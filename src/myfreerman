#!/bin/bash

set -e
RELEASE=2.5.12

function backup()
{
	local OPTIND l_opt
	while getopts "h" opt; do
		case $opt in
			h)
				help_backup
				return
				;;
			\?)
				echo "Invalid option: -$OPTARG" >&2
				main_help
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if [ $# -lt 1 ]; then
		help_backup
		return 1
	fi
	check_config_backup || return 1
	BINLOG_BACKUP_DIR="$BACKUP_DIR/binlog"
	BASE_BACKUP_DIR="$BACKUP_DIR/base"
	TMP_BACKUP_DIR="$BACKUP_DIR/tmp"

	if [ $READ_ONLY -eq 1 ]; then
		write_out "Read-only mode is enabled in configuration"
		return 1
	fi

	ERR_LOG=`mktemp /tmp/myfreerman.XXXXXX`
	mysqladmin --defaults-file="$SERVER_CONFIG" --socket="$SERVER_SOCKET" $TARGET_CRED_OPT status >/dev/null 2>$ERR_LOG
	RC=$?
	write_file_out "$ERR_LOG"
	rm "$ERR_LOG"
	[ $RC -eq 0 ] || return 1

	if ! which mysqlbackup >/dev/null 2>&1; then
		write_out "Cannot find 'mysqlbackup' in PATH"
		return 1
	fi
	BKP_TYPE=`echo $1 | awk '{print tolower($0)}'`
	shift
	BINLOG_PREFIX=`mysql --socket="$SERVER_SOCKET" $TARGET_CRED_OPT -e "show variables like 'log_bin_basename'" | tail -n 1 | cut -f 2 -d$'\t'` || return 1
	BINLOG_DIR="`dirname \"$BINLOG_PREFIX\"`" || return 1
	DATADIR=`mysql --socket="$SERVER_SOCKET" $TARGET_CRED_OPT -e "show variables like 'datadir'" | tail -n 1 | cut -f 2 -d$'\t'` || return 1
	case $BKP_TYPE in
		full)
			backup_full $* || return 1
			;;
		binlog)
			backup_binlog $* || { return 1; }
			;;
		*)
			echo "Invalid backup type '$BKP_TYPE'" >&2
			help_backup
			return 1
			;;
	esac
	[ $REPORT_FINISHED -eq 0 ] || write_out "Finished"
}

function backup_binlog()
{
	local OPTIND l_opt
	KEEP_BINLOGS=0
	while getopts "hk" opt; do
		case $opt in
			h)
				help_backup_binlog
				return
				;;
			k)
				KEEP_BINLOGS=1
				break;;
			\?)
				help_backup_binlog
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if [ $# -ne 0 ]; then
		help_backup_binlog
		return 1
	fi
	if ! exist_base_backup; then
		write_out "No full backup was previously done"
		return 1
	fi

	lock_binlog_lock || return 1

	#create binlog backup dir
	mkdir -p "$BINLOG_BACKUP_DIR" || return 1

	#flush logs
	write_out "Flushing binary logs"
	BUFF=`mktemp /tmp/myfreerman.XXXXXX`
	mysqladmin --defaults-file="$SERVER_CONFIG" --socket="$SERVER_SOCKET" $TARGET_CRED_OPT flush-logs binary >"$BUFF" 2>&1
	RC=$?
	write_file_out "$BUFF"
	rm "$BUFF"
	if [ $RC -ne 0 ]; then
		return 1
	fi

	BINLOG_PREFIX="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION log_bin 2>/dev/null`"
	if [ -n "$BINLOG_PREFIX" ]; then
		BINLOG_DIR="`dirname $BINLOG_PREFIX`" || return 1
		BINLOG_BNAME="`basename $BINLOG_PREFIX`" || return 1
	fi

	crosscheck_binlogs || return 1

	#list binlogs, just ignoring the last one
	LIST_FILE=`mktemp /tmp/myfreerman.XXXXXX` || return 1
	mysql --socket="$SERVER_SOCKET" $TARGET_CRED_OPT -e "show binary logs\G" | grep -wi log_name | cut -d \  -f 3 >$LIST_FILE || { return 1; }
			
	TOTAL=`cat $LIST_FILE | wc -l` || { return 1; }
	COUNT=$((TOTAL - 1))
	LIST=`head -n $COUNT $LIST_FILE`
	LAST_BINLOG=`tail -n 1 $LIST_FILE`
	rm $LIST_FILE
	ERR_LOG=`mktemp /tmp/myfreerman.XXXXXX`
	for BINLOG in $LIST; do
		if ! [ -f "$BINLOG_BACKUP_DIR/${BINLOG}.gz" ]; then
			LONG_LOGSEQ=`echo $BINLOG | cut -d . -f 2`
			LOGSEQ=`expr $LONG_LOGSEQ + 0`
			write_out "Saving binary log #${LOGSEQ}"
			BKP="$BINLOG_BACKUP_DIR/${BINLOG}.gz"
			TMP_OUT="${BKP}.tmp"
			gzip -c9 "$BINLOG_DIR/$BINLOG" >"$TMP_OUT" 2>$ERR_LOG
			RC=$?
			write_file_out $ERR_LOG
			[ $RC -eq 0 ] || { rm $ERR_LOG; return 1; }

			#rename tmp to final
			mv "$TMP_OUT" "$BKP" 2>$ERR_LOG
			RC=$?
			write_file_out $ERR_LOG
			[ $RC -eq 0 ] || { rm $ERR_LOG; return 1; }
		fi
	done
	rm $ERR_LOG
	check_purge_binlogs $LAST_BINLOG || { return 1; }
	remove_tmp_binlog_backups
	lock_binlog_unlock || return 1
}

function backup_full()
{
	local OPTIND l_opt
	while getopts "d:h" opt; do
		case $opt in
			d)
				BACKUP_DIR="$OPTARG"
				;;
			h)
				help_backup_full
				return
				;;
			\?)
				help_backup_full
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if  [ $# -ne 0 ]; then
		help_backup_full
		return 1
	fi
	if ! [ -d "$BACKUP_DIR" ]; then
		write_out "Cannot find directory '$BACKUP_DIR'"
		return 1
	fi
	cd "$BACKUP_DIR" || return 1

	mkdir -p "$TMP_BACKUP_DIR" || return 1
	mkdir -p "$BASE_BACKUP_DIR" || return 1
	DATE_VAL=`date +%Y-%m-%d`
	TIME_VAL=`date +%H-%M-%S`
	TIMESTAMP=${DATE_VAL}_${TIME_VAL}
	TMP_DIRECTORY="${TMP_BACKUP_DIR}/${TIMESTAMP}" || return 1
	mkdir "${TMP_DIRECTORY}" || return 1
	DIRECTORY="${BASE_BACKUP_DIR}/${TIMESTAMP}" || return 1
	LIM_MEM_OPT=`mount_limit_memory_option`

	#disable buffer pool dump?
	DISABLE_BUFFER_POOL_DUMP_OPT=
	if [ $DISABLE_BUFFER_POOL_DUMP -eq 1 ]; then
		DISABLE_BUFFER_POOL_DUMP_OPT="--backup_innodb_buffer_pool_filename="
	fi

	if [ -n "$LOG_FILE" ]; then
		TMP_LOG=`mktemp /tmp/myfreerman.XXXXXX` || return 1
		write_out "===== STARTING MEB - Log: $TMP_LOG ====="
		mysqlbackup --defaults-file="$SERVER_CONFIG" --socket="$SERVER_SOCKET" $TARGET_CRED_OPT --limit-memory=$BACKUP_LIMIT_MEMORY --read-threads=$BACKUP_READ_THREADS --process-threads=$BACKUP_PROCESS_THREADS --write-threads=$BACKUP_WRITE_THREADS --backup-dir="${TMP_DIRECTORY}" $LIM_MEM_OPT $DISABLE_BUFFER_POOL_DUMP_OPT --skip-binlog backup-and-apply-log >$TMP_LOG 2>&1 
		RETCODE=$?
		cat $TMP_LOG
		cat $TMP_LOG >>"$LOG_FILE"
		rm $TMP_LOG
		if [ $RETCODE -ne 0 ]; then
			rm -fr "$TMP_DIRECTORY"
			return 1
		fi
	else
		write_out "===== STARTING MEB ====="
		mysqlbackup --defaults-file="$SERVER_CONFIG" --socket="$SERVER_SOCKET" $TARGET_CRED_OPT --limit-memory=$BACKUP_LIMIT_MEMORY --read-threads=$BACKUP_READ_THREADS --process-threads=$BACKUP_PROCESS_THREADS --write-threads=$BACKUP_WRITE_THREADS --backup-dir="${TMP_DIRECTORY}" $LIM_MEM_OPT $DISABLE_BUFFER_POOL_DUMP_OPT --skip-binlog backup-and-apply-log
		RETCODE=$?
		if [ $RETCODE -ne 0 ]; then
			rm -fr "${TMP_DIRECTORY}"
			return 1
		fi
	fi
	#move tmp directory to permanent dst
	mv "${TMP_DIRECTORY}" "${BASE_BACKUP_DIR}" || return 1
	LAST_BACKUP=`ls "${BASE_BACKUP_DIR}" | tail -n 1` || return 1
	fix_backup_timestamp $LAST_BACKUP || return 1

	write_out "Removing stale temporary data"
	remove_stale_temp_data
}

function do_apply_binlog()
{
	SOCKET="$1"
	BASE_BACKUP="$2"
	TARGET_CRED_OPT=`mount_target_credentials_opt`
	if [ $USE_AUX_INSTANCE -eq 0 ]; then
		FPATH="$WORKING_DIR/restore.ini"
		VALIDATED=`crudini --get "$FPATH" recovery validated` 2>/dev/null
		if [ "$VALIDATED" != "1" ]; then
			write_out "No previous restore done -- aborting"
			return 1
		fi
		REQ_TIMESTAMP_NO_SPACE=`crudini --get "$FPATH" recovery requested_timestamp 2>/dev/null`
		REQ_TIMESTAMP="${REQ_TIMESTAMP_NO_SPACE/_/ }"
		BASE_BACKUP=`crudini --get "$FPATH" recovery base_backup 2>/dev/null`
		if [ -z "$BASE_BACKUP" ]; then
			write_out "Cannot find base backup in working file!!!"
			return 1
		fi
	fi
	if [ -z "$BASE_BACKUP" ]; then
		write_out "No backup found"
		return 1
	fi

	TMP_SQL=`mktemp /tmp/myfreerman.XXXXXX`
	LOGSEQ=`get_base_backup_binlog_sequence $BASE_BACKUP`
	POSITION=`get_base_backup_binlog_position $BASE_BACKUP`
	INST_TYPE="restricted"
	if [ $USE_AUX_INSTANCE -eq 1 ]; then
		INST_TYPE="aux"
	fi
	mysql_start || return 1
	ERR_LOG=`mktemp /tmp/myfreerman.XXXXXX`
	FIRST=1
	while binlog_backup_exists $LOGSEQ; do
		rm $TMP_SQL || return 1
		touch $TMP_SQL || return 1
		write_out "Applying binary log #${LOGSEQ}"
		read_binlog $LOGSEQ $POSITION "$REQ_TIMESTAMP" $TMP_SQL
		ERR=$?
		if [ $ERR -eq 0 ]; then
			mysql $TARGET_CRED_OPT --socket="$SOCKET" <"$TMP_SQL" 2>$ERR_LOG
			ERR=$?
			write_file_out $ERR_LOG
		fi
		if [ $ERR -ne 0 ]; then
			mysql_stop
			if [ $FIRST -eq 1 ]; then
				write_out "Binary logs cannot be applied. This might be caused by a misconfiguration in database credentials. Please review your configuration and try 'myfreerman apply binlog'."
			else
				write_out "Some binary logs were applied, but there was an error in the middle of the process. I really don't know what to do. Please check all your logs, binary log sequences and data."
			fi
			rm $TMP_SQL $ERR_LOG
			return 1
		fi
		LOGSEQ=`expr $LOGSEQ + 1`
		POSITION=0
		FIRST=0
		FPATH="$WORKING_DIR/restore.ini"
		crudini --del "$FPATH" recovery base_backup 2>/dev/null
		crudini --del "$FPATH" recovery restore_time 2>/dev/null
		crudini --del "$FPATH" recovery requested_timestamp 2>/dev/null
		crudini --del "$FPATH" recovery validated 2>/dev/null
	done
	rm $TMP_SQL $ERR_LOG
}

function help()
{
	echo "$0 <options> <command>"
	echo "- Options: [ -h ] [ -c <config file> ] [ -l <log file format> ] [ -q ] [ -y ]"
	echo "  -h: display this help"
	echo "  -c: use a specific config file"
	echo "  -l: specify format for log file name"
	echo "  -q: quiet mode - do not print release information"
	echo "  -y: assume YES for all questions"
	echo "- Commands:"
   echo "  apply"
   echo "  backup"
   echo "  drop"
   echo "  flashback"
   echo "  init"
   echo "  list"
   echo "  metadata"
   echo "  promote"
   echo "  recover"
   echo "  remove"
   echo "  restore"
}

function help_backup()
{
	REPORT_FINISHED=0
	echo "* Make backups"
	echo "- Options: [ -h ]"
	echo "  -h: display this help and exit"
	echo "- Parameters:"
	echo "	binlog"
	echo "	full"
}

function help_backup_binlog()
{
	REPORT_FINISHED=0
	echo "* Backup binary logs"
	echo "- Options: [ -h ] [ -k ]"
	echo "  -h: display this help and exit"
	echo "  -k: do backup but keep binary logs in database instance"
	echo "- Parameters:"
}

function help_backup_full()
{
	REPORT_FINISHED=0
	echo "* Backup full database"
	echo "- Options: [ -h ] [ -d <dir> ]"
	echo "  -h: display this help and exit"
	echo "  -d: save backup in <dir>, instead of directory set in configuration"
	echo "- Parameters:"
}

function help_drop()
{
	REPORT_FINISHED=0
	echo "* Drop data from local server"
	echo "- Options: [ -h ]"
	echo "  -h: display this help and exit"
	echo "- Parameters:"
	echo "   database"
}

function help_drop_database()
{
	REPORT_FINISHED=0
	echo "* Drop current database - datafiles, redo, undo, binary logs and relay logs"
	echo "- Options: [ -h ]"
	echo "  -h: display this help and exit"
	echo "- Parameters:"
}

function help_init()
{
	REPORT_FINISHED=0
	echo "* Initialize a database"
	echo "- Options: [ -h ]"
	echo "  -h: display this help and exit"
	echo "- Parameters:"
	echo "   database"
	echo "   replica"
}

function help_init_database
{
	REPORT_FINISHED=0
	echo "* Initialize a new empty database"
	echo "- Options: [ -h ]"
	echo "  -h: display this help and exit"
	echo "- Parameters:"
}

function help_init_replica
{
	echo "* Initialize a new replica"
	echo "- Options: [ -h ] -m <master host>[:<port>] -u <user> -d <directory>"
	echo "  -h: display this help and exit"
	echo "  -m: use master in <master host>[:<port>]"
	echo "  -u: use <user> to connect to master instance"
	echo "  -d: restore master backup from <directory>"
	echo "- Parameters:"
}

function help_apply()
{
	echo "* Apply binary logs"
	echo "   apply binlog"
}

function help_apply_binlog()
{
	echo "* Apply binary logs to a recently restored database"
	echo "* This is used when binary logs could not be applied in RESTORE command, for example due to invalid credentials"
}

function help_flashback()
{
	echo "* Flashback data to a specific moment in the past"
	echo "	flashback table"
}

function help_flashback_table()
{
	echo "* Flashback a table to a specific moment in the past. Multithreading is supported - number of threads is set in 'process_threads' config"
	echo "	flashback table <database>.<table>[:<new table name>] <timestamp>"
	echo "	   database: database that has the table"
	echo "	   table: table name"
	echo "	      optional new table name to receive the result"
   echo "      <timestmap>: hhmm | ddhhmm | MMddhhmm | yyyy-MM-dd_hh:mm:ss"
   echo "         hh: hour, mm: minute, dd: day, MM: month, yyyy: year, ss: second"
}

function help_metadata()
{
	echo "* Retrieve metadata from latest full backup"
	echo "- Options: [ -h ]"
	echo "  -h: display this help and exit"
	echo "- Parameters:"
}

function help_promote()
{
	echo "* Promote local instance to master"
	echo "Event scheduler is disabled in old master and enabled in new master"
	echo "- Options: [ -h ]"
	echo "  -h: display this help and exit"
	echo "- Parameters:"
}

function help_recover()
{
	echo "* Recover data"
	echo "	recover replica"
	echo "		Apply needed binary logs in replica, using master backup directory"
}

function help_recover_replica()
{
	echo "* Apply needed binary logs in replica, using master backup directory"
	echo "	recover replica <dir>"
	echo "		<dir>: master backup directory"
}

function help_remove()
{
	echo "* Remove backups"
	echo "	remove expired"
	echo "		expired: Remove expired backups, according to retention policy set in configuration"
}

function help_restore()
{
	echo "* Restore data from backup"
	echo "   restore config"
	echo "   restore database"
}

function help_restore_config()
{
	echo "* Restore server configuration from backup"
	echo "** Configuration is printed to standard output"
   echo "   restore config [ -o <dir> ] [ -p <timestamp> ]"
   echo "      -o use backup saved in <dir>, and not directory set in configuration"
   echo "      -p restore config in use in <timestmap>"
   echo "         <timestmap>: hhmm | ddhhmm | MMddhhmm | yyyy-MM-dd_hh:mm:ss"
   echo "            hh: hour, mm: minute, dd: day, MM: month, yyyy: year, ss: second"
}

function help_restore_database()
{
	echo "* Restore a database from backup"
   echo "   restore database [ -n ] [ -o <dir> ] [ -p <timestamp> ] [ -R ] [ -s <schema>[:<new name>] ] | [ -t <schema1.table1[:<new name>]> [ -t <schema2.table2[:<new name>] [ ... ] ] ]"
   echo "      -n do not create a new database incarnation"
   echo "      -o use backup saved in <dir>, and not directory set in configuration (also, do not create a new database incarnation)"
   echo "      -p restore until <timestmap>"
   echo "         <timestmap>: hhmm | ddhhmm | MMddhhmm | yyyy-MM-dd_hh:mm:ss"
   echo "            hh: hour, mm: minute, dd: day, MM: month, yyyy: year, ss: second"
   echo "      -R Do not apply binlogs"
   echo "      -s Restore only specific schema (optionally using a new name)"
   echo "      -t Restore only specific table (optionally using a new name)"
   echo "         Multiple -t options are allowed"
}

function help_list()
{
	echo "* List backups or binlog events"
	echo "   list [ -r <hostname> ] full"
	echo "      List full backups"
	echo "   list [ -r <hostname> ] binlog"
	echo "      List binlog backups"
	echo "   list events"
	echo "      List binlog events"
	echo
	echo "   OPTIONS:"
	echo "      -r List backups that are saved in remote host <hostname>"
}

function help_list_events
{
	echo "* List events in binary logs"
	echo "   list events [ -b <binlog> ] [ -h ] [ -m <min> ] [ -s <timestamp> ] [ -e <timestamp> ]"
	echo "      Output table contains the following colums: binlog sequence number, date, time, operation, manipulated table, packet size (Mb)"
	echo "      Minimum params are -s or -m"
	echo "      -b: List events in binlog file <binlog>"
	echo "      -h: Show this help"
	echo "      -m: List events generated by local server in the last <min> minutes"
	echo "         Cannot be used with -s or -e"
	echo "      -e: List events occurred before <timestamp>"
   echo "     	   Require -s option"
	echo "         Cannot be used with -m"
   echo "     	   <timestmap>: hhmm | ddhhmm | MMddhhmm | yyyy-MM-dd_hh:mm:ss"
   echo "            hh: hour, mm: minute, dd: day, MM: month, yyyy: year, ss: second"
	echo "      -s: List events occurred after <timestamp>"
	echo "         Cannot be used with -m"
   echo "     	   <timestmap>: hhmm | ddhhmm | MMddhhmm | yyyy-MM-dd_hh:mm:ss"
   echo "            hh: hour, mm: minute, dd: day, MM: month, yyyy: year, ss: second"

}

function help_list_transactions
{
	echo "* List transactions from binary logs"
	echo "   list transactions [ -h ] [ -d <schema> ] [ -m <min> ] [ -s <timestamp> ] [ -e <timestamp> ]"
	echo "      Output table contains the following colums: transaction start time, <total>, <table details>"
	echo "         total: total number of rows affected by the transaction"
	echo "         table details: list of each table affected, followed by number of INSERTs, UPDATEs and DELETEs on the table"
	echo "      Minimum params are -s or -m"
	echo "      -h: Show this help"
	echo "      -d: Set default schema to <schema>. Tables in this schema are not gonna be qualified, in generated list"
	echo "      -m: List transactions executed in the last <min> minutes"
	echo "         Cannot be used with -s or -e"
	echo "      -e: List transactions executed before <timestamp>"
   echo "     	   Require -s option"
	echo "         Cannot be used with -m"
   echo "     	   <timestmap>: hhmm | ddhhmm | MMddhhmm | yyyy-MM-dd_hh:mm:ss"
   echo "            hh: hour, mm: minute, dd: day, MM: month, yyyy: year, ss: second"
	echo "      -s: List transactions executed after <timestamp>"
	echo "         Cannot be used with -m"
   echo "     	   <timestmap>: hhmm | ddhhmm | MMddhhmm | yyyy-MM-dd_hh:mm:ss"
   echo "            hh: hour, mm: minute, dd: day, MM: month, yyyy: year, ss: second"
}

function binlog_backup_exists()
{
	if ! [ -d "$BINLOG_BACKUP_DIR" ]; then
		return 1
	fi
	LOGSEQ=$1
	LONG_LOGSEQ=`seq -f "%06g" $LOGSEQ $LOGSEQ`
	BINLOG="$BINLOG_BACKUP_DIR/binlog.${LONG_LOGSEQ}"
	if [ -f "${BINLOG}" ]; then
		return 0
	fi
	if [ -f "${BINLOG}.gz" ]; then
		return 0
	fi
	return 1
}

function binlog_exists()
{
	LOGSEQ=$1
	LONG_LOGSEQ=`seq -f "%06g" $LOGSEQ $LOGSEQ`
	FILEPATH="${BINLOG_PREFIX}.$LONG_LOGSEQ"
	if [ -f "$FILEPATH" ]; then
		return 0
	fi
	return 1
}


function check_aux_binaries()
{
	if ! which mysqld >/dev/null 2>&1; then
		echo "Cannot find 'mysqld' in PATH" >&2
		return 1
	fi
	if ! which mysqldump >/dev/null 2>&1; then
		echo "Cannot find 'mysqldump' in PATH" >&2
		return 1
	fi
}

function check_aux_dir_space()
{
	DIR=$1
	BKP_SIZE=`du -s -m "$DIR/datadir" | cut -f 1`
	REQ_SIZE=`expr $BKP_SIZE + 100`
	FREE_SIZE=`df -m $AUX_BASEDIR | tail -n 1 | tr -s ' ' | cut -d ' ' -f 4` || return 1
	if [ $FREE_SIZE -lt $REQ_SIZE ]; then
		echo "Not enough space in $AUX_BASEDIR - a minimum of ${REQ_SIZE}M is required" >&2
		return 1
	fi
}

function check_backup_consistency()
{
	write_out "Checking backup consistency"
	if ! [ -d "$BASE_BACKUP_DIR" ]; then
		return
	fi
	cd "$BASE_BACKUP_DIR" || return 1
	for BKP in `ls`; do
		if [ -d "$BKP" ]; then
			if ! consistent_backup "$BKP"; then
				rm -r "$BKP"
			fi
		fi
	done
}

function check_config()
{
	#LOG_DIR
	#if -l option used, log_dir is required
	if [ -n "$LOG_FILE_BASENAME" -a -z "$LOG_DIR" ]; then
		echo "Configuration variable 'log_dir' is required when log file is defined" >&2
		return 1
	fi

	#LOG_DIR - if defined, must exist
	if [ -n "$LOG_DIR" ]; then
		if ! [ -d "$LOG_DIR" ]; then
			echo "'$LOG_DIR': no such directory" >&2
			return 1
		fi
	fi

	#READ_ONLY - must be 0 or 1
	if [ "$READ_ONLY" != "0" -a "$READ_ONLY" != "1" ]; then
		echo "Configuration 'read_only' must be 0 or 1" >&2
		return 1
	fi

	#backup limit memory - must be 20 to 2048
	if [ $BACKUP_LIMIT_MEMORY -lt 20 -o $BACKUP_LIMIT_MEMORY -gt 2048 ]; then
		write_out "Configuration 'backup_limit_memory' must be between 20 and 2048"
		return 1
	fi

	#backup process threads - must be 1 to 15
	if [ $BACKUP_PROCESS_THREADS -lt 1 -o $BACKUP_PROCESS_THREADS -gt 15 ]; then
		write_out "Configuration 'backup_process_threads' must be between 1 and 30"
		return 1
	fi

	#process threads - must be 1 to 30
	if [ $PROCESS_THREADS -lt 1 -o $PROCESS_THREADS -gt 30 ]; then
		write_out "Configuration 'process_threads' must be between 1 and 30"
		return 1
	fi

	#backup read threads
	if [ $BACKUP_READ_THREADS -lt 1 -o $BACKUP_READ_THREADS -gt $MAX_READ_THREADS ]; then
		echo "Configuration 'backup_read_threads' must be between 1 and $MAX_READ_THREADS" >&2
		return 1
	fi

	#restore read threads
	if [ $RESTORE_READ_THREADS -lt 1 -o $RESTORE_READ_THREADS -gt $MAX_READ_THREADS ]; then
		echo "Configuration 'restore_read_threads' must be between 1 and $MAX_READ_THREADS" >&2
		return 1
	fi

	#backup write threads
	if [ $BACKUP_WRITE_THREADS -lt 1 -o $BACKUP_WRITE_THREADS -gt $MAX_WRITE_THREADS ]; then
		echo "Configuration 'backup_write_threads' must be between 1 and $MAX_WRITE_THREADS" >&2
		return 1
	fi

	#restore write threads
	if [ $RESTORE_WRITE_THREADS -lt 1 -o $RESTORE_WRITE_THREADS -gt $MAX_WRITE_THREADS ]; then
		echo "Configuration 'restore_write_threads' must be between 1 and $MAX_WRITE_THREADS" >&2
		return 1
	fi

	#disable buffer pool dump
	if [ "$DISABLE_BUFFER_POOL_DUMP" != "0" -a "$DISABLE_BUFFER_POOL_DUMP" != "1" ]; then
		echo "Configuration 'disable_buffer_pool_dump' must be 0 or 1" >&2
		return 1
	fi

	#use rclone
	if [ "$USE_RCLONE" != "0" -a "$USE_RCLONE" != "1" ]; then
		echo "Configuration 'use_rclone' must be 0 or 1" >&2
		return 1
	fi
	#if enabled, rclone must be found
	if [ $USE_RCLONE -eq 1 ]; then
		if ! which rclone >/dev/null 2>&1; then
			write_out "RCLONE not found. If you do not plan to use it, please disable it in config file."
			return 1
		fi
	fi
}

function check_config_backup()
{
	#BACKUP_DIR
	if [ -z "$BACKUP_DIR" ]; then
		echo "Configuration 'backup_dir' is required" >&2
		return 1
	fi
	if [ ! -d "$BACKUP_DIR" ]; then
		echo "'$BACKUP_DIR': no such directory" >&2
		return 1
	fi

}

function check_config_list()
{
	if [ -z "$LIST_REMOTE_HOST" ]; then
		#BACKUP_DIR
		if [ -z "$BACKUP_DIR" ]; then
			echo "Configuration 'backup_dir' is required" >&2
			return 1
		fi
		if [ ! -d "$BACKUP_DIR" ]; then
			echo "'$BACKUP_DIR': no such directory" >&2
			return 1
		fi
	fi
}

function check_depends()
{
	#crudini
	if ! rpm -q crudini >/dev/null 2>&1; then
		write_out "Cannot find package 'crudini'"
		return 1
	fi
}

function check_empty_target_database()
{
	#datadir must be empty
	#if ls -d "$DATADIR"/* >/dev/null 2>&1; then
		#write_out "Data directory [$DATADIR] must be empty"
		#return 1
	#fi

	#check there is no binary log
	if [ -n "$BINLOG_PREFIX" ] && ls "$BINLOG_PREFIX"* >/dev/null 2>&1; then
		write_out "No binary logs [${BINLOG_PREFIX}*] should exist"
		return 1
	fi

	#binlog index file must not exist
	if [ -n "$BINLOG_INDEX" -a -f "$BINLOG_INDEX" >/dev/null 2>&1 ]; then
		write_out "Binary log index [$BINLOG_INDEX] must not exist"
		return 1
	fi

	#check there is no relay log
	if [ -n "$RELAY_LOG_PREFIX" ] && ls "$RELAY_LOG_PREFIX"* >/dev/null 2>&1; then
		write_out "No relay logs [${RELAY_LOG_PREFIX}*] should exist"
		return 1
	fi

	#relay log index file must not exist
	if [ -n "$RELAY_LOG_INDEX" -a -f "$RELAY_LOG_INDEX" ]; then
		write_out "Relay log index [$RELAY_LOG_INDEX] must not exist"
		return 1
	fi
}

function check_purge_binlogs()
{
	if [ $KEEP_BINLOGS -eq 1 ]; then
		write_out "Keeping binary logs in instance"
		return 0
	fi
	if [ -n "$SLAVE_SERVER" -a $USE_AUX_INSTANCE -eq 0 ]; then
		LIMIT_LOG=`get_current_replica_binlog`
	else
		LIMIT_LOG=$1
	fi
	if [ $? -ne 0 ]; then
		write_out "Cannot contact replica instance - no binary log will be purged"
		return
	fi
	if [ -z "$LIMIT_LOG" ]; then
		write_out "Cannot retrieve replica server's current status - no binary log will be purged"
		return
	fi
	purge_binlogs $LIMIT_LOG || return 1
}

function check_target_instance_config()
{
	write_out "Checking target instance configuration"

	#innodb force recovery cannot be active
	INNODB_FORCE_RECOVERY="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION innodb_force_recovery 2>/dev/null`"
	if [ -n "$INNODB_FORCE_RECOVERY" ]; then
		if [ $INNODB_FORCE_RECOVERY -gt 0 ]; then
			write_out "Option INNODB_FORCE_RECOVERY must be disabled"
			return 1
		fi
	fi

	#pid file
	PID_FILE="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION pid_file 2>/dev/null`"
	#create pid file's folder and set owner
	if [ -n "$PID_FILE" ]; then
		DNAME="`dirname $PID_FILE`" || return 1
		mkdir -p "$DNAME" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DNAME" || return 1
		fi
	fi

	#general log file
	GENERAL_LOG_FILE="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION general_log_file 2>/dev/null`"
	if [ -n "$GENERAL_LOG_FILE" ]; then
		DNAME="`dirname $GENERAL_LOG_FILE`" || return 1
		mkdir -p "$DNAME" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DNAME" || return 1
		fi
	fi

	#create directory for binlog index
	if [ -n "$BINLOG_INDEX" ]; then
		DN="`dirname \"$BINLOG_INDEX\"`"
		mkdir -p "$DN" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DN" || return 1
		fi
	fi

	#create directory for binlogs
	if [ -n "$BINLOG_DIR" ]; then
		mkdir -p "$BINLOG_DIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$BINLOG_DIR" || return 1
		fi
	fi
	
	#create directory for relay log index
	if [ -n "$RELAY_LOG_INDEX" ]; then
		DN="`dirname \"$RELAY_LOG_INDEX\"`"
		mkdir -p "$DN" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DN" || return 1
		fi
	fi

	#create directory for relay logs
	if [ -n "$RELAY_LOG_DIR" ]; then
		mkdir -p "$RELAY_LOG_DIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$RELAY_LOG_DIR" || return 1
		fi
	fi

	#tmp directory
	TMP_DIRECTORY="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION tmpdir 2>/dev/null`"
	if [ -n "$TMP_DIRECTORY" ]; then
		mkdir -p "$TMP_DIRECTORY" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$TMP_DIRECTORY" || return 1
		fi
	fi

	LOG_ERROR="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION log_error 2>/dev/null`"
	if [ -z "$LOG_ERROR" ]; then
		write_out "MySQL configuration mysqld:log_error cannot be empty"
		return 1
	fi
	PID_FILE="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION pid_file 2>/dev/null`"
	if [ -z "$PID_FILE" ]; then
		write_out "MySQL configuration mysqld:pid_file cannot be empty"
		return 1
	fi
	if ! which mysqld >/dev/null 2>&1; then
		write_out "Cannot find 'mysqld' executable file"
		return 1
	fi
	TMP_LOG=`mktemp /tmp/myfreerman.XXXXXX` || return 1
	TMP_CONF=`mktemp /tmp/myfreerman.XXXXXX` || return 1
	grep -v "^audit" "$SERVER_CONFIG" >$TMP_CONF || return 1
	if ! mysqld --defaults-group-suffix=$MYSQL_DEFAULT_GROUP_SUFFIX --defaults-file="$TMP_CONF" --initialize >>"$TMP_LOG" 2>&1; then
		write_out "Cannot check target instance configuration. Check server output in '$TMP_LOG' and logs in '$LOG_ERROR'."
		drop_target_database
		rm $TMP_LOG $TMP_CONF
		return 1
	fi
	rm $TMP_LOG
	mysqld --defaults-group-suffix=$MYSQL_DEFAULT_GROUP_SUFFIX --defaults-file="$TMP_CONF" --bind-address=127.0.0.1 --daemonize
	RC=$?
	kill_pid "$PID_FILE"
	sleep 2
	rm $TMP_CONF
	drop_target_database
	[ $RC -eq 0 ] || return 1
}

function confirm_operation()
{
	if [ $ANSWER_YES -eq 1 ]; then
		return 0
	fi
	echo -n "Are you sure? (You must type 'yes' to confirm): "
	read ANSWER
	LANSWER=`echo "$ANSWER" | awk '{print tolower($0)}'`
	if [ "$LANSWER" == "yes" ]; then
		return 0
	fi
	return 1
}

function consistent_backup()
{
	TMP_BKP_DIR="$1"
	TMP_BACKUP_VARS="$TMP_BKP_DIR/meta/backup_variables.txt"
	if ! [ -f "$TMP_BACKUP_VARS" ]; then
		return 1
	fi
	TMP_APPLY_LOG_DONE="`crudini --get \"$TMP_BACKUP_VARS\" backup_variables apply_log_done`" || return 1
	if [ "$TMP_APPLY_LOG_DONE" != "1" ]; then
		return 1
	fi
	return 0
}

function copy_recovered_db()
{
	write_out "Copying restored schema from aux instance"
	mysql --socket="$SERVER_SOCKET" $TARGET_CRED_OPT -e "create database if not exists $RESTORE_SCHEMA_NEW_NAME;" >/dev/null || return 1
	mysqldump --socket=$AUX_SOCKET --no-create-db --routines --events --triggers --set-gtid-purged=off $RESTORE_SCHEMA_OLD_NAME | mysql --socket="$SERVER_SOCKET" $TARGET_CRED_OPT $RESTORE_SCHEMA_NEW_NAME || return 1
}

function copy_restored_tables()
{
	TARGET_CRED_OPT=`mount_target_credentials_opt`
	write_out "Copying restored tables from aux instance"
	for QT in $RESTORE_TABLE_LIST; do
		if ! echo "$QT" | grep \\. >/dev/null; then
			echo "Invalid table name: '$QT' - table names must be qualified with schema" >&2
			return 1
		fi
		SCHEMA=`echo $QT | cut -d . -f 1`
		TABLE=`echo $QT | cut -d . -f 2`
		ORIG_TABLE=`echo $TABLE | cut -d \: -f 1`
		NEW_TABLE=`echo $TABLE | cut -d \: -f 2`
		if [ -z "$NEW_TABLE" ]; then
			NEW_TABLE=$ORIG_TABLE
		fi
		write_out "    ${QT}"
		mysqldump --defaults-file=$AUX_CONFIG --skip-lock-tables --no-create-db --routines --events --triggers --set-gtid-purged=off $SCHEMA $ORIG_TABLE | \
				sed	-e s/^\\\(drop\ table\ if\ exists\ \\\)\`$ORIG_TABLE\`/\\1\`$NEW_TABLE\`/i \
						-e s/^\\\(create\ table\ \\\)\`$ORIG_TABLE\`/\\1\`$NEW_TABLE\`/i \
						-e s/^\\\(insert\ into\ \\\)\`$ORIG_TABLE\`/\\1\`$NEW_TABLE\`/i \
						-e s/^\\\(lock\ tables\ \\\)\`$ORIG_TABLE\`/\\1\`$NEW_TABLE\`/i \
						-e s/^\\\(.*alter\ table\ \\\)\`$ORIG_TABLE\`/\\1\`$NEW_TABLE\`/i \
						| mysql --socket="$SERVER_SOCKET" $TARGET_CRED_OPT $SCHEMA || return 1
	done
}

function create_aux_config()
{
	DIR=$1
	if [ -z "$AUX_BASEDIR" ]; then
		echo "Cannot find 'basedir' in '$RMAN_CONFIG'" >&2
		return 1
	fi
	if ! [ -d "$AUX_BASEDIR" ]; then
		echo "'$AUX_BASEDIR' is not a directory (or access is denied)" >&2
		return 1
	fi
	TARGET_CRED_OPT=`mount_target_credentials_opt`
	TARGET_BASEDIR=`mysql --socket="$SERVER_SOCKET" $TARGET_CRED_OPT -e "show variables like 'basedir'" | tail -n 1 | cut -f 2 -d$'\t'`
	LC_MESSAGES_DIR=`mysql --socket="$SERVER_SOCKET" $TARGET_CRED_OPT -e "show variables like 'lc_messages_dir'" | tail -n 1 | cut -f 2 -d$'\t'`
	LOWER_CASE_TABLE_NAMES=`mysql --socket="$SERVER_SOCKET" $TARGET_CRED_OPT -e "show variables like 'lower_case_table_names'" | tail -n 1 | cut -f 2 -d$'\t'`
	echo "[$SERVER_INI_SECTION]" >$AUX_CONFIG
	echo "datadir=${AUX_DATADIR}" >>$AUX_CONFIG
	echo "explicit_defaults_for_timestamp=1" >>$AUX_CONFIG
	echo "innodb_buffer_pool_size=10M" >>$AUX_CONFIG
	echo "innodb_data_home_dir="$AUX_DATADIR >>$AUX_CONFIG
	echo "innodb_log_group_home_dir=$AUX_REDODIR" >>$AUX_CONFIG
	echo "innodb_undo_directory=$AUX_UNDODIR" >>$AUX_CONFIG
	echo "lc_messages_dir=$LC_MESSAGES_DIR" >>$AUX_CONFIG
	echo "lc_messages=en_US" >>$AUX_CONFIG
	echo "log_bin=${AUX_BINLOG_PREFIX}" >>$AUX_CONFIG
	echo "log_bin_index=${AUX_BINLOG_INDEX}" >>$AUX_CONFIG
	echo "log_bin_trust_function_creators=on" >>$AUX_CONFIG
	echo "log_error=$AUX_LOG_ERROR" >>$AUX_CONFIG
	echo "log_timestamps=system" >>$AUX_CONFIG
	echo "lower_case_table_names=$LOWER_CASE_TABLE_NAMES" >>$AUX_CONFIG
	echo "max_allowed_packet=128M" >>$AUX_CONFIG
	echo "mysqlx=0" >>$AUX_CONFIG
	echo "pid_file=$AUX_PID_FILE" >>$AUX_CONFIG
	echo "port=$AUX_PORT" >>$AUX_CONFIG
	#relay log (prefix)
	if [ -n "$AUX_RELAY_LOG_PREFIX" ]; then
		echo "relay_log=$AUX_RELAY_LOG_PREFIX" >>$AUX_CONFIG
	fi
	#relay log (index)
	if [ -n "$AUX_RELAY_LOG_INDEX" ]; then
		echo "relay_log_index=$AUX_RELAY_LOG_INDEX" >>$AUX_CONFIG
	fi
	echo "socket=$AUX_SOCKET" >>$AUX_CONFIG
	echo "skip-grant-tables=1" >>$AUX_CONFIG
	echo "user=mysql" >>$AUX_CONFIG

	#copy GTID params to aux config
	ENFORCE_GTID_CONSISTENCY=`mysql --socket="$SERVER_SOCKET" $TARGET_CRED_OPT -e "show variables like 'enforce_gtid_consistency'" | tail -n 1 | cut -f 2 -d$'\t'`
	echo "enforce_gtid_consistency=$ENFORCE_GTID_CONSISTENCY" >>$AUX_CONFIG

	GTID_MODE=`mysql --socket="$SERVER_SOCKET" $TARGET_CRED_OPT -e "show variables like 'gtid_mode'" | tail -n 1 | cut -f 2 -d$'\t'`
	echo "gtid_mode=$GTID_MODE" >>$AUX_CONFIG

	echo "[mysql]" >>$AUX_CONFIG
	echo "port=$AUX_PORT" >>$AUX_CONFIG
	echo "socket=$AUX_SOCKET" >>$AUX_CONFIG
	echo "[mysqldump]" >>$AUX_CONFIG
	echo "max_allowed_packet=128M" >>$AUX_CONFIG
	echo "port=$AUX_PORT" >>$AUX_CONFIG
	echo "socket=$AUX_SOCKET" >>$AUX_CONFIG
}

function create_incarnation()
{
	write_out "Creating new backup incarnation"
	MOMENT=$1
	RESTORE_DIR=$RESTORE_BACKUP_DIR/$MOMENT
	mkdir -p "$RESTORE_DIR" || return 1
	BASE_BACKUP_DIR="$BACKUP_DIR/base"
	BINLOG_BACKUP_DIR="$BACKUP_DIR/binlog"
	ERR_LOG=`mktemp /tmp/myfreerman.XXXXXX` || return 1
	if [ -d "$BASE_BACKUP_DIR" ]; then
		mv "$BASE_BACKUP_DIR" "$RESTORE_DIR" 2>$ERR_LOG || { rm $ERR_LOG; return 1; }
	fi
	if [ -d "$BINLOG_BACKUP_DIR" ]; then
		mv "$BINLOG_BACKUP_DIR" "$RESTORE_DIR" 2>$ERR_LOG || { rm $ERR_LOG; return 1; }
	fi
	rm $ERR_LOG
}

function crosscheck_binlogs()
{
	write_out "Crosschecking binary logs"
	CUR_SEQ=`get_current_master_binlog_sequence` || { write_out "Cannot find information about current server binlogs"; return 1; }

	#each sequence in backup that is higher =>remove
	LIST=`ls "$BINLOG_BACKUP_DIR" 2>/dev/null`
	[ -n "$LIST" ] || return 0
	for F in $LIST; do
		LONG_SEQ=`echo $F | cut -d . -f 2`
		[ -n "$LONG_SEQ" ] || continue
		if [ $LONG_SEQ -gt $CUR_SEQ ]; then
			SHORT_SEQ=`expr $LONG_SEQ + 0`
			write_out "   Removing obsolete backup of binary log #${SHORT_SEQ}"
			rm "$BINLOG_BACKUP_DIR"/$F 2>/dev/null
		fi
	done
}

function drop_target_database()
{
	if [ -n "$REDODIR" ]; then
		fs_remove_directory_contents "$REDODIR" || return 1
	fi
	if [ -n "$UNDODIR" ]; then
		fs_remove_directory_contents "$UNDODIR" || return 1
	fi
	if [ -n "$BINLOG_PREFIX" ]; then
		rm -f "$BINLOG_PREFIX"* || return 1
	fi
	if [ -n "$RELAY_LOG_PREFIX" ]; then
		rm -f "$RELAY_LOG_PREFIX"* || return 1
	fi
	if [ -n "$BINLOG_INDEX" ]; then
		rm -f "$BINLOG_INDEX" || return 1
	fi
	if [ -n "$RELAY_LOG_INDEX" ]; then
		rm -f "$RELAY_LOG_INDEX" || return 1
	fi
	fs_remove_directory_contents "$DATADIR" || return 1
}

function exiting()
{
	lock_binlog_unlock
}

function expand_logfile_path()
{
	date "+$1"
}

function expand_timestamp()
{
	TS=$1
	if [ ${#TS} -eq 4 ]; then
		H=${TS:0:2}
		M=${TS:2:2}
		date +%Y-%m-%d_${H}:${M}:00 || return 1
		return
	fi
	if [ ${#TS} -eq 6 ]; then
		D=${TS:0:2}
		H=${TS:2:2}
		M=${TS:4:2}
		date +%Y-%m-${D}_${H}:${M}:00 || return 1
		return
	fi
	if [ ${#TS} -eq 8 ]; then
		MON=${TS:0:2}
		D=${TS:2:2}
		H=${TS:4:2}
		MIN=${TS:6:2}
		date +%Y-${MON}-${D}_${H}:${MIN}:00 || return 1
		return
	fi
	echo $TS
}

function exist_base_backup()
{
	if ! [ -d "$BASE_BACKUP_DIR" ]; then
		return 1
	fi
	COUNT=`ls "$BASE_BACKUP_DIR" | wc -l`
	if [ $COUNT -eq 0 ]; then
		return 1
	fi
	return 0
}

function get_backup_timestamp()
{
	BACKUP="$1"
	END_TIME_UTC=`grep -w "end_time_utc" "${BASE_BACKUP_DIR}/${BACKUP}/meta/backup_variables.txt" | cut -d '=' -f 2 | cut -d ':' -f 1`
	if [ -z "$END_TIME_UTC" ]; then
		write_out "Can't find timestamp when backup was finished"
		return 1
	fi
	#unit time is in first 10 chars
	UNIX_TIME=${END_TIME_UTC:0:10}
	date -d @${UNIX_TIME} +%Y-%m-%d_%H-%M-%S
}

get_binlog_last_event_timestamp()
{
	SQL="$1"
	BUFF=`mktemp /tmp/myfreerman.XXXXXX`
	grep -A 1 "^# at " "$SQL" >$BUFF
	LINE=`tail -n 1 $BUFF`
	rm $BUFF
	Y="20${LINE:1:2}"
	M="${LINE:3:2}"
	D="${LINE:5:2}"
	DATE="$Y-$M-$D"
	TIME="${LINE:8:8}"
	echo "$DATE $TIME"
}

function get_server_config()
{
	CONFIG_NAME=$1
	CMD="select @@${CONFIG_NAME}\G"
	BUFF=`mktemp /tmp/myfreerman.XXXXXX`
	mysql -N --socket="$SERVER_SOCKET" $TARGET_CRED_OPT -e "$CMD" >$BUFF || { rm $BUFF; return 1; }
	RC=$?
	tail -n 1 $BUFF
	rm $BUFF
	return $?
}

function find_aux_port()
{
	FIRST_PORT=10000
	LAST_PORT=19999
	RANGE=`expr $LAST_PORT - $FIRST_PORT`
	while true; do
		PORT=$RANDOM
		let "PORT %= $RANGE"
		PORT=`expr $PORT + $FIRST_PORT`
		if port_available $PORT; then
			echo $PORT
			return
		fi
	done
}

function find_base_backup()
{
	REQ_TIMESTAMP="$1"

	#if not pitr, simply pick most recent
	if [ -z "$REQ_TIMESTAMP" ]; then
		ls "$BASE_BACKUP_DIR" | tail -n 1
		return
	fi

	FMT_REQ_TIMESTAMP=`date --date="$1" +%Y%m%d%H%M%S` || return 1
	for BKP in `ls -r "$BASE_BACKUP_DIR" | cut -d . -f 1`; do
		DATE=${BKP:0:10}
		TIME=${BKP:11:8}
		TIME=${TIME//-/:}
		BKP_FMT_TS="$DATE $TIME"
		BKP_TIMESTAMP=`date --date="$BKP_FMT_TS" +%Y%m%d%H%M%S`
		if [ $BKP_TIMESTAMP -le $FMT_REQ_TIMESTAMP ]; then
			echo $BKP
			return
		fi
	done
}

function fix_backup_timestamp()
{
	OLD_NAME=$1
	NEW_NAME=`get_backup_timestamp $OLD_NAME` || return 1
	#move only if theu have differente names
	if [ "$OLD_NAME" != "$NEW_NAME" ]; then
		mv "${BASE_BACKUP_DIR}/${OLD_NAME}" "${BASE_BACKUP_DIR}/${NEW_NAME}" || return 1
	fi
}

function flashback()
{
	local OPTIND l_opt
	while getopts "h" l_opt; do
		case $l_opt in
			h)
				help_flashback
				return
				;;
			\?)
				help_flashback
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if [ $# -eq 0 ]; then
		help_flashback
		return 1
	fi

	CMD=$1
	shift
	BINLOG_BACKUP_DIR="$BACKUP_DIR/binlog"
	case $CMD in
		table)
			flashback_table $* || return 1
			;;
		*)
			echo "Invalid flashback command: $CMD" >&2
			return 1
			;;
	esac
	[ $REPORT_FINISHED -eq 0 ] || write_out "Finished"
}

function flashback_table()
{
	local OPTIND l_opt
	while getopts "h" l_opt; do
		case $l_opt in
			h)
				help_flashback_table
				return
				;;
			\?)
				help_flashback_table
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if [ $# -ne 2 ]; then
		help_flashback_table
		return 1 
	fi

	DATABASE=`echo $1 | cut -d . -f 1`
	COMPLETE_TABLE_NAME=`echo $1 | cut -d . -f 2`
	TABLE_NAME=`echo $COMPLETE_TABLE_NAME | cut -d : -f 1`
	FQ_TABLE_NAME=$DATABASE.$TABLE_NAME
	NEW_TABLE_NAME=`echo $COMPLETE_TABLE_NAME | cut -d : -f 2`
	FQ_NEW_TABLE_NAME=$DATABASE.$NEW_TABLE_NAME

	#if new table chosen, it cannot exist
	if [ "$NEW_TABLE_NAME" != "$TABLE_NAME" ]; then
		MOD_SH="$MYFREERMAN_MOD_DIR/catalog.sh"
		source "$MOD_SH" || return 1
		table_exists $DATABASE $NEW_TABLE_NAME
		RETVAL=$?
		[ $RETVAL -ge 0 ] || return 1
		[ $RETVAL -eq 0 ] || { write_out "New table name exists - cannot continue"; return 1; }
	fi

	USER_TIMESTAMP=$2
	REQ_TIMESTAMP=`expand_timestamp $USER_TIMESTAMP | sed -e 's/_/ /'` || return 1
	write_out "Requested timestamp: $REQ_TIMESTAMP"
	confirm_operation
	flashback_run || return 1
}

function get_base_backup_binlog_name()
{
	BACKUP=$1
	grep -w "binlog_position" $BASE_BACKUP_DIR/$BACKUP/meta/backup_variables.txt | cut -d '=' -f 2 | cut -d ':' -f 1 || return 1
}

function get_base_backup_binlog_sequence()
{
	BACKUP=$1
	BINLOG=`get_base_backup_binlog_name $BACKUP`
	get_binlog_sequence $BINLOG || return 1
}

function get_base_backup_binlog_position()
{
	BACKUP=$1
	grep -w "binlog_position" $BASE_BACKUP_DIR/$BACKUP/meta/backup_variables.txt | cut -d '=' -f 2 | cut -d ':' -f 2 || return 1
}

function get_binlog_path()
{
	LOGSEQ=$1
	LONG_LOGSEQ=`seq -f "%06g" $LOGSEQ $LOGSEQ`
	BINLOG=binlog.$LONG_LOGSEQ

	#search in backup
	if [ -f "$BINLOG_BACKUP_DIR/$BINLOG" ]; then
		echo "$BINLOG_BACKUP_DIR/$BINLOG"
		return
	fi

	#search in backup (compressed)
	if [ -f "$BINLOG_BACKUP_DIR/$BINLOG.gz" ]; then
		echo "$BINLOG_BACKUP_DIR/$BINLOG.gz"
		return
	fi

	#search in server repository
	if [ -f "${BINLOG_PREFIX}.$LONG_LOGSEQ" ]; then
		echo "${BINLOG_PREFIX}.$LONG_LOGSEQ"
		return
	fi

	echo "Cannot find binary log $LOGSEQ anywhere" >&2
	return 1
}

function get_binlog_sequence()
{
	BINLOG=$1
	LONG_LOGSEQ=`echo $BINLOG | cut -d . -f 2`
	expr $LONG_LOGSEQ + 0
}

function get_binlog_transaction_timestamp()
{
	BINLOG=$1
	POSITION=$2

	PLAIN_BINLOG=/$BINLOG
	TMP_BINLOG=
	if file $PLAIN_BINLOG | grep -w gzip >/dev/null; then
		TMP_BINLOG=`mktemp /tmp/myfreerman.XXXXXX` || return 1
		PLAIN_BINLOG=$TMP_BINLOG
		gunzip -c $BINLOG >$PLAIN_BINLOG
	fi
	TMP_SQL=`mktemp /tmp/myfreerman.XXXXXX` || return 1
	mysqlbinlog --defaults-file="$SERVER_CONFIG" $PLAIN_BINLOG >$TMP_SQL || return 1
	if [ -n "$TMP_BINLOG" ]; then
		rm $TMP_BINLOG
	fi
	LINE=`grep "^#.*end_log_pos $POSITION" $TMP_SQL` || return 1
	rm $TMP_SQL
	TIMESTAMP="${LINE:1:15}"
	date -d"$TIMESTAMP" +%Y-%m-%d_%H-%M-%S
}

function get_mysql_main_help()
{
	BACKUP=$1
	grep -w "mysql_main_help" $BASE_BACKUP_DIR/$BACKUP/meta/backup_variables.txt | cut -d '=' -f 2 | cut -d '.' -f 1 || return 1
}

function get_oldest_full_backup()
{
	cd "$BACKUP_DIR" || return 1
	mkdir -p "$BASE_BACKUP_DIR" || return 1
	cd "$BASE_BACKUP_DIR" || return 1
	ls | head -n 1
}

function get_current_master_binlog_sequence()
{
	BUFF=`mktemp /tmp/myfreerman.XXXXXX`
	ERR=`mktemp /tmp/myfreerman.XXXXXX`
	mysql --socket="$SERVER_SOCKET" $TARGET_CRED_OPT -e 'show master status\G' | grep -vwi warning >$BUFF 2>$ERR
	RC=$?
	write_file_out $ERR
	rm $ERR
	#check if output is not empty
	SIZE=`stat -c %s $BUFF`
	if [ $SIZE -eq 0 ]; then
		return 1
	fi
	[ $RC -eq 0 ] || { rm $BUFF; return 1; }
	LONG_SEQ=`grep -wi file $BUFF | awk '{ print $2; }' | cut -d . -f 2`
	rm $BUFF
	expr $LONG_SEQ + 0
}

function get_current_replica_binlog()
{
	MIN_LOG=999999
	SLAVE_SERVERS=`echo $SLAVE_SERVER | tr "," "\n"`
	for S in $SLAVE_SERVERS; do
		SLAVE_HOSTNAME=`echo $S | cut -d \: -f 1`
		SLAVE_PORT=`echo $S | cut -d \: -f 2`
		if [ -z  "$SLAVE_PORT" ]; then
			SLAVE_PORT=3306
		fi
		CRED_OPT=`mount_target_credentials_opt`

		#before getting replica status, check if we can reach it
		RESULT=1
		if mysqladmin --defaults-file="$SERVER_CONFIG" --host=${SLAVE_HOSTNAME} --port=${SLAVE_PORT} $CRED_OPT status >/dev/null; then
			CUR_LOG=`mysql --host=${SLAVE_HOSTNAME} --port=${SLAVE_PORT} $SLAVE_CRED_OPT -e "show replica status\G" | grep -i relay_source_log_file | cut -d :  -f 2 | sed -e 's/ //'`
			if [ $? -ne 0 ]; then
				return $?
			fi
			CUR_LOG=`echo $CUR_LOG | cut -d . -f 2`
			if [ -z "$CUR_LOG" ]; then
				return 1
			fi
			CUR_LOG=`expr $CUR_LOG + 0`
			if [ $CUR_LOG -lt $MIN_LOG ]; then
				MIN_LOG=$CUR_LOG
			fi
		else
			return 1
		fi
	done

	#decrement one, because sometimes it looses sync and master purges an unapplied binlog
	MIN_LOG=$((MIN_LOG-1))

	LONG_LOGSEQ=`seq -f "%06g" $MIN_LOG $MIN_LOG`
	echo ${BINLOG_BNAME}.${LONG_LOGSEQ}
	return 0
}

function header()
{
	write_out "myfreerman - Free Recovery Manager for MySQL - Release $RELEASE - Host $MYHOST"
}

function kill_pid()
{
	PID_FILE="$1"
	[ -f "$PID_FILE" ] || return 0
	PID=`cat "$PID_FILE"`
	kill $PID
	sleep 1
	COUNT=1
	while kill -0 $PID 2>/dev/null; do
		COUNT=$((COUNT + 1))
		if [ $COUNT -ge $KILL_WAIT_TIMEOUT ]; then
			return 1
		fi
		sleep 1
	done
}

function drop()
{
	local OPTIND l_opt
	while getopts "h" l_opt; do
		case $l_opt in
			h)
				help_drop
				return
				;;
			\?)
				help_drop
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if [ $# -lt 1 ]; then
		help_drop
		return 1
	fi
	CMD=$1
	shift
	case $CMD in
		database)
			drop_database $* || return 1
			;;
		*)
			echo "Invalid drop command: $CMD" >&2
			help_drop
			return 1
			;;
	esac
	[ $REPORT_FINISHED -eq 0 ] || write_out "Finished"
}

function drop_database()
{
	local OPTIND l_opt
	while getopts "h" l_opt; do
		case $l_opt in
			h)
				help_drop_database
				return
				;;
			\?)
				help_drop_database
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if [ $# -gt 0 ]; then
		help_drop_database
		return 1
	fi
	PID_FILE="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION pid_file 2>/dev/null`"
	if [ -f "$PID_FILE" ]; then
		PID=`cat "$PID_FILE"`
		if kill -0 $PID; then
			write_out "Server is running - cannot drop database"
			return 1
		fi
	fi
	if ! confirm_operation; then
		return 1
	fi
	write_out "Dropping database"

	#datadir
	DATADIR="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION datadir`" 2>/dev/null
	if [ "$DATADIR" == "/" ]; then
		write_out "Invalid data directory (datadir)"
		return 1
	fi
	if [ -n "$DATADIR" ]; then
		fs_remove_directory_contents "$DATADIR" || return 1
	fi

	#redo
	REDODIR="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION innodb_log_group_home_dir 2>/dev/null`"
	if [ "$REDODIR" == "/" ]; then
		write_out "Invalid redo directory"
		return 1
	fi
	if [ -n "$REDODIR" ]; then
		fs_remove_directory_contents "$REDODIR" || return 1
	fi

	#undo
	UNDODIR="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION innodb_undo_directory 2>/dev/null`"
	if [ "$UNDODIR" == "/" ]; then
		write_out "Invalid undo directory"
		return 1
	fi
	if [ -n "$UNDODIR" ]; then
		rm -fr "$UNDODIR/"* || return 1
	fi

	#binlog index file
	BINLOG_INDEX="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION log_bin_index 2>/dev/null`"
	if [ -n "$BINLOG_INDEX" ]; then
		rm -f "$BINLOG_INDEX" || return 1
	fi

	#relay index file
	RELAY_LOG_INDEX="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION relay_log_index 2>/dev/null`"
	if [ -n "$RELAY_LOG_INDEX" ]; then
		rm -f "$RELAY_LOG_INDEX" || return 1
	fi

	#binlogs directory
	BINLOG_PREFIX="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION log_bin 2>/dev/null`"
	if [ -n "$BINLOG_PREFIX" ]; then
		rm -f "${BINLOG_PREFIX}"* || return 1
	fi

	#relay logs directory
	RELAY_LOG_PREFIX="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION relay_log 2>/dev/null`"
	if [ -n "$RELAY_LOG_PREFIX" ]; then
		rm -f "${RELAY_LOG_PREFIX}"* || return 1
	fi

	#innodb temp tablespaces directory
	INNODB_TEMP_TABLESPACES_DIR="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION innodb_temp_tablespaces_dir 2>/dev/null`"
	if [ -n "$INNODB_TEMP_TABLESPACES_DIR" ]; then
		 fs_remove_directory_contents "${INNODB_TEMP_TABLESPACES_DIR}" || return 1
	fi
}

function init()
{
	local OPTIND l_opt
	while getopts "h" l_opt; do
		case $l_opt in
			h)
				help_init
				return
				;;
			\?)
				help_init
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if [ $# -eq 0 ]; then
		help_init
		return 1
	fi

	CMD=$1
	shift
	case $CMD in
		database)
			init_database $* || return 1
			;;
		replica)
			init_replica $* || return 1
			;;
		*)
			help_init
			return 1
			;;
	esac
}

function init_database()
{
	local L_BKP
	local OPTIND l_opt

	while getopts "h" l_opt; do
		case $l_opt in
			h)
				help_init_database
				return
				;;
			\?)
				help_init_database
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))

	if [ $# -ne 0 ]; then
		help_init_database
		return 1
	fi

	CONFIG="$SERVER_CONFIG"
	#error log is required
	LOG_ERROR="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION log_error 2>/dev/null`"
	if [ -z "$LOG_ERROR" ]; then
		write_out "Configuration 'log_error' in server configuration is required"
		return 1
	fi

	#mysqld user
	MYSQLD_USER="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION user 2>/dev/null`"

	#create log error file
	DNAME="`dirname $LOG_ERROR`" || return 1
	mkdir -p "$DNAME" || return 1
	if [ -n "$MYSQLD_USER" ]; then
		chown $MYSQLD_USER "$DNAME" || return 1
	fi
	touch "$LOG_ERROR" || return 1
	if [ -n "$MYSQLD_USER" ]; then
		chown $MYSQLD_USER "$LOG_ERROR" || return 1
	fi

	#datadir
	DATADIR="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION datadir`" 2>/dev/null
	if [ -n "$DATADIR" ]; then
		mkdir -p "$DATADIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DATADIR" || return 1
		fi
	fi

	#redo
	REDODIR="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION innodb_log_group_home_dir 2>/dev/null`"
	if [ -n "$REDODIR" ]; then
		mkdir -p "$REDODIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$REDODIR" || return 1
		fi
	fi

	#undo
	UNDODIR="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION innodb_undo_directory 2>/dev/null`"
	if [ -n "$UNDODIR" ]; then
		mkdir -p "$UNDODIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$UNDODIR" || return 1
		fi
	fi

	#binlog index file
	BINLOG_INDEX="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION log_bin_index 2>/dev/null`"
	if [ -n "$BINLOG_INDEX" ]; then
		DNAME="`dirname $BINLOG_INDEX`" || return 1
		mkdir -p "$DNAME" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DNAME" || return 1
		fi
	fi

	#relay index file
	RELAY_LOG_INDEX="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION relay_log_index 2>/dev/null`"
	if [ -n "$RELAY_LOG_INDEX" ]; then
		DNAME="`dirname $RELAY_LOG_INDEX`" || return 1
		mkdir -p "$DNAME" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DNAME" || return 1
		fi
	fi

	#binlogs directory
	BINLOG_PREFIX="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION log_bin 2>/dev/null`"
	if [ -n "$BINLOG_PREFIX" ]; then
		BINLOG_DIR="`dirname $BINLOG_PREFIX`" || return 1
		BINLOG_BNAME="`basename $BINLOG_PREFIX`" || return 1
		mkdir -p "$BINLOG_DIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$BINLOG_DIR" || return 1
		fi
	fi

	#relay logs directory
	RELAY_LOG_PREFIX="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION relay_log 2>/dev/null`"
	if [ -n "$RELAY_LOG_PREFIX" ]; then
		RELAY_LOG_DIR="`dirname $RELAY_LOG_PREFIX`" || return 1
		mkdir -p "$RELAY_LOG_DIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$RELAY_LOG_DIR" || return 1
		fi
	fi

	#secure files directory
	SECURE_DIR="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION secure_file_priv 2>/dev/null`"
	if [ -n "$SECURE_DIR" ]; then
		mkdir -p "$SECURE_DIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$SECURE_DIR" || return 1
			chmod 700 "$SECURE_DIR" || return 1
		fi
	fi

	#tmp directory
	TMP_DIRECTORY="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION tmpdir 2>/dev/null`"
	if [ -n "$TMP_DIRECTORY" ]; then
		mkdir -p "$TMP_DIRECTORY" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$TMP_DIRECTORY" || return 1
		fi
	fi

	#innodb temp tablespaces directory
	INNODB_TEMP_TABLESPACES_DIR="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION innodb_temp_tablespaces_dir 2>/dev/null`"
	if [ -n "$INNODB_TEMP_TABLESPACES_DIR" ]; then
		mkdir -p "$INNODB_TEMP_TABLESPACES_DIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$INNODB_TEMP_TABLESPACES_DIR" || return 1
		fi
	fi

	#slow query log file
	SLOW_QUERY_LOG_FILE="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION slow_query_log_file 2>/dev/null`"
	if [ -n "$SLOW_QUERY_LOG_FILE" ]; then
		DNAME="`dirname $SLOW_QUERY_LOG_FILE`" || return 1
		mkdir -p "$DNAME" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DNAME" || return 1
		fi
	fi

	#general log file
	GENERAL_LOG_FILE="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION general_log_file 2>/dev/null`"
	if [ -n "$GENERAL_LOG_FILE" ]; then
		DNAME="`dirname $GENERAL_LOG_FILE`" || return 1
		mkdir -p "$DNAME" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DNAME" || return 1
		fi
	fi

	#server socket
	SOCKET="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION socket 2>/dev/null`"
	#create socket's folder and set owner
	if [ -n "$SERVER_SOCKET" ]; then
		DNAME="`dirname $SERVER_SOCKET`" || return 1
		mkdir -p "$DNAME" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DNAME" || return 1
		fi
	fi

	#pid file
	PID_FILE="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION pid_file 2>/dev/null`"
	#create pid file's folder and set owner
	if [ -n "$PID_FILE" ]; then
		DNAME="`dirname $PID_FILE`" || return 1
		mkdir -p "$DNAME" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DNAME" || return 1
		fi
	fi

	echo -n "Please enter initial password for root: "
	read NEW_PASSWORD

	#run initialize
	write_out "Creating server repository"
	if ! mysqld --defaults-group-suffix=$MYSQL_DEFAULT_GROUP_SUFFIX --defaults-file="$SERVER_CONFIG" --initialize; then
		write_out "Cannot create server repository. Please check mysql log at '$LOG_ERROR'."
		return 1
	fi
	LINE=`grep -w password "$LOG_ERROR" | tail -n 1`
	PASSWORD=`echo ${LINE##* }`
	write_out "Temp password: $PASSWORD"

	INST_TYPE=init
	mysql_start || return 1

	write_out "Running initial config commands"
	#create tmp file with commands
	SQL=`mktemp /tmp/myfreerman.XXXXXX`
	echo "alter user root@localhost identified by '$NEW_PASSWORD';" >>$SQL
	echo "update mysql.user set host = '%' where user = 'root' and host = 'localhost';" >>$SQL
	echo "flush privileges;" >>$SQL
	echo "grant resource_group_admin, backup_admin on *.* to root;" >>$SQL

	#create expect script
	EXPECT_SCRIPT=`mktemp /tmp/myfreerman.XXXXXX`
	echo "spawn mysql -S $SOCKET --connect-expired-password -u root -p -e \"source $SQL\"" >$EXPECT_SCRIPT
	echo "expect \" password:\"" >>$EXPECT_SCRIPT
	echo "send \"$PASSWORD\\r\"" >>$EXPECT_SCRIPT
	echo "interact" >>$EXPECT_SCRIPT
	BUFF=`mktemp /tmp/myfreerman.XXXXXX`
	expect $EXPECT_SCRIPT >$BUFF 2>&1
	RC=$?
	rm $EXPECT_SCRIPT $SQL
	mysql_stop
	cat $BUFF >&2
	if [ $RC -ne 0 ]; then
		rm $BUFF
		return 1
	fi
	rm $BUFF
	[ $REPORT_FINISHED -eq 0 ] || write_out "Finished"
}

function init_replica()
{
	local OPTIND l_opt
	while getopts "d:hm:u:" l_opt; do
		case $l_opt in
			d)
				BACKUP_DIRECTORY="$OPTARG"
				;;
			h)
				help_init_replica
				return 0
				;;
			m)
				MASTER_HOST=$OPTARG
				;;
			u)
				REPL_USERNAME=$OPTARG
				;;
			\?)
				help_init_replica
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))

	if [ $# -ne 0 ]; then
		help_init_replica
		return 1
	fi

	if [ -z "$BACKUP_DIRECTORY" ]; then
		write_out "Option -d is required"
		return 1
	fi
	if [ -z "$MASTER_HOST" ]; then
		write_out "Option -m is required"
		return 1
	fi
	if [ -z "$REPL_USERNAME" ]; then
		write_out "Option -u is required"
		return 1
	fi

	REPORT_FINISHED=0
	MASTER_PORT=`echo $MASTER_HOST | cut -s -d \: -f 2`
	if [ -z "$MASTER_PORT" ]; then
		MASTER_PORT=3306
	else
		MASTER_HOST=`echo $MASTER_HOST | cut -s -d \: -f 1`
	fi
	CONFIG="$SERVER_CONFIG"

	#test auth with admin user (from config)
	TARGET_CRED_OPT=`mount_target_credentials_opt` || return 1
	if ! mysqladmin --defaults-file="$SERVER_CONFIG" -h $MASTER_HOST -P $MASTER_PORT $TARGET_CRED_OPT status >/dev/null; then
		write_out "Cannot connect to master server using credentials from configuration"
		return 1
	fi

	read -s -p "Replication user password: " REPL_PASSWD
	if [ -z "$REPL_PASSWD" ]; then
		return 1
	fi

	#test auth with replication user
	if ! mysqladmin --defaults-file="$SERVER_CONFIG" -h $MASTER_HOST -P $MASTER_PORT -u $REPL_USERNAME -p"${REPL_PASSWD}" status >/dev/null; then
		return 1
	fi

	ANSWER_YES=1
	restore database -n -o "$BACKUP_DIRECTORY" || exit 1

	#start server
	INST_TYPE=replica
	mysql_start || return 1

	SOCKET="`crudini --get \"$SERVER_CONFIG\" $INI_SECTION socket 2>/dev/null`"
	TARGET_CRED_OPT=`mount_target_credentials_opt` || return 1

	#mount command to config replica
	write_out "Setting new replica configuration"
	CMD="reset replica all";
	if ! mysql --socket="$SERVER_SOCKET" $TARGET_CRED_OPT -e "$CMD"; then
		mysql_stop || return 1
		return 1
	fi
	CMD="change replication source to source_host='$MASTER_HOST', source_port=$MASTER_PORT, source_auto_position=1, source_ssl=1, source_user='$REPL_USERNAME', source_password='$REPL_PASSWD'";
	if ! mysql --socket="$SERVER_SOCKET" $TARGET_CRED_OPT -e "$CMD"; then
		mysql_stop || return 1
		return 1
	fi
	start_replica || { mysql_stop; return 1; }
	sleep 10
	mysql --socket="$SERVER_SOCKET" $TARGET_CRED_OPT -e "show replica status\G" | grep -E "Slave_SQL_Running_State|Last_IO_Error|Seconds_Behind_Master|Slave_IO_State"
	mysql_stop
	[ $REPORT_FINISHED -eq 0 ] || write_out "Finished"
}

function list()
{
	LIST_REMOTE_HOST=
	local OPTIND l_opt
	while getopts "hr:" l_opt; do
		case $l_opt in
			h)
				help_list
				return
				;;
			r)
				LIST_REMOTE_HOST=${OPTARG}
				;;
			\?)
				help_list
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if [ $# -lt 1 ]; then
		help_list
		return 1
	fi
	CMD=$1
	shift
	check_config_list || return 1
	if [ -n "$LIST_REMOTE_HOST" ]; then
		list_remote $CMD || return 1
		return
	fi
	case $CMD in
		events)
			list_events $* || return 1;;
		full)
			list_full || return 1
			;;
		binlog)
			list_binlog || return 1
			;;
		transactions)
			list_transactions $* || return 1
			;;
		*)
			help_list
			return 1
			;;
	esac
}

function list_binlog()
{
	BINLOG_BACKUP_DIR="$BACKUP_DIR/binlog"
	mkdir -p "$BINLOG_BACKUP_DIR" || return 1
	echo -e SEQUENCE '\t' DATE '\t\t' TIME
	echo "-----------------------------------------"
	LIST=`ls "$BINLOG_BACKUP_DIR"`
	for F in $LIST; do
		FULL="${BINLOG_BACKUP_DIR}/${F}"
		BINLOG=`echo $F | cut -d . -f 2`
		LOGSEQ=`expr $BINLOG + 0`
		BKP_FMT_TS="`stat -c %y "$FULL" | cut -d . -f 1`"
		DATE=${BKP_FMT_TS:0:10}
		TIME=${BKP_FMT_TS:11:8}
		echo -e $LOGSEQ '\t\t' $DATE '\t' $TIME
	done
}

function list_binlog_remote()
{
	ssh -q -o "StrictHostKeyChecking=no" $LIST_REMOTE_HOST MYSQL_SID=$MYSQL_SID myfreerman -q list binlog
}

function list_events()
{
	MINUTES=
	DETAILED=0
	START_TIME=
	END_TIME=
	local OPTIND l_opt
	while getopts "b:dhm:s:e:" l_opt; do
		case $l_opt in
			b)
				BINLOG_FILE="$OPTARG";;
			d)
				DETAILED=1;;
			h)
				help_list_events
				return
				;;
			m)
				MINUTES=$OPTARG;;
			s)
				START_TIME=$OPTARG;;
			e)
				END_TIME=$OPTARG;;
			\?)
				help_list_events
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if [ $# -ne 0 ]; then
		help_list_events
		return 1
	fi
	binlog_do_list_events || return 1
}

function list_full()
{
	BASE_BACKUP_DIR="$BACKUP_DIR/base"
	mkdir -p "$BASE_BACKUP_DIR" || return 1
	echo -e DATE '\t\t' TIME
	echo "-------------------------"
	LIST=`ls "$BASE_BACKUP_DIR"`
	for BKP in $LIST; do
		DATE=${BKP:0:10}
		TIME=${BKP:11:8}
		TIME=${TIME//-/:}
		echo -e $DATE '\t' $TIME
	done
}

function list_full_remote()
{
	ssh -q -o "StrictHostKeyChecking=no" $LIST_REMOTE_HOST MYSQL_SID=$MYSQL_SID myfreerman -q list full
}

function list_remote()
{
	REMOTE_USER=`whoami`
	REMOTE_INST=`echo $REMOTE_HOST | cut -d . -f 1`
	CMD=$1
	case $CMD in
		full)
			list_full_remote || return 1
			;;
		binlog)
			list_binlog_remote || return 1
			;;
		*)
			help_list_remote
			return 1
			;;
	esac
}

function list_server_binlogs()
{
	LIST_FILE=`mktemp /tmp/myfreerman.XXXXXX` || return 1
	mysql --socket="$SERVER_SOCKET" $TARGET_CRED_OPT -e "show binary logs\G" | grep -wi log_name | cut -d \  -f 3 >$LIST_FILE || { return 1; }
	cat $LIST_FILE
	rm $LIST_FILE
}

function list_transactions()
{
	MINUTES=
	DETAILED=0
	START_TIME=
	#default end time is now
	END_TIME=
	DEFAULT_SCHEMA=
	local OPTIND l_opt
	while getopts "hd:m:s:e:" l_opt; do
		case $l_opt in
			h)
				help_list_transactions
				return
				;;
			d)
				DEFAULT_SCHEMA=$OPTARG;;
			m)
				MINUTES=$OPTARG;;
			s)
				START_TIME=$OPTARG;;
			e)
				END_TIME=$OPTARG;;
			\?)
				help_list_transactions
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if [ $# -ne 0 ]; then
		help_list_transactions
		return 1
	fi
	binlog_do_list_transactions || return 1
}

function load_modules()
{
	for F in "$MYFREERMAN_MOD_DIR"/*; do
		source "$F" || return 1
	done
}

function metadata()
{
	local L_BINLOG
	local L_METAFILE
	local L_OPT
	local L_OPTIND
	local L_SEQ

	while getopts "h" L_OPT; do
		case $L_OPT in
			h)
				help_promote
				return 0
				;;
			\?)
				help_promote
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if [ $# -ne 0 ]; then
		help_metadata
		return 1
	fi
	BASE_BACKUP_DIR="$BACKUP_DIR/base"
	DIR=`find_base_backup ""` || return 1
	if [ -z "$DIR" ]; then
		write_out "No backup found"
		return 1
	fi
	METAFILE=$BASE_BACKUP_DIR/$DIR/meta/backup_variables.txt
	BINLOG_POSITION=`grep -wi binlog_position $METAFILE | cut -d = -f 2`
	BINLOG=`echo $BINLOG_POSITION | cut -d : -f 1`
	SEQ=`echo $BINLOG_POSITION | cut -d : -f 2`
	echo "Timestamp: $DIR"
	echo "Binlog: $BINLOG"
	echo "Sequence: $SEQ"
}

function mount_credentials_opt()
{
	RESULT=
	if [ -n "$DB_USERNAME" ]; then
		RESULT="$RESULT --user=$DB_USERNAME"
	fi
	if [ $USE_AUX_INSTANCE -eq 1 ]; then
		return
	fi
	if [ -n "$DB_PASSWORD" ]; then
		if [ -n "$RESULT" ]; then
			RESULT="$RESULT"
		fi
		RESULT="${RESULT}--password=$DB_PASSWORD"
	fi
	echo -n "$RESULT"
}

function mount_limit_memory_option()
{
	if [ -n "$MAX_MEM" ]; then
		echo "--limit-memory=$MAX_MEM"
	fi
}

function mount_target_credentials_opt()
{
	RESULT=
	if [ -n "$DB_USERNAME" ]; then
		RESULT="--user=$DB_USERNAME"
	fi
	echo -n "$RESULT"
}

function mount_aux_defaults_file_opt()
{
	if [ $USE_AUX_INSTANCE -eq 1 ]; then
		echo "--defaults-file=$AUX_CONFIG"
	fi
}

function mysql_start()
{
	LOG_ERROR="`crudini --get \"$CONFIG\" $SERVER_INI_SECTION log_error 2>/dev/null`"
	CMD="mysqld"
	OPTS="--defaults-group-suffix=$MYSQL_DEFAULT_GROUP_SUFFIX --defaults-file="$CONFIG" --bind-address=127.0.0.1 --console --super-read-only=off --event-scheduler=off --disable-log-bin --skip-replica-start --daemonize"
	write_out "Starting server (${INST_TYPE})"
	BUFF=`mktemp /tmp/myfreerman.XXXXXX`
	$CMD $OPTS >"$LOG_ERROR" >$BUFF 2>&1
	RC=$?
	cat $BUFF
	rm $BUFF
	return $RC
}

function mysql_stop()
{
	PID_FILE="`crudini --get \"$CONFIG\" $SERVER_INI_SECTION pid_file 2>/dev/null`"
	LOG_ERROR="`crudini --get \"$CONFIG\" $SERVER_INI_SECTION log_error 2>/dev/null`"
	write_out "Stopping server (${INST_TYPE})"
	PID=`cat "$PID_FILE"`
	kill $PID
	sleep 1
	COUNT=1
	while [ $COUNT -lt $SERVER_STOP_TIMEOUT ]; do
		if ! kill -0 $PID 2>/dev/null; then
			return 0
		fi
		sleep 1
		COUNT=`expr $COUNT + 1`
	done
	write_out "Timeout reached waiting server to stop. Check server logs [${LOG_ERROR}]."
	return 1
}

function port_available()
{
	PORT=$1
	if netstat -an | grep -w $PORT >/dev/null; then
		return 1
	fi
	return 0
}

function promote()
{
	local MAX_DELAY=5
	local OPTIND l_opt
	while getopts "h" l_opt; do
		case $l_opt in
			h)
				help_promote
				return 0
				;;
			\?)
				help_promote
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if [ $# -ne 0 ]; then
		help_promote
		return 1
	fi
	if ! confirm_operation; then
		return 1
	fi
	write_out "Checking if local instance has binary logs"
	V=`get_server_config log_bin` || return 1
	if [ $V -eq 0 ]; then
		write_out "Binary logs disabled - this instance can't be a master"
		return 1
	fi

	write_out "Checking if local instance is a replica"
	replica_check_is_replica || return 1
	write_out "Querying master location"
	MASTER=`replica_query_master_location`
	MASTER_HOST=`echo $MASTER | cut -d \  -f 1`
	MASTER_PORT=`echo $MASTER | cut -d \  -f 2`
	REPL_USER=`echo $MASTER | cut -d \  -f 3`
	write_out "Checking SSH connection to master host"
	ssh -o StrictHostKeyChecking=no -o PasswordAuthentication=no $MASTER_HOST true >/dev/null || return 1

	write_out "Checking replica delay"
	DELAY=`replica_query_delay`
	if [ -z "$DELAY" -o "$DELAY" == "NULL" ]; then
		write_out "Cannot check replica delay"
		return 1
	fi
	if [ $DELAY -gt $MAX_DELAY ]; then
		write_out "Replica delay is too high [$DELAY]"
		return 1
	fi

	echo -n "Please type replication user [$REPL_USER] password: "
	read REPL_PASSWD
	write_out "Listing all replicas"
	QUERY="select host from information_schema.processlist where user = '$REPL_USER'"
	BUFF=`mktemp /tmp/myfreerman.XXXXXX`
	LOGIN_FILE=~/.mylogin.cnf
	LOGIN_FILE_PRESENT=0
	if [ -f $LOGIN_FILE ]; then
		LOGIN_FILE_PRESENT=1
		TMP_LOGIN_FILE=`mktemp ~/.mylogin.cnf.XXXXXX`
		mv $LOGIN_FILE $TMP_LOGIN_FILE
	fi
	MYSQL_PWD=$REPL_PASSWD mysql -N -h $MASTER_HOST -P $MASTER_PORT -u $REPL_USER -e "$QUERY" >$BUFF
	RC=$?
	if [ $LOGIN_FILE_PRESENT -eq 1 ]; then
		mv $TMP_LOGIN_FILE $LOGIN_FILE
	fi
	if [ $RC -ne 0 ]; then
		rm $BUFF
		return 1
	fi

	REPLICA_LIST=`cat $BUFF`
	rm $BUFF
	write_out "Enabling READ-ONLY mode in master"
	TARGET_CRED_OPT=`mount_target_credentials_opt` || return 1
	mysql -h $MASTER_HOST -P $MASTER_PORT -e "set global read_only = on" || return 1

	write_out "Enabling SUPER-READ-ONLY mode in master"
	TARGET_CRED_OPT=`mount_target_credentials_opt` || return 1
	mysql -h $MASTER_HOST -P $MASTER_PORT -e "set global super_read_only = on" || return 1
	sleep 3

	write_out "Querying last transaction executed in master"
	TARGET_CRED_OPT=`mount_target_credentials_opt` || return 1
	BUFF=`mktemp /tmp/myfreerman.XXXXXX`
	mysql $TARGET_CRED_OPT -h $MASTER_HOST -P $MASTER_PORT -e "show master status\G" >$BUFF || { rm $BUFF; return 1; }
	LAST_GTID_MASTER=`grep -i executed_gtid_set $BUFF | awk '{ print $NF }'`
	rm $BUFF
	write_out "Waiting for local replica to apply last executed transaction"
	replica_wait_for_transaction $LAST_GTID_MASTER

	write_out "Disabling READ-ONLY mode in local replica"
	mysql -S "$SERVER_SOCKET" $TARGET_CRED_OPT -e "set global read_only = off" || return 1
	write_out "Disabling SUPER-READ-ONLY mode in local replica"
	mysql -S "$SERVER_SOCKET" $TARGET_CRED_OPT -e "set global super_read_only = off" || return 1

	write_out "Stopping applier in local replica"
	mysql -S "$SERVER_SOCKET" $TARGET_CRED_OPT -e "stop replica" || return 1

	write_out "Converting local replica to master"
	mysql -S "$SERVER_SOCKET" $TARGET_CRED_OPT -e "reset replica all" || return 1

	write_out "Converting master to replica"
	HOST_FIRST_NAME=`echo $HOSTNAME | cut -d . -f 1`
	QUERY="change replication source to source_host = '$HOST_FIRST_NAME', source_user = '$REPL_USER', source_password = '$REPL_PASSWD', source_auto_position = 1, source_ssl = 1"
	mysql $TARGET_CRED_OPT -h $MASTER_HOST -P $MASTER_PORT -e "$QUERY" || return 1
	QUERY="start replica"
	mysql $TARGET_CRED_OPT -h $MASTER_HOST -P $MASTER_PORT -e "$QUERY" || return 1

	write_out "Persisting enabled READ-ONLY mode in old master"
	CMD="crudini --set $SERVER_CONFIG mysqld read_only on"
	ssh -o StrictHostKeyChecking=no -o PasswordAuthentication=no $MASTER_HOST "$CMD" >/dev/null || return 1

	write_out "Persisting enabled SUPER-READ-ONLY mode in old master"
	CMD="crudini --set $SERVER_CONFIG mysqld super_read_only on"
	ssh -o StrictHostKeyChecking=no -o PasswordAuthentication=no $MASTER_HOST "$CMD" >/dev/null || return 1

	write_out "Persisting disabled READ-ONLY mode in new master"
	crudini --set $SERVER_CONFIG mysqld read_only off

	write_out "Persisting disabled SUPER-READ-ONLY mode in new master"
	crudini --set $SERVER_CONFIG mysqld super_read_only off

	write_out "Disabling scheduler in old master"
	CMD="crudini --set $SERVER_CONFIG mysqld event_scheduler off"
	ssh -o StrictHostKeyChecking=no -o PasswordAuthentication=no $MASTER_HOST "$CMD" >/dev/null || return 1
	QUERY="set global event_scheduler=off"
	mysql $TARGET_CRED_OPT -h $MASTER_HOST -P $MASTER_PORT -e "$QUERY" || return 1

	write_out "Enabling scheduler in new master"
	crudini --set $SERVER_CONFIG mysqld event_scheduler on
	QUERY="set global event_scheduler=on"
	mysql $TARGET_CRED_OPT -P $MASTER_PORT -e "$QUERY" || return 1

	write_out "Setting new master in other replicas"
	for R in $REPLICA_LIST; do
		REPLICA_FIRST_NAME=`echo $R | cut -d . -f 1`
		if [ $REPLICA_FIRST_NAME == $HOST_FIRST_NAME ]; then
			continue
		fi
		write_out "   $REPLICA_FIRST_NAME"
		QUERY="stop replica; change replication source to source_host = '$HOST_FIRST_NAME', source_user = '$REPL_USER', source_password = '$REPL_PASSWD', source_auto_position = 1, source_ssl = 1; start replica;"
		mysql $TARGET_CRED_OPT -h $REPLICA_FIRST_NAME -e "$QUERY" || return 1
	done
	write_out "Finished"
}

function purge_binlogs()
{
	LIMIT_LOG=$1
	write_out "Purging binary logs (limit: $LIMIT_LOG)"
	TARGET_CRED_OPT=`mount_target_credentials_opt` || return 1
	mysql --socket="$SERVER_SOCKET" $TARGET_CRED_OPT -e "purge binary logs to '$LIMIT_LOG';" >/dev/null || return 1
}

function query()
{
	CMD=`echo $1 | awk '{print tolower($0)}'`
	shift
	case $CMD in
		backup_age)
			query_backup_age || return 1
			;;
		*)
			help_query
			;;
	esac
}

function query_backup_age()
{
	FULL=`query_full_backup_age` || return 1
	BINLOG=`query_binlog_backup_age` || return 1
	echo "FULL|$FULL"
	echo "BINLOG|$BINLOG"
}

function query_binlog_backup_age()
{
	cd $BINLOG_BACKUP_DIR || return 1
	LAST_FILE=`ls -tr | tail -n 1`
	DATE=${BKP:0:10}
	TIME=${BKP:11:8}
	TIME=${TIME//-/:}
	BKP_FMT_TS="`stat -c %y $LAST_FILE | cut -d . -f 1`"
	BKP_TS_EPOCH=`date -d "$BKP_FMT_TS" +%s`
	DIFF=`expr $NOW_EPOCH - $BKP_TS_EPOCH`
	RESULT=`echo "scale = 2; $DIFF / 3600" | bc`
	echo $RESULT
}

function query_full_backup_age()
{
	cd "$BASE_BACKUP_DIR" || return 1
	BKP=`ls | tail -n 1`
	DATE=${BKP:0:10}
	TIME=${BKP:11:8}
	TIME=${TIME//-/:}
	BKP_FMT_TS="$DATE $TIME"
	BKP_TS_EPOCH=`date -d "$BKP_FMT_TS" +%s`
	DIFF=`expr $NOW_EPOCH - $BKP_TS_EPOCH`
	RESULT=`echo "scale = 2; $DIFF / 3600 / 24" | bc`
	echo $RESULT
}

function read_binlog()
{
	LOGSEQ=$1
	POSITION=$2
	REQ_TIMESTAMP="$3"
	SQL_DEST=$4

	#if pitr requested
	if [ -n "$REQ_TIMESTAMP" ]; then
		STOP_DATETIME_OPT="--stop-datetime=$REQ_TIMESTAMP"
	fi
	RECOVER_DB=
	if [ $# -ge 5 ]; then
		RECOVER_DB=$5
	fi
	POSITION_OPTION=
	if [ $POSITION -ne 0 ]; then
		POSITION_OPTION="--start-position=$POSITION"
	fi
	BINLOG=`get_binlog_path $LOGSEQ`
	PLAIN_BINLOG=$BINLOG
	TMP_BINLOG=
	if file $PLAIN_BINLOG | grep -w gzip >/dev/null; then
		TMP_BINLOG=`mktemp /tmp/myfreerman.XXXXXX`
		PLAIN_BINLOG=$TMP_BINLOG
		gunzip -c $BINLOG >$PLAIN_BINLOG || return 1
	fi
	DB_OPTION=
	if [ -n "$RECOVER_DB" ]; then
		DB_OPTION="--database=$RECOVER_DB"
	fi
	if [ -n "$STOP_DATETIME_OPT" ]; then
		mysqlbinlog --defaults-file="$SERVER_CONFIG" $DB_OPTION "$STOP_DATETIME_OPT" $POSITION_OPTION $PLAIN_BINLOG >>$SQL_DEST || { [ -n "$TMP_BINLOG" ] && rm "$TMP_BINLOG"; return 1; }
	else
		mysqlbinlog --defaults-file="$SERVER_CONFIG" $DB_OPTION $POSITION_OPTION $PLAIN_BINLOG >>$SQL_DEST || { [ -n "$TMP_BINLOG" ] && "$TMP_BINLOG"; return 1; }
	fi
	if [ -n "$TMP_BINLOG" ]; then
		rm $TMP_BINLOG
	fi
}

function read_config()
{
	read_db_config || return 1
	read_rman_config || return 1
}

function read_db_config()
{
	#mount ini section
	INI_SECTION=mysqld
	if [ -n "$MYSQL_SID" ]; then
		INI_SECTION=${INI_SECTION}@${MYSQL_SID}
	fi

	#server socket
	SERVER_SOCKET="`crudini --get \"$SERVER_CONFIG\" $INI_SECTION socket 2>/dev/null`"
	#create socket's folder and set owner
	if [ -n "$SERVER_SOCKET" ]; then
		DNAME="`dirname $SERVER_SOCKET`" || return 1
		mkdir -p "$DNAME" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DNAME" || return 1
		fi
	fi
}

function read_rman_config()
{
	#mount ini section
	INI_SECTION=myfreerman
	if [ -n "$MYSQL_SID" ]; then
		INI_SECTION=${INI_SECTION}@${MYSQL_SID}
	fi

	#config file is not required
	#for example, in clusters with vip, oem agent runs on a third host
	#and it must list backups remotely - no configuration required in target host
	if ! [ -f "$RMAN_CONFIG" ]; then
		return
	fi

	BACKUP_DIR="`crudini --get "$RMAN_CONFIG" $INI_SECTION backup_dir 2>/dev/null`"

	AUX_BASEDIR="`crudini --get "$RMAN_CONFIG" $INI_SECTION aux_basedir 2>/dev/null`"

	DB_PASSWORD="`crudini --get "$RMAN_CONFIG" $INI_SECTION db_password 2>/dev/null`"
	DB_USERNAME="`crudini --get "$RMAN_CONFIG" $INI_SECTION db_username 2>/dev/null`"

	#log directory
	LOG_DIR="`crudini --get "$RMAN_CONFIG" $INI_SECTION log_dir 2>/dev/null`"

	#max memory
	MAX_MEM="`crudini --get "$RMAN_CONFIG" $INI_SECTION max_mem 2>/dev/null`"

	#read only
	READ_ONLY="`crudini --get "$RMAN_CONFIG" $INI_SECTION read_only 2>/dev/null`"
	#default: 0
	if [ -z "${READ_ONLY}" ]; then
		READ_ONLY=0
	fi

	#backup limit memory
	BACKUP_LIMIT_MEMORY="`crudini --get "$RMAN_CONFIG" $INI_SECTION backup_limit_memory 2>/dev/null`"
	#default: 100
	if [ -z "$BACKUP_LIMIT_MEMORY" ]; then
		BACKUP_LIMIT_MEMORY=100
	fi

	#backup process threads
	BACKUP_PROCESS_THREADS="`crudini --get "$RMAN_CONFIG" $INI_SECTION backup_process_threads 2>/dev/null`"
	#default: 6
	if [ -z "$BACKUP_PROCESS_THREADS" ]; then
		BACKUP_PROCESS_THREADS=6
	fi

	#process threads
	PROCESS_THREADS="`crudini --get "$RMAN_CONFIG" $INI_SECTION process_threads 2>/dev/null`"
	#default: 1
	if [ -z "$PROCESS_THREADS" ]; then
		PROCESS_THREADS=1
	fi

	#backup read threads
	BACKUP_READ_THREADS="`crudini --get "$RMAN_CONFIG" $INI_SECTION backup_read_threads 2>/dev/null`"
	#default: 1
	if [ -z "$BACKUP_READ_THREADS" ]; then
		BACKUP_READ_THREADS=1
	fi

	#restore read threads
	RESTORE_READ_THREADS="`crudini --get "$RMAN_CONFIG" $INI_SECTION restore_read_threads 2>/dev/null`"
	#default: 1
	if [ -z "$RESTORE_READ_THREADS" ]; then
		RESTORE_READ_THREADS=1
	fi

	#slave server
	SLAVE_SERVER="`crudini --get "$RMAN_CONFIG" $INI_SECTION slave_server 2>/dev/null`"

	#working dir
	WORKING_DIR="`crudini --get "$RMAN_CONFIG" $INI_SECTION working_dir 2>/dev/null`"
	#default: /var/lib/myfreerman
	if [ -z "$WORKING_DIR" ]; then
		WORKING_DIR=/var/lib/myfreerman
	fi

	#backup write threads
	BACKUP_WRITE_THREADS="`crudini --get "$RMAN_CONFIG" $INI_SECTION backup_write_threads 2>/dev/null`"
	#default: 1
	if [ -z "$BACKUP_WRITE_THREADS" ]; then
		BACKUP_WRITE_THREADS=1
	fi

	#restore write threads
	RESTORE_WRITE_THREADS="`crudini --get "$RMAN_CONFIG" $INI_SECTION restore_write_threads 2>/dev/null`"
	#default: 1
	if [ -z "$RESTORE_WRITE_THREADS" ]; then
		RESTORE_WRITE_THREADS=1
	fi

	#disable buffer pool dump?
	DISABLE_BUFFER_POOL_DUMP="`crudini --get "$RMAN_CONFIG" $INI_SECTION disable_buffer_pool_dump 2>/dev/null`"
	#default: 0
	if [ -z "$DISABLE_BUFFER_POOL_DUMP" ]; then
		DISABLE_BUFFER_POOL_DUMP=0
	fi

	#use rclone?
	USE_RCLONE="`crudini --get "$RMAN_CONFIG" $INI_SECTION use_rclone 2>/dev/null`"
	#default: 0
	if [ -z "$USE_RCLONE" ]; then
		USE_RCLONE=1
	fi

	check_config || return 1
}

function apply()
{
	local OPTIND l_opt
	while getopts "h" l_opt; do
		case $l_opt in
			h)
				help_apply
				return
				;;
			\?)
				help_apply
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if [ $# -lt 1 ]; then
		help_apply
		return 1
	fi

	read_config || return 1
	BASE_BACKUP_DIR="$BACKUP_DIR/base"
	BINLOG_BACKUP_DIR="$BACKUP_DIR/binlog"
	TMP_BACKUP_DIR="$BACKUP_DIR/tmp"

	#backup dir is required
	if [ -z "$BACKUP_DIR" ]; then
		echo "Configuration 'backup_dir' is required" >&2
		return 1
	fi
	CMD=$1
	shift
	case $CMD in
		binlog)
			apply_binlog $* || return 1
			;;
		*)
			help_apply
			return 1
			;;
	esac
}

function apply_binlog()
{
	local OPTIND l_opt
	while getopts "h" l_opt; do
		case $l_opt in
			h)
				help_apply_binlog
				return
				;;
			\?)
				help_apply_binlog
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if [ $# -gt 0 ]; then
		help_apply_binlog
		return 1
	fi

	#backup dir is required
	if [ -z "$BACKUP_DIR" ]; then
		echo "Configuration 'backup_dir' is required" >&2
		return 1
	fi
	USE_AUX_INSTANCE=0
	CONFIG="$SERVER_CONFIG"

	#if not validated, no restore was previously done
	BUFF=`mktemp /tmp/myfreerman.XXXXXX`
	mkdir -p "$WORKING_DIR" 2>$BUFF
	RC=$?
	ERR_MSG=`cat $BUFF`
	rm $BUFF
	if [ $RC -ne 0 ]; then
		write_out "Cannot create directory '$WORKING_DIR': $ERR_MSG"
		return 1
	fi
	FPATH="$WORKING_DIR/restore.ini"
	VAL=`crudini --get "$FPATH" recovery validated 2>/dev/null`
	if [ "$VAL" != "1" ]; then
		write_out "No previous restore done -- aborting"
		return 1
	fi

	REQ_TIMESTAMP=`crudini --get "$FPATH" recovery requested_timestamp 2>/dev/null`
	if [ -n "$REQ_TIMESTAMP" ]; then
		ISO_REQ_TIMESTAMP="${REQ_TIMESTAMP/_/ }"
		write_out "Requested timestamp: $ISO_REQ_TIMESTAMP"
	fi
	if ! confirm_operation; then
		return
	fi
	do_apply_binlog "$SERVER_SOCKET" || return 1
	mysql_stop
}

function recover()
{
	local OPTIND l_opt
	while getopts "h" l_opt; do
		case $l_opt in
			h)
				help_recover
				return
				;;
			\?)
				help_recover
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if [ $# -lt 1 ]; then
		help_recover
		return 1
	fi

	CMD=$1
	shift
	case $CMD in
		replica)
			recover_replica $* || return 1;;
		*)
			help_recover; return 1;;
	esac
}

function recover_replica()
{
	local OPTIND l_opt
	while getopts "h" l_opt; do
		case $l_opt in
			h)
				help_recover_replica
				return
				;;
			\?)
				help_recover_replica
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if [ $# -ne 1 ]; then
		help_recover_replica
		return 1
	fi
	BACKUP_DIR="$1"
	BINLOG_BACKUP_DIR="$BACKUP_DIR/binlog"
	#if binlog backup dir doesn't exist
	if ! [ -d "$BINLOG_BACKUP_DIR" ]; then
		write_out "No backup directory found"
		return 1
	fi

	#check if server is running
	if ! mysqladmin --defaults-file="$SERVER_CONFIG" --socket="$SERVER_SOCKET" ping >/dev/null 2>&1; then
		write_out "Server is not running"
		return 1
	fi

	TARGET_CRED_OPT=`mount_target_credentials_opt`
	ERR=`mktemp /tmp/myfreerman.XXXXXX`

	#identify next binlog and position
	OUT=`mktemp /tmp/myfreerman.XXXXXX`
	mysql --socket="$SERVER_SOCKET" $TARGET_CRED_OPT -e "show replica status\G" >$OUT 2>$ERR
	RC=$?
	write_file_out $ERR
	rm $ERR
	[ $RC -eq 0 ] || { rm $OUT; return 1; }

	#check if current error is the correct one
	ERRNO=`grep -w Last_IO_Errno $OUT | awk '{ print $2; }'`
	if [ $ERRNO -ne 13114 ]; then
		write_out "Server does not seem to be in a state that needs recovery"
		return
	fi

	#query binlog sequence
	BINLOG=`grep -w Master_Log_File $OUT | awk '{ print $2; }'`
#check if we really know binlog name
	if [ -z "$BINLOG" ]; then
		write_out "Unknown current binary log in master"
		return 1
	fi
	LONG_SEQ=`echo $BINLOG | cut -d . -f 2`
	#query binlog position
	POSITION=`grep -w Read_Master_Log_Pos $OUT | awk '{ print $2; }'`
	rm $OUT

	#disable read only for admins in target mysql
	mysql --socket="$SERVER_SOCKET" $TARGET_CRED_OPT -e "set global super_read_only=off" 2>$ERR
	RC=$?
	write_file_out $ERR
	[ $RC -eq 0 ] || { rm $ERR; return 1; }

	stop_replica || { rm $ERR; return 1; }
	reset_replica || { rm $ERR; return 1; }

	#apply first binlog
	SHORT_SEQ=`expr $LONG_SEQ + 0`
	FILE_PATH="$BINLOG_BACKUP_DIR/$BINLOG.gz"
	##it must exist
	[ -f "$FILE_PATH" ] || { write_out "Cannot find backup of binary log #$SHORT_SEQ"; rm $ERR; return 1; }
	write_out "Applying binary log #$SHORT_SEQ"
	PLAIN=`mktemp /tmp/myfreerman.XXXXXX`
	gunzip -c "$FILE_PATH" >$PLAIN 2>$ERR
	RC=$?
	write_file_out $ERR
	[ $RC -eq 0 ] || { rm $PLAIN $ERR; return 1; }

	mysqlbinlog --defaults-file="$SERVER_CONFIG" --start-position=$POSITION $PLAIN | mysql --socket="$SERVER_SOCKET" $TARGET_CRED_OPT 2>$ERR
	RC=$?
	rm $PLAIN
	write_file_out $ERR
	[ $RC -eq 0 ] || { rm $ERR; return 1; }

	#apply next binlogs
	FIRST_SEQ=$SHORT_SEQ
	LIST=`ls "$BINLOG_BACKUP_DIR"`
	for BINLOG in $LIST; do
		LONG_SEQ=`echo $BINLOG | cut -d . -f 2`
		SHORT_SEQ=`expr $LONG_SEQ + 0`
		#apply only if sequence is greater than the first sequence
		if [ $SHORT_SEQ -le $FIRST_SEQ ]; then
			continue
		fi
		write_out "Applying binary log #$SHORT_SEQ"
		FILE_PATH="$BINLOG_BACKUP_DIR/$BINLOG"
		PLAIN=`mktemp /tmp/myfreerman.XXXXXX`
		gunzip -c "$FILE_PATH" >$PLAIN 2>$ERR
		RC=$?
		write_file_out $ERR
		[ $RC -eq 0 ] || { rm $PLAIN $ERR; return 1; }
		mysqlbinlog --defaults-file="$SERVER_CONFIG"  $PLAIN | mysql --socket="$SERVER_SOCKET" $TARGET_CRED_OPT 2>$ERR
		RC=$?
		rm $PLAIN
		write_file_out $ERR
		[ $RC -eq 0 ] || { rm $ERR; return 1; }
	done
	start_replica
	rm $ERR
}

function remove_expired_backups()
{
	if ! confirm_operation; then
		return 1
	fi
	#retention period
	RETENTION_PERIOD="`crudini --get "$RMAN_CONFIG" $INI_SECTION retention_period 2>/dev/null`"
	if [ -z "$RETENTION_PERIOD" ]; then
		write_out "Configuration 'retention_period' is required"
		return 1
	fi

	remove_expired_full_backups || return 1
	remove_expired_binlog_backups || return 1
}

function remove_expired_binlog_backups()
{
	cd "${BINLOG_BACKUP_DIR}" || return 1
	OLDEST_BKP=`ls ${BASE_BACKUP_DIR} | head -n 1`
	LIST=`find . -type f \! -newer "${BASE_BACKUP_DIR}/${OLDEST_BKP}"` || return 1
	for BINLOG in $LIST; do
		write_out "Removing expired backup of binary log sequence $LOGSEQ"
		BINLOG=`basename $BINLOG`
		rm -f $BINLOG || return 1
		BINLOG=`echo $BINLOG | cut -d . -f 2`
		LOGSEQ=`expr $BINLOG + 0`
	done
}

function remove_expired_full_backups()
{
	BASE_BACKUP_DIR="$BACKUP_DIR/base"
	REF_TIMESTAMP=`date --date="-$RETENTION_PERIOD days" +%Y%m%d%H%M%S`
	mkdir -p "$BASE_BACKUP_DIR" || return 1
	COUNT=`ls "$BASE_BACKUP_DIR" | wc -l`
	if [ $COUNT -eq 0 ]; then
		return 0
	fi
	PREV_BKP=
	for BKP in `ls "$BASE_BACKUP_DIR"`; do
		DATE=${BKP:0:10}
		TIME=${BKP:11:8}
		TIME=${TIME//-/:}
		BKP_FMT_TS="$DATE $TIME"
		BKP_TIMESTAMP=`date --date="$BKP_FMT_TS" +%Y%m%d%H%M%S`
		if [ $BKP_TIMESTAMP -ge $REF_TIMESTAMP ]; then
			return
		fi
		if [ -n "$PREV_BKP" ]; then
			write_out "Removing expired full backup $PREV_BKP"
			rm -fr "$BASE_BACKUP_DIR/$PREV_BKP" || return 1
			PREV_BKP=`echo $PREV_BKP | cut -d . -f 1`
		fi
		PREV_BKP=$BKP
	done
}

function remove_stale_temp_data()
{
	REF=`date --date="-15 days" +%Y-%m-%d_%H:%M:%S`
	for I in `ls "$TMP_BACKUP_DIR"`; do
		if [[ "$I" < "$REF" ]]; then
			DIR="$TMP_BACKUP_DIR/$I"
			rm -fr "$DIR"
		fi
	done
}

function remove_tmp_binlog_backups()
{
	COUNT=`ls "$BINLOG_BACKUP_DIR"/*.tmp 2>/dev/null | wc -l`
	[ $COUNT -ne 0 ] || return
	ERR=`mktemp /tmp/myfreerman.XXXXXX`
	rm -f "$BINLOG_BACKUP_DIR"/*.tmp
	write_file_out $ERR
	rm $ERR
}

function reset_master()
{
	mysql --socket="$SERVER_SOCKET" $TARGET_CRED_OPT -e "reset master;" >/dev/null || return 1
}

function restore()
{
	local OPTIND l_opt
	while getopts "h" l_opt; do
		case $l_opt in
			h)
				help_restore
				return
				;;
			\?)
				help_restore
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if [ $# -lt 1 ]; then
		help_restore
		return 1
	fi

	BINLOG_BACKUP_DIR="$BACKUP_DIR/binlog"
	BASE_BACKUP_DIR="$BACKUP_DIR/base"
	TMP_BACKUP_DIR="$BACKUP_DIR/tmp"

	CMD=$1
	shift
	case $CMD in
		config)
			restore_config $* || return 1
			;;
		database)
			restore_database $* || return 1
			;;
		*)
			help_restore
			return 1
			;;
	esac
	[ $REPORT_FINISHED -eq 0 ] || write_out "Finished"
}

function restore_config()
{
	local OPTIND l_opt
	while getopts "ho:p:" l_opt; do
		case $l_opt in
			h)
				help_restore_config
				return
				;;
			o)
				BACKUP_DIR="${OPTARG}"
				;;
			p)
				USER_TIMESTAMP="${OPTARG}"
				;;
			\?)
				help_restore_config
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if [ $# -ne 0 ]; then
		help_restore_config
		return 1
	fi
	REPORT_FINISHED=0
	#backup dir is required
	if [ -z "$BACKUP_DIR" ]; then
		echo "Configuration 'backup_dir' is required" >&2
		return 1
	fi

	BASE_BACKUP_DIR="$BACKUP_DIR/base"
	[ -d "$BASE_BACKUP_DIR" ] || { write_out "No backup found" && return 1; }
	REQ_TIMESTAMP=
	if [ -n "$USER_TIMESTAMP" ]; then
		REQ_TIMESTAMP=`expand_timestamp $USER_TIMESTAMP | sed -e 's/_/ /'` || return 1
		write_out "Requested timestamp: $REQ_TIMESTAMP"
	fi
	DIR=`find_base_backup "$REQ_TIMESTAMP"` || return 1
	if  [ -z "$DIR" ]; then
		write_out "No backup found"
		return 1
	fi

	CONF="$BASE_BACKUP_DIR/$DIR/server-my.cnf"
	if ! [ -f "$CONF" ]; then
		write_out "Cannot find server configuration file in backup!"
		return 1
	fi
	grep -Ev "^#|^\[" "$CONF"
}

function restore_database()
{
	local DO_BINLOGS=1
	DORESET=1
	PITR=0
	RESTORE_TABLE_LIST=
	REQ_TIMESTAMP=
	CUR_SOCKET="$SERVER_SOCKET"
	local OPTIND l_opt
	while getopts "hno:Rs:p:t:" l_opt; do
		case $l_opt in
			R)
				DO_BINLOGS=0;;
			s)
				RESTORE_SCHEMA=${OPTARG}
				;;
			h)
				help_restore_database
				return
				;;
			o)
				BACKUP_DIR="${OPTARG}"
				DORESET=0
				;;
			n)
				DORESET=0
				;;
			p)
				USER_TIMESTAMP="${OPTARG}"
				;;
			t)
				RESTORE_TABLE_LIST="$RESTORE_TABLE_LIST ${OPTARG}"
				;;
			\?)
				help_restore_database
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if [ $# -ne 0 ]; then
		help_restore_database
		return 1
	fi
	#backup dir is required
	if [ -z "$BACKUP_DIR" ]; then
		echo "Configuration 'backup_dir' is required" >&2
		return 1
	fi

	BINLOG_BACKUP_DIR="$BACKUP_DIR/binlog"
	BASE_BACKUP_DIR="$BACKUP_DIR/base"
	TMP_BACKUP_DIR="$BACKUP_DIR/tmp"
	restore_validate_options || return 1

	#check if there is at least one backup full
	if ! [ -d "$BASE_BACKUP_DIR" ]; then
		write_out "No backup found"
		return 1
	fi
	COUNT=`ls "$BASE_BACKUP_DIR" | wc -l`
	if [ $COUNT -eq 0 ]; then
		write_out "No backup found"
		return 1
	fi

	if [ -n "$USER_TIMESTAMP" ]; then
		REQ_TIMESTAMP="`expand_timestamp $USER_TIMESTAMP | sed -e 's/_/ /'`" || return 1
		write_out "Requested timestamp: $REQ_TIMESTAMP"
	fi
	if [ -n "$RESTORE_SCHEMA" -o -n "$RESTORE_TABLE_LIST" ]; then
		USE_AUX_INSTANCE=1
	fi

	DIR=`find_base_backup "$REQ_TIMESTAMP"` || return 1
	if [ -z "$DIR" ]; then
		write_out "No backup found"
		return 1
	fi
	BASE_BACKUP=$DIR
	if ! confirm_operation; then
		return 1
	fi
	if ! [ -f "$SERVER_CONFIG" ]; then
		write_out "Cannot find readable file '$SERVER_CONFIG'"
		return 1
	fi
	if [ $USE_AUX_INSTANCE -eq 1 ]; then
		backup_binlog || return 1
		BINLOG_PREFIX=`mysql --socket="$SERVER_SOCKET" $TARGET_CRED_OPT -e "show variables like 'log_bin_basename'" | tail -n 1 | cut -f 2 -d$'\t'` || return 1
	fi
	MOMENT=`date +%Y%m%d-%H%M%S`
	AUX_SOCKET_OPT=
	if ! [ -d "$BASE_BACKUP_DIR" ]; then
		write_out "No backup to be restored"
		return 1
	fi
	DATADIR="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION datadir`" 2>/dev/null
	REDODIR="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION innodb_log_group_home_dir 2>/dev/null`"
	UNDODIR="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION innodb_undo_directory 2>/dev/null`"
	BINLOG_INDEX="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION log_bin_index 2>/dev/null`"
	RELAY_LOG_INDEX="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION relay_log_index 2>/dev/null`"
	BINLOG_PREFIX="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION log_bin 2>/dev/null`"
	if [ -n "$BINLOG_PREFIX" ]; then
		BINLOG_DIR="`dirname $BINLOG_PREFIX`" || return 1
	fi
	RELAY_LOG_PREFIX="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION relay_log 2>/dev/null`"
	if [ -n "$RELAY_LOG_PREFIX" ]; then
		RELAY_LOG_DIR="`dirname $RELAY_LOG_PREFIX`" || return 1
	fi

	#secure files directory
	SECURE_DIR="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION secure_file_priv 2>/dev/null`"

	#mysqld user
	MYSQLD_USER="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION user 2>/dev/null`"

	RESTORE_SCHEMA_OLD_NAME=`echo $RESTORE_SCHEMA | cut -d \: -f 1`
	RESTORE_SCHEMA_NEW_NAME=`echo $RESTORE_SCHEMA | cut -d \: -f 2`
	if [ -z "$RESTORE_SCHEMA_NEW_NAME" ]; then
		RESTORE_SCHEMA_NEW_NAME=$RESTORE_SCHEMA_OLD_NAME
	fi

	if [ "$RESTORE_SCHEMA_OLD_NAME" = "mysql" -o "$RESTORE_SCHEMA_OLD_NAME" = "sys" -o "$RESTORE_SCHEMA_OLD_NAME" = "information_schema" -o "$RESTORE_SCHEMA_OLD_NAME" = "performance_schema" ]; then
		write_out "Invalid schema name '$RESTORE_SCHEMA_OLD_NAME'"
		return 1
	fi
	if [ "$RESTORE_SCHEMA_NEW_NAME" = "mysql" -o "$RESTORE_SCHEMA_NEW_NAME" = "sys" -o "$RESTORE_SCHEMA_NEW_NAME" = "information_schema" -o "$RESTORE_SCHEMA_NEW_NAME" = "performance_schema" ]; then
		write_out "Invalid schema name '$RESTORE_SCHEMA_NEW_NAME'"
		return 1
	fi
	CONFIG="$SERVER_CONFIG"
	if [ $USE_AUX_INSTANCE -eq 1 ]; then
		if [ -z "$AUX_BASEDIR" ]; then
			write_out "When restoring a single database or a table, AUX_BASEDIR configuration must be set"
			return 1
		fi
		if ! [ -d "$AUX_BASEDIR" ]; then
			write_out "No such directory: $AUX_BASEDIR" >&2
			return 1
		fi
		check_aux_binaries || return 1
		AUX_BASEDIR=`mktemp -d -p "$AUX_BASEDIR" -t "aux.XXXXXX"` || return 1
		BASENAME=`basename "$AUX_BASEDIR"` || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$AUX_BASEDIR" || return 1
		fi
		DORESET=0
		AUX_CONFIG="${AUX_BASEDIR}/my.cnf"
		CONFIG="$AUX_CONFIG"
		AUX_BINLOG_PREFIX="${AUX_BASEDIR}/binlog/binlog"
		AUX_BINLOG_INDEX="${AUX_BASEDIR}/binlog.index"
		AUX_DATADIR="$AUX_BASEDIR/datadir"
		AUX_LOG_ERROR="${AUX_BASEDIR}/mysqld.log"
		AUX_PID_FILE="$AUX_BASEDIR/pid_file"
		AUX_SOCKET="$AUX_BASEDIR/socket"
		AUX_PORT=`find_aux_port` || return 1
		AUX_REDODIR="${AUX_BASEDIR}/redo"
		AUX_SOCKET_OPT="--socket=$AUX_SOCKET"
		AUX_UNDODIR="${AUX_BASEDIR}/undo"
		CUR_SOCKET="$AUX_SOCKET"

		#relay
		if [ -n "$RELAY_LOG_INDEX" ]; then
			AUX_RELAY_LOG_INDEX="${AUX_BASEDIR}/relay.index"
		fi
		if [ -n "$RELAY_LOG_PREFIX" ]; then
			AUX_RELAY_LOG_PREFIX="${AUX_BASEDIR}/relay/relay"
		fi
	fi
	AUDIT_LOG_FILE="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION audit_log_file 2>/dev/null`"
	MYSQLD_USER="`crudini --get \"$SERVER_CONFIG\" $SERVER_INI_SECTION user`" 2>/dev/null
	if [ $USE_AUX_INSTANCE -eq 0 ]; then	
		restore_target_instance $DIR || return 1
	else
		restore_aux_instance $DIR || return 1
	fi
	if [ $REPLICA -eq 1 ]; then
		return
	fi

	BUFF=`mktemp /tmp/myfreerman.XXXXXX`
	mkdir -p "$WORKING_DIR" 2>$BUFF
	RC=$?
	ERR_MSG=`cat $BUFF`
	rm $BUFF
	if [ $RC -ne 0 ]; then
		write_out "Cannot create directory '$WORKING_DIR': $ERR_MSG"
		return 1
	fi
	FPATH="$WORKING_DIR/restore.ini"
	if [ $USE_AUX_INSTANCE -eq 0 ]; then
		TS=`date +%Y-%m-%d_%H-%M-%S`
		#save restore time
		if ! crudini --set "$FPATH" recovery restore_time $TS; then
			write_out "Cannot write to working file '$FPATH' -- please review 'working_dir' config"
			return 1
		fi
		if ! crudini --set "$FPATH" recovery validated 1; then
			write_out "Cannot write to working file '$FPATH' -- please review 'working_dir' config"
			return 1
		fi
		#save requested timestamp
		crudini --del "$FPATH" recovery requested_timestamp 2>/dev/null
		if [ -n "$REQ_TIMESTAMP" ]; then
			REQ_TIMESTAMP_NO_SPACE=${REQ_TIMESTAMP/ /_}
			if ! crudini --set "$FPATH" recovery requested_timestamp $REQ_TIMESTAMP_NO_SPACE; then
				write_out "Cannot write to working file '$FPATH' -- please review 'working_dir' config"
				return 1
			fi
		fi
		#save base backup
		if ! crudini --set "$FPATH" recovery base_backup $BASE_BACKUP; then
			write_out "Cannot write to working file '$FPATH' -- please review 'working_dir' config"
			return 1
		fi
	fi
	SOCKET="$SERVER_SOCKET"
	ITYPE="restricted"
	if [ $USE_AUX_INSTANCE -eq 1 ]; then
		ITYPE="aux"
		LOG_ERROR="$AUX_LOG_ERROR"
		SOCKET="$AUX_SOCKET"
	fi
	if [ $DO_BINLOGS -eq 1 ]; then
		do_apply_binlog "$SOCKET" $BASE_BACKUP || return 1
	else
		INST_TYPE="restricted"
		if [ $USE_AUX_INSTANCE -eq 1 ]; then
			INST_TYPE="aux"
		fi
		mysql_start || return 1
	fi
	if [ -n "$RESTORE_SCHEMA_OLD_NAME" ]; then
		copy_recovered_db || { mysql_stop && return 1; }
	fi
	if [ -n "$RESTORE_TABLE_LIST" ]; then
		copy_restored_tables || { mysql_stop "$CONFIG" $ITYPE && return 1; }
	fi
	if [ $USE_AUX_INSTANCE -eq 0 -a $DORESET -eq 1 -a $DO_BINLOGS -eq 1 ]; then
		create_incarnation $MOMENT
		reset_master || return 1
	fi
	mysql_stop

	#if using aux instance, remove files
	if [ $USE_AUX_INSTANCE -eq 1 ]; then
		rm -fr "$AUX_BASEDIR"
	fi
}

function restore_aux_instance()
{
	DIR="${1}"
	create_aux_config $DIR || return 1
	rm -fr "$AUX_DATADIR/*" || return 1
	mkdir -p $AUX_DATADIR || return 1
	LIM_MEM_OPT=`mount_limit_memory_option`
	FULL_DIR="${BASE_BACKUP_DIR}/${DIR}"

	RELAY_LOG_OPTS=
	if [ -n "$AUX_RELAY_LOG_PREFIX" ]; then
		RELAY_LOG_OPTS="--relay-log=$AUX_RELAY_LOG_PREFIX"
	fi
	if [ -n "$AUX_RELAY_LOG_INDEX" ]; then
		RELAY_LOG_OPTS="$RELAY_LOG_OPTS --relay-log-index=$AUX_RELAY_LOG_INDEX"
	fi

	if [ -n "$LOG_FILE" ]; then
		TMP_LOG=`mktemp /tmp/myfreerman.XXXXXX` || return 1
		write_out "===== STARTING MEB - Log: $TMP_LOG ====="
		mysqlbackup --defaults-group-suffix=$MYSQL_DEFAULT_GROUP_SUFFIX --defaults-file=$AUX_CONFIG --read-threads=$RESTORE_READ_THREADS --write-threads=$RESTORE_WRITE_THREADS --backup-dir="$FULL_DIR" --skip-messages-logdir $LIM_MEM_OPT copy-back --log-bin="${AUX_BINLOG_PREFIX}" --log-bin-index="${AUX_BINLOG_INDEX}" $RELAY_LOG_OPTS >$TMP_LOG 2>&1
		RETCODE=$?
		cat $TMP_LOG
		cat $TMP_LOG >>"$LOG_FILE"
		rm $TMP_LOG
		if [ $RETCODE -ne 0 ]; then
			return 1
		fi
	else
		write_out "===== STARTING MEB ====="
		mysqlbackup --defaults-group-suffix=$MYSQL_DEFAULT_GROUP_SUFFIX --defaults-file=$AUX_CONFIG --read-threads=$RESTORE_READ_THREADS --write-threads=$RESTORE_WRITE_THREADS --backup-dir="$FULL_DIR" --skip-messages-logdir $LIM_MEM_OPT copy-back --log-bin="${AUX_BINLOG_PREFIX}" --log-bin-index="${AUX_BINLOG_INDEX}" $RELAY_LOG_OPTS || return 1
	fi

#===========================================
#Rodrigo Tassinari - 2020-03-11
#BUG in MEB 8.0.18:
#Binary log index informed in --log-bin-index is appended a text ".index", and manual does not say that
#So, we rename it
	BUG_BINLOG_INDEX="${AUX_BINLOG_INDEX}.index" 
	if [ -f "$BUG_BINLOG_INDEX" ]; then
		ERR_LOG=`mktemp /tmp/myfreerman.XXXXXX`
		mv "$BUG_BINLOG_INDEX" "$AUX_BINLOG_INDEX"
		RC=$?
		write_file_out "$ERR_LOG"
		rm "$ERR_LOG"
		[ $RC -eq 0 ] || return 1
	fi
#===========================================

	#create log file
	touch "$AUX_LOG_ERROR" || return 1
	#change ownership
	if [ -n "$MYSQLD_USER" ]; then
		chown $MYSQLD_USER "$AUX_LOG_ERROR" || return 1
		chown -R $MYSQLD_USER "$AUX_BASEDIR" || return 1
	fi
}

function restore_target_instance()
{
	DIR="${1}"
	#if server is running, abort
	if mysqladmin --defaults-file="$SERVER_CONFIG" -s --socket="$SERVER_SOCKET" $TARGET_CRED_OPT ping >/dev/null; then
		write_out "MySQL is running - aborting"
		return 1
	fi
	mkdir -p "$DATADIR" || return 1
	if [ -n "$MYSQLD_USER" ]; then
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DATADIR" || return 1
		fi
	fi

	if [ -n "$UNDODIR" ]; then
		if [ "${UNDODIR:0:1}" != "/" ]; then
			UNDODIR="$DATADIR/$UNDODIR"
		fi
		mkdir -p "$UNDODIR" || return 1
		fs_remove_directory_contents "$UNDODIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$UNDODIR" || return 1
		fi
	fi

	#redo
	if [ -n "$REDODIR" ]; then
		if [ "${REDODIR:0:1}" != "/" ]; then
			REDODIR="$DATADIR/$REDODIR"
		fi
		mkdir -p "$REDODIR" || return 1
		#if ls -d "$REDODIR"/* >/dev/null 2>&1; then
			#write_out "Redo directory [$REDODIR] must be empty"
			#return 1
		#fi
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$REDODIR" || return 1
		fi
	fi
	if [ -n "$BINLOG_DIR" ]; then
		mkdir -p "$BINLOG_DIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$BINLOG_DIR" || return 1
		fi
	fi
	if [ -n "$SECURE_DIR" ]; then
		mkdir -p "$SECURE_DIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$SECURE_DIR" || return 1
		fi
		chmod 700 "$SECURE_DIR" || return 1
	fi
	check_empty_target_database || return 1
	check_target_instance_config || return 1
	LIM_MEM_OPT=`mount_limit_memory_option`
	FULL_DIR="${BASE_BACKUP_DIR}/${DIR}"

	if [ $USE_RCLONE -eq 1 ]; then
		restore_target_instance_with_rclone || return 1
	else
		restore_target_instance_with_meb || return 1
	fi

#===========================================
#Rodrigo Tassinari - 2020-03-11
#BUG in MEB 8.0.18:
#Binary log index informed in --log-bin-index is appended a text ".index", and manual does not say that
#So, we rename it
	if [ -n "$BINLOG_INDEX" ]; then
		BUG_BINLOG_INDEX="${BINLOG_INDEX}.index" 
		if [ -f "$BUG_BINLOG_INDEX" ]; then
			ERR_LOG=`mktemp /tmp/myfreerman.XXXXXX`
			mv "$BUG_BINLOG_INDEX" "$BINLOG_INDEX"
			RC=$?
			write_file_out "$ERR_LOG"
			rm "$ERR_LOG"
			[ $RC -eq 0 ] || return 1
		fi
#===========================================
	fi
	if [ -n "$MYSQLD_USER" ]; then
		write_out "Setting permissions"
		chown -R $MYSQLD_USER "$DATADIR" || return 1
		if [ -n "$REDODIR" ]; then
			chown -R $MYSQLD_USER "$REDODIR" || return 1
		fi
		if [ -n "$UNDODIR" ]; then
			chown -R $MYSQLD_USER "$UNDODIR" || return 1
		fi
		if [ -n "$BINLOG_INDEX" -a -n "$MYSQLD_USER" -a -f "$BINLOG_INDEX" ]; then
			chown $MYSQLD_USER "$BINLOG_INDEX" || return 1
		fi
		if [ -n "$BINLOG_DIR" -a -n "$MYSQLD_USER" ]; then
			chown -R $MYSQLD_USER "$BINLOG_DIR" || return 1
		fi
		if [ -n "$RELAY_LOG_INDEX" -a -n "$MYSQLD_USER" -a -f "$RELAY_LOG_INDEX" ]; then
			chown $MYSQLD_USER "$RELAY_LOG_INDEX" || return 1
		fi
		if [ -n "$RELAY_LOG_DIR" -a -n "$MYSQLD_USER" ]; then
			chown -R $MYSQLD_USER "$RELAY_LOG_DIR" || return 1
		fi
	fi
}

function restore_target_instance_with_meb()
{
	if [ -n "$LOG_FILE" ]; then
		TMP_LOG=`mktemp /tmp/myfreerman.XXXXXX` || return 1
		write_out "===== STARTING MEB - Log: $TMP_LOG ====="
		mysqlbackup --defaults-group-suffix=$MYSQL_DEFAULT_GROUP_SUFFIX --defaults-file="$SERVER_CONFIG" --read-threads=$RESTORE_READ_THREADS --write-threads=$RESTORE_WRITE_THREADS --backup-dir="$FULL_DIR" --skip-messages-logdir $LIM_MEM_OPT copy-back --log-bin="${BINLOG_PREFIX}" --log-bin-index="${BINLOG_INDEX}" --relay-log="$RELAY_LOG_PREFIX" --relay-log-index="$RELAY_LOG_INDEX" >$TMP_LOG 2>&1 
		RETCODE=$?
		cat $TMP_LOG >>"$LOG_FILE"
		cat $TMP_LOG
		rm $TMP_LOG
		if [ $RETCODE -ne 0 ]; then
			return 1
		fi
	else
		write_out "===== STARTING MEB ====="
		mysqlbackup --defaults-group-suffix=$MYSQL_DEFAULT_GROUP_SUFFIX --defaults-file="$SERVER_CONFIG" --read-threads=$RESTORE_READ_THREADS --write-threads=$RESTORE_WRITE_THREADS --backup-dir="$FULL_DIR" --skip-messages-logdir $LIM_MEM_OPT copy-back --log-bin="${BINLOG_PREFIX}" --log-bin-index="${BINLOG_INDEX}" --relay-log="$RELAY_LOG_PREFIX" --relay-log-index="$RELAY_LOG_INDEX" || return 1 
	fi
}

function restore_target_instance_with_rclone()
{
	BKP_DATADIR="$FULL_DIR/datadir"

	#check for redo logs in old format
	OLD_REDO=0
	if ls "${BKP_DATADIR}/ib_logfile*" >/dev/null 2>&1; then
		OLD_REDO=1
	fi

	#check for redo logs in new format
	NEW_REDO=0
	if ls -d "${BKP_DATADIR}/#innodb_redo" >/dev/null 2>&1; then
		NEW_REDO=1
	fi


	if [ -n "$LOG_FILE" ]; then
		TMP_LOG=`mktemp /tmp/myfreerman.XXXXXX` || return 1
		write_out "===== STARTING RCLONE (database) - Log: $TMP_LOG ====="
		rclone --transfers=$BACKUP_READ_THREADS -v --exclude '/ib_logfile*' --exclude '/undo*' sync "${BKP_DATADIR}/" "$DATADIR" >$TMP_LOG 2>&1
		RETCODE=$?
		cat $TMP_LOG >>"$LOG_FILE"
		cat $TMP_LOG
		rm $TMP_LOG
		if [ $RETCODE -ne 0 ]; then
			return 1
		fi

		write_out "===== STARTING RCLONE (redo logs) - Log: $TMP_LOG ====="
		#old format?
		if [ $OLD_REDO -eq 1 ]; then
			rclone --transfers=$BACKUP_READ_THREADS -v --include '/ib_logfile*' sync "${BKP_DATADIR}/" "$REDODIR" >$TMP_LOG 2>&1
			RETCODE=$?
			cat $TMP_LOG >>"$LOG_FILE"
			cat $TMP_LOG
			rm $TMP_LOG
			if [ $RETCODE -ne 0 ]; then
				return 1
			fi
		fi
		#new format?
		if [ $NEW_REDO -eq 1 ]; then
			rclone --transfers=$BACKUP_READ_THREADS -v sync "${BKP_DATADIR}/#innodb_redo" "$REDODIR/#innodb_redo" >$TMP_LOG 2>&1
			RETCODE=$?
			cat $TMP_LOG >>"$LOG_FILE"
			cat $TMP_LOG
			rm $TMP_LOG
			if [ $RETCODE -ne 0 ]; then
				return 1
			fi
		fi
	else
		write_out "===== STARTING RCLONE (database) ====="
		rclone --transfers=$BACKUP_READ_THREADS -v --exclude '/ib_logfile*' --exclude '/undo*' sync "${BKP_DATADIR}/" "$DATADIR" || return 1
		write_out "===== STARTING RCLONE (redo logs) ====="
		#old format?
		if [ $OLD_REDO -eq 1 ]; then
			rclone --transfers=$BACKUP_READ_THREADS -v --include '/ib_logfile*' sync "${BKP_DATADIR}/" "$REDODIR" || return 1
		fi
		#new format?
		if [ $NEW_REDO -eq 1 ]; then
			rclone --transfers=$BACKUP_READ_THREADS -v sync "${BKP_DATADIR}/#innodb_redo" "$REDODIR/#innodb_redo" || return 1
		fi
	fi
}

function restore_validate_options()
{
	#backup directory must exist
	if ! [ -d "$BACKUP_DIR" ]; then
		write_out "Directory not found: $BACKUP_DIR"
		return 1
	fi

	if [ -n "$RESTORE_SCHEMA_OLD_NAME" -a -n "$RESTORE_TABLE_LIST" ]; then
		echo "Options -s and -t cannot be used together" >&2
		return 1
	fi
	if [ -n "$RESTORE_TABLE_LIST" ]; then
		restore_validate_tablenames || return 1
	fi
}

function restore_validate_tablenames()
{
	for QT in $RESTORE_TABLE_LIST; do
		if ! echo "$QT" | grep \\. >/dev/null; then
			echo "Invalid table name: '$QT' - table names must be qualified with schema" >&2
			return 1
		fi
		SCHEMA=`echo $QT | cut -d . -f 1`
		TABLE=`echo $QT | cut -d . -f 2`
		if [ -z "$SCHEMA" -o -z "$TABLE" ]; then
			echo "Invalid table name: '$QT' - table names must be qualified with schema" >&2
			return 1
		fi
	done
}

function run()
{
	REPORT_FINISHED=1
	KILL_WAIT_TIMEOUT=300
	SERVER_START_TIMEOUT=7200
	SERVER_STOP_TIMEOUT=300

	RMAN_CONFIG=/etc/my.cnf
	LOG_FILE_BASENAME=
	ANSWER_YES=0
	QUIET=0
	while getopts "hl:c:qy" opt; do
		case $opt in
			h)
				help
				;;
			l)
				LOG_FILE_BASENAME=`date "+$OPTARG"` || return 1
				;;
			c)
				RMAN_CONFIG="$OPTARG"
				;;
			q)
				QUIET=1
				;;
			y)
				ANSWER_YES=1
				;;
			\?)
				help
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	SERVER_CONFIG="$RMAN_CONFIG"

	if [ $QUIET -eq 0 ]; then
		header
	fi
	if [ $# -lt 1 ]; then
		help
		return 1
	fi
	read_config || return 1
	LOG_FILE=
	if [ -n "$LOG_FILE_BASENAME" ]; then
		LOG_FILE="${LOG_DIR}/$LOG_FILE_BASENAME"
	fi
	if [ -z "$MYFREERMAN_MOD_DIR" ]; then
		MYFREERMAN_MOD_DIR=/usr/lib/myfreerman/modules
	fi
	REPLICA=0
	TARGET_CRED_OPT=`mount_target_credentials_opt` || return 1

	#if password in config, set env
	if [ -n "$DB_PASSWORD" ]; then
		export MYSQL_PWD="$DB_PASSWORD"
	fi

	MYHOST=`hostname`
	BINLOG_BACKUP_DIR="$BACKUP_DIR/binlog"
	RESTORE_BACKUP_DIR="$BACKUP_DIR/restore"
	CMD=`echo $1 | awk '{print tolower($0)}'`
	shift
	USE_AUX_INSTANCE=0
	SERVER_INI_SECTION=mysqld
	if [ -n "$MYSQL_SID" ]; then
		SERVER_INI_SECTION="${SERVER_INI_SECTION}@$MYSQL_SID"
		MYSQL_DEFAULT_GROUP_SUFFIX="@$MYSQL_SID"
	fi
	load_modules || return 1
	trap exiting EXIT
	case $CMD in
		apply)
			apply $* || return 1
			;;
		backup)
			backup $* || return 1
			;;
		drop)
			drop $* || return 1
			;;
		flashback)
			flashback $* || return 1
			;;
		init)
			init $* || return 1
			;;
		list)
			list $* || return 1
			;;
		metadata)
			metadata || return 1;;
		promote)
			promote $* || return 1
			;;
		query)
			query $* || return 1
			;;
		recover)
			recover $* || return 1
			;;
		remove)
			remove $* || return 1
			;;
		restore)
			restore $* || return 1
			;;
		*)
			echo "Invalid command: $CMD" >&2
			help
			return 1
			;;
	esac
}

function remove()
{
	local OPTIND l_opt
	while getopts "h" opt; do
		case $opt in
			h)
				help_remove
				return
				;;
			\?)
				help_remove
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if [ $# -ne 1 ]; then
		help_remove
		return 1
	fi
	case $1 in
		expired)
			remove_expired_backups || return 1
			;;
		*)
			help_remove
			return 1
			;;
	esac
}

function reset_replica()
{
	CMD="reset replica"
	TARGET_CRED_OPT=`mount_target_credentials_opt` || return 1
	ERR=`mktemp /tmp/myfreerman.XXXXXX`
	mysql --socket="$SERVER_SOCKET" $TARGET_CRED_OPT -e "$CMD" 2>$ERR
	RC=$?
	write_file_out $ERR
	rm $ERR
	[ $RC -eq 0 ] || return 1
}

function save_recovery_data()
{
	FPATH="$WORKING_DIR/restore.ini"
	crudini --set "$FPATH" recovery restore_time "$REQ_TIMESTAMP"
}

function start_replica()
{
	CMD="start replica"
	TARGET_CRED_OPT=`mount_target_credentials_opt` || return 1
	ERR=`mktemp /tmp/myfreerman.XXXXXX`
	mysql --socket="$SERVER_SOCKET" $TARGET_CRED_OPT -e "$CMD" 2>$ERR
	RC=$?
	write_file_out $ERR
	rm $ERR
	[ $RC -eq 0 ] || return 1
}

function stop_replica()
{
	CMD="stop replica"
	TARGET_CRED_OPT=`mount_target_credentials_opt` || return 1
	ERR=`mktemp /tmp/myfreerman.XXXXXX`
	mysql --socket="$SERVER_SOCKET" $TARGET_CRED_OPT -e "$CMD" 2>$ERR
	RC=$?
	write_file_out $ERR
	rm $ERR
	[ $RC -eq 0 ] || return 1
}


function uncompress_backup()
{
	BKP="$1"
	TAR_FILE="${BASE_BACKUP_DIR}/${BKP}.tgz"
	tar -C "${BASE_BACKUP_DIR}" -x -z -f "${TAR_FILE}" || return 1
}

function wait_server_start()
{
	PID=$1
	CONF_FILE="$2"
	LOG_ERROR="`crudini --get \"$CONF_FILE\" $SERVER_INI_SECTION log_error 2>/dev/null`"
	sleep 3
	COUNT=3
	while [ $COUNT -lt $SERVER_START_TIMEOUT ]; do
		if mysqladmin --defaults-file="$SERVER_CONFIG" -s --socket="$SOCKET" ping >/dev/null; then
			return 0
		fi
		if ! kill -0 $PID 2>/dev/null; then
			return 1
		fi
		sleep 1
		COUNT=$((COUNT + 1))
	done
}

function write_err()
{
	MSG="$1"
	echo "$MSG" >&2
}

function write_file_out()
{
	local OUT_F="$1"
	cat "$OUT_F"
	if [ -n "$LOG_FILE" ]; then
		cat "$OUT_F" >>"$LOG_FILE"
	fi
}

function write_out()
{
	MSG="$1"
	TS=`date +"%d %H:%M:%S"`
	echo "[$TS] $MSG"
	if [ -n "$LOG_FILE" ]; then
		echo "[$TS] $MSG" >>"$LOG_FILE"
	fi
}

if [ "$DEBUG" == "1" ]; then
	set -xv
fi
NOW_EPOCH=`date +%s`
DATE_VAL=`date +%Y-%m-%d`
TIME_VAL=`date +%H:%M:%S`
MAX_READ_THREADS=15
MAX_WRITE_THREADS=15
READ_ONLY=0
LOG_FILE=
check_depends || exit -1
run $*
RETCODE=$?
exit $RETCODE
