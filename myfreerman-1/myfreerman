#!/bin/bash
RELEASE=1.4.20

function apply_binlog()
{
	FILENAME="$1"
	SOCKET="$2"
	mysql --socket="$SOCKET" <"$FILENAME" || return 1
	#rotate binlogs
	mysqladmin --socket="$SOCKET" flush-logs || return 1
	CUR_BINLOG=`tail "$BINLOG_INDEX"` || return 1
	BN="`basename \"$CUR_BINLOG\"`" || return 1
}

function backup()
{
	if [ $# -lt 1 ]; then
		echo "Missing backup type" >&2
		usage
		return 1
	fi
	check_config_backup || return 1
	if [ $READ_ONLY -eq 1 ]; then
		write_out "Read-only mode is enabled in configuration"
		return 1
	fi

	TARGET_CRED_OPT=`mount_target_credentials_opt`
	if ! mysqladmin $TARGET_CRED_OPT ping >/dev/null 2>&1; then
		write_out "No MySQL server running - ignoring backup"
		return
	fi
	if ! which mysqlbackup >/dev/null 2>&1; then
		write_out "Cannot find 'mysqlbackup' in PATH"
		return 1
	fi
	BKP_TYPE=`echo $1 | awk '{print tolower($0)}'`
	shift
	BINLOG_PREFIX=`mysql $TARGET_CRED_OPT -e "show variables like 'log_bin_basename'" | tail -n 1 | cut -f 2 -d$'\t'` || return 1
	BINLOG_DIR="`dirname \"$BINLOG_PREFIX\"`" || return 1
	DATADIR=`mysql $TARGET_CRED_OPT -e "show variables like 'datadir'" | tail -n 1 | cut -f 2 -d$'\t'` || return 1
	case $BKP_TYPE in
		full)
			backup_full $* || return 1
			;;
		binlog)
			backup_binlog $* || return 1
			;;
		*)
			echo "Invalid backup type '$BKP_TYPE'" >&2
			usage
			return 1
			;;
	esac
}

function backup_binlog()
{
	local OPTIND l_opt
	while getopts "" opt; do
		case $opt in
			\?)
				echo "Invalid option: -$OPTARG" >&2
				usage
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if [ $# -ne 0 ]; then
		usage
		return 1
	fi
	cd "$BACKUP_DIR" || return 1
	if ! exist_base_backup; then
		echo "No full backup was previously done" >&2
		return 1
	fi

	#create binlog backup dir
	mkdir -p "$BINLOG_BACKUP_DIR" || return 1

	#flush logs
	mysqladmin $TARGET_CRED_OPT flush-logs || return 1

	#list binlogs, just ignoring the last one
	LIST_FILE=`mktemp /tmp/myfreerman.XXXXXX` || return 1
	mysql $TARGET_CRED_OPT -e "show binary logs\G" | grep -wi log_name | cut -d \  -f 3 >$LIST_FILE || return 1
	TOTAL=`cat $LIST_FILE | wc -l` || return 1
	COUNT=$((TOTAL - 1))
	LIST=`head -n $COUNT $LIST_FILE`
	LAST_BINLOG=`tail -n 1 $LIST_FILE`
	rm $LIST_FILE
	for BINLOG in $LIST; do
		if ! [ -f "$BINLOG_BACKUP_DIR/${BINLOG}.gz" ]; then
			LONG_LOGSEQ=`echo $BINLOG | cut -d . -f 2`
			LOGSEQ=`expr $LONG_LOGSEQ + 0`
			write_out "Saving binary log sequence $LOGSEQ"
			gzip -c9 "$BINLOG_DIR/$BINLOG" >"$BINLOG_BACKUP_DIR/${BINLOG}.gz" || return 1
		fi
	done
	check_purge_binlogs $LAST_BINLOG || return 1
}

function backup_full()
{
	local OPTIND l_opt
	while getopts "" opt; do
		case $opt in
			\?)
				echo "Invalid option: -$OPTARG" >&2
				usage
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if  [ $# -ne 0 ]; then
		usage
		return 1
	fi
	cd "$BACKUP_DIR" || return 1
	mkdir -p "$BASE_BACKUP_DIR" || return 1
	DATE_VAL=`date +%Y-%m-%d`
	TIME_VAL=`date +%H-%M-%S`
	TIMESTAMP=${DATE_VAL}_${TIME_VAL}
	DIRECTORY="${BASE_BACKUP_DIR}/${TIMESTAMP}"
	mkdir -p "$DIRECTORY" || return 1
	IMAGE_FILE="${BASE_BACKUP_DIR}/${TIMESTAMP}.dat"
	LIM_MEM_OPT=`mount_limit_memory_option`
	write_out "===== STARTING mysqlbackup ====="
	if [ -n "$LOG_FILE" ]; then
		TMP_LOG=`mktemp /tmp/myfreerman.XXXXXX` || return 1
		mysqlbackup $TARGET_CRED_OPT --read-threads=$READ_THREADS --write-threads=$WRITE_THREADS --backup-dir="${DIRECTORY}" $LIM_MEM_OPT backup-and-apply-log >$TMP_LOG 2>&1 
		RETCODE=$?
		cat $TMP_LOG
		cat $TMP_LOG >>"$LOG_FILE"
		rm $TMP_LOG
		if [ $RETCODE -ne 0 ]; then
			return 1
		fi
	else
		mysqlbackup $TARGET_CRED_OPT --read-threads=$READ_THREADS --write-threads=$WRITE_THREADS --backup-dir="${DIRECTORY}" $LIM_MEM_OPT backup-and-apply-log
	fi
	RETCODE=$?
	write_out "===== FINISHED mysqlbackup ====="
	#check_backup_consistency
	if [ $RETCODE -ne 0 ]; then
		rm -fr "${DIRECTORY}"
		return 1
	fi
	cd "$BASE_BACKUP_DIR" || return 1
	LAST_BACKUP=`ls | tail -n 1` || return 1
	write_out "Saving config file"
	cp "$CONFIG_FILE" "$DIRECTORY/my.cnf" || return 1
	fix_backup_timestamp $LAST_BACKUP || return 1
	backup_binlog || return 1
	if [ -n "$RETENTION_PERIOD" ]; then
		remove_old_backups || return 1
	fi
}

function binlog_backup_exists()
{
	cd "$BINLOG_BACKUP_DIR" || return 1
	LOGSEQ=$1
	LONG_LOGSEQ=`seq -f "%06g" $LOGSEQ $LOGSEQ`
	BINLOG=binlog.${LONG_LOGSEQ}
	if [ -f "${BINLOG}" ]; then
		return 0
	fi
	if [ -f "${BINLOG}.gz" ]; then
		return 0
	fi
	return 1
}

function binlog_exists()
{
	LOGSEQ=$1
	LONG_LOGSEQ=`seq -f "%06g" $LOGSEQ $LOGSEQ`
	FILEPATH="${BINLOG_PREFIX}.$LONG_LOGSEQ"
	if [ -f "$FILEPATH" ]; then
		return 0
	fi
	return 1
}


function check_aux_binaries()
{
	if ! which mysqld >/dev/null 2>&1; then
		echo "Cannot find 'mysqld' in PATH" >&2
		return 1
	fi
	if ! which mysqldump >/dev/null 2>&1; then
		echo "Cannot find 'mysqldump' in PATH" >&2
		return 1
	fi
}

function check_aux_dir_space()
{
	DIR=$1
	BKP_SIZE=`du -s -m "$DIR/datadir" | cut -f 1`
	REQ_SIZE=`expr $BKP_SIZE + 100`
	FREE_SIZE=`df -m $AUX_BASEDIR | tail -n 1 | tr -s ' ' | cut -d ' ' -f 4` || return 1
	if [ $FREE_SIZE -lt $REQ_SIZE ]; then
		echo "Not enough space in $AUX_BASEDIR - a minimum of ${REQ_SIZE}M is required" >&2
		return 1
	fi
}

function check_backup_consistency()
{
	write_out "Checking backup consistency"
	if ! [ -d "$BASE_BACKUP_DIR" ]; then
		return
	fi
	cd "$BASE_BACKUP_DIR" || return 1
	for BKP in `ls`; do
		if [ -d "$BKP" ]; then
			if ! consistent_backup "$BKP"; then
				rm -r "$BKP"
			fi
		fi
	done
}

function check_config()
{
	#LOG_DIR
	#if -l option used, log_dir is required
	if [ -n "$LOG_FILE_BASENAME" -a -z "$LOG_DIR" ]; then
		echo "Configuration variable 'log_dir' is required when log file is defined" >&2
		return 1
	fi

	#LOG_DIR - if defined, must exist
	if [ -n "$LOG_DIR" ]; then
		if ! [ -d "$LOG_DIR" ]; then
			echo "'$LOG_DIR': no such directory" >&2
			return 1
		fi
	fi

	#READ_ONLY - must be 0 or 1
	if [ $READ_ONLY -ne 0 -a $READ_ONLY -ne 1 ]; then
		echo "Configuration 'read_only' must be 0 or 1" >&2
		return 1
	fi

	#READ_THREADS
	if [ $READ_THREADS -lt 1 -o $READ_THREADS -gt $MAX_READ_THREADS ]; then
		echo "Configuration 'read_threads' must be between 1 and $MAX_READ_THREADS" >&2
		return 1
	fi

	#WRITE_THREADS
	if [ $WRITE_THREADS -lt 1 -o $WRITE_THREADS -gt $MAX_WRITE_THREADS ]; then
		echo "Configuration WRITE_THREADS must be between 1 and $MAX_WRITE_THREADS" >&2
		return 1
	fi

	#DB_HOSTNAME and DB_SOCKET cannot both be set mutually
	if [ -n "$DB_HOSTNAME" -a -n "$DB_SOCKET" ]; then
		echo "Configurations DB_HOSTNAME and DB_SOCKET cannot both be set"
		return 1
	fi
}

function check_config_backup()
{
	#BACKUP_DIR
	if [ -z "$BACKUP_DIR" ]; then
		echo "Configuration 'backup_dir' is required" >&2
		return 1
	fi
	if [ ! -d "$BACKUP_DIR" ]; then
		echo "'$BACKUP_DIR': no such directory" >&2
		return 1
	fi

	#LOCK_FILE - required
	if [ -z "$LOCK_FILE" ]; then
		echo "Configuration 'lock_file' is required" >&2
		return 1
	fi
}

function check_config_list()
{
	if [ -z "$LIST_REMOTE_HOST" ]; then
		#BACKUP_DIR
		if [ -z "$BACKUP_DIR" ]; then
			echo "Configuration 'backup_dir' is required" >&2
			return 1
		fi
		if [ ! -d "$BACKUP_DIR" ]; then
			echo "'$BACKUP_DIR': no such directory" >&2
			return 1
		fi
	fi
}

function check_depends()
{
	#crudini
	if ! rpm -q crudini >/dev/null 2>&1; then
		write_out "Cannot find package 'crudini'"
		return 1
	fi
}

function check_empty_target_database()
{
	#datadir must be empty
	if ls -d "$DATADIR"/* >/dev/null 2>&1; then
		write_out "Data directory [$DATADIR] must be empty"
		return 1
	fi

	#check there is no binary log
	if [ -n "$BINLOG_PREFIX" ] && ls "$BINLOG_PREFIX"* >/dev/null 2>&1; then
		write_out "No binary logs [${BINLOG_PREFIX}*] might exist"
		return 1
	fi

	#binlog index file must not exist
	if [ -n "$BINLOG_INDEX" -a -f "$BINLOG_INDEX" >/dev/null 2>&1 ]; then
		write_out "Binary log index [$BINLOG_INDEX] must not exist"
		return 1
	fi

	#check there is no relay log
	if [ -n "$RELAY_LOG_MASK" ] && ls "$RELAY_LOG_MASK"* >/dev/null 2>&1; then
		write_out "No relay logs [${RELAY_LOG_MASK}*] might exist"
		return 1
	fi

	#relay log index file must not exist
	if [ -n "$RELAY_LOG_INDEX" -a -f "$RELAY_LOG_INDEX" ]; then
		write_out "Relay log index [$RELAY_LOG_INDEX] must not exist"
		return 1
	fi
}

function check_lock_file()
{
	MAX_WAIT_TIME_MIN=10
	SLEEP_TIME=15

	MAX_WAIT_TIME_SEC=`expr $MAX_WAIT_TIME_MIN \* 60`
	TOT_WAIT_TIME=0

	if [ -n "$LOCK_FILE" ]; then
		while [ -f "$LOCK_FILE" ]; do
			if [ $TOT_WAIT_TIME -ge $MAX_WAIT_TIME_SEC ]; then
				write_out "Timeout reached waiting for another instance"
				return 1
			fi
			write_out "Waiting for another instance - lock file: $LOCK_FILE"
			sleep $SLEEP_TIME
			TOT_WAIT_TIME=`expr $TOT_WAIT_TIME + $SLEEP_TIME`
		done
		touch "$LOCK_FILE" || return 1
	fi
}

function check_new_db_name()
{
	if [ -n "$RESTORE_DB_NEW_NAME" ]; then
		if ls $DATADIR/$RESTORE_DB_NEW_NAME >/dev/null 2>&1; then
			echo "Database '$RESTORE_DB_NEW_NAME' already exists" >&2
			return 1
		fi
	fi
}

function check_purge_binlogs()
{
	if [ -n "$SLAVE_SERVER" -a $USE_AUX_INSTANCE -eq 0 ]; then
		LIMIT_LOG=`get_current_slave_binlog`
	else
		LIMIT_LOG=$1
	fi
	if [ $? -ne 0 ]; then
		write_out "Cannot contact slave server - no binary log will be purged"
		return
	fi
	if [ -z "$LIMIT_LOG" ]; then
		write_out "Cannot retrieve slave server's current slave status - no binary log will be purged"
		return
	fi
	write_out "Purging binary logs (limit: $LIMIT_LOG)"
	TARGET_CRED_OPT=`mount_target_credentials_opt "$CONFIG_FILE"` || return 1
	mysql --defaults-file="$CONFIG_FILE" $TARGET_CRED_OPT -e "purge binary logs to '$LIMIT_LOG';" >/dev/null || return 1
}

function check_target_instance_config()
{
	START_TIMEOUT=60
	write_out "Checking target instance configuration"

	#create directory for binlog index
	if [ -n "$BINLOG_INDEX" ]; then
		DN="`dirname \"$BINLOG_INDEX\"`"
		mkdir -p "$DN" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DN" || return 1
		fi
	fi

	#create directory for binlogs
	if [ -n "$BINLOG_DIR" ]; then
		mkdir -p "$BINLOG_DIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$BINLOG_DIR" || return 1
		fi
	fi
	
	#create directory for relay log index
	if [ -n "$RELAY_LOG_INDEX" ]; then
		DN="`dirname \"$RELAY_LOG_INDEX\"`"
		mkdir -p "$DN" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DN" || return 1
		fi
	fi

	#create directory for relay logs
	if [ -n "$RELAY_LOG_DIR" ]; then
		mkdir -p "$RELAY_LOG_DIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$RELAY_LOG_DIR" || return 1
		fi
	fi

	LOG_ERROR="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION log_error 2>/dev/null`"
	if [ -z "$LOG_ERROR" ]; then
		write_out "MySQL configuration mysqld:log_error cannot be empty"
		return 1
	fi
	PID_FILE="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION pid_file 2>/dev/null`"
	if [ -z "$PID_FILE" ]; then
		write_out "MySQL configuration mysqld:pid_file cannot be empty"
		return 1
	fi
	if ! which mysqld >/dev/null 2>&1; then
		write_out "Cannot find 'mysqld' executable file"
		return 1
	fi
	TMP_LOG=`mktemp /tmp/myfreerman.XXXXXX` || return 1
	TMP_CONF=`mktemp /tmp/myfreerman.XXXXXX` || return 1
	grep -v "^audit" "$CONFIG_FILE" >$TMP_CONF || return 1
	if ! mysqld --defaults-group-suffix=$MYSQL_DEFAULT_GROUP_SUFFIX --defaults-file="$TMP_CONF" --initialize >>"$TMP_LOG" 2>&1; then
		write_out "Cannot check target instance configuration. Check server output in '$TMP_LOG' and logs in '$LOG_ERROR'."
		drop_target_database
		return 1
	fi
	mysqld --defaults-group-suffix=$MYSQL_DEFAULT_GROUP_SUFFIX --defaults-file="$TMP_CONF" --bind-address=127.0.0.1 &
	PID=$!
	if ! wait_server_start $PID "$TMP_CONF"; then
		write_out "Cannot check target instance configuration. Check server logs in '$LOG_ERROR'."
		drop_target_database
		return 1
	fi
	kill_pid "$PID_FILE"
	rm $TMP_CONF
	drop_target_database || return 1
}

function confirm_operation()
{
	if [ $ANSWER_YES -eq 1 ]; then
		return 0
	fi
	echo -n "Are you sure? (You must type 'yes' to confirm): "
	read ANSWER
	LANSWER=`echo "$ANSWER" | awk '{print tolower($0)}'`
	if [ "$LANSWER" == "yes" ]; then
		return 0
	fi
	return 1
}

function consistent_backup()
{
	TMP_BKP_DIR="$1"
	TMP_BACKUP_VARS="$TMP_BKP_DIR/meta/backup_variables.txt"
	if ! [ -f "$TMP_BACKUP_VARS" ]; then
		return 1
	fi
	TMP_APPLY_LOG_DONE="`crudini --get \"$TMP_BACKUP_VARS\" backup_variables apply_log_done`" || return 1
	if [ "$TMP_APPLY_LOG_DONE" != "1" ]; then
		return 1
	fi
	return 0
}

function copy_recovered_db()
{
	if [ -z "$RESTORE_DB_NEW_NAME" ]; then
		RESTORE_DB_NEW_NAME=$RESTORE_DB_OLD_NAME
		write_out "Dropping target schema '$RESTORE_DB_NEW_NAME'"
		mysql $TARGET_CRED_OPT -e "drop database if exists $RESTORE_DB_NEW_NAME;" || return 1
	fi
	write_out "Copying recovered database from aux instance"
	mysql $TARGET_CRED_OPT -e "create database $RESTORE_DB_NEW_NAME;" >/dev/null || return 1
	mysqldump --socket=$AUX_SOCKET --no-create-db --routines --events --triggers $RESTORE_DB_OLD_NAME | mysql $TARGET_CRED_OPT $RESTORE_DB_NEW_NAME || return 1
}

function copy_restored_tables()
{
	TARGET_CRED_OPT=`mount_target_credentials_opt "$CONFIG_FILE"`
	write_out "Copying restored tables from aux instance"
	for QT in $RESTORE_TABLE_LIST; do
		if ! echo "$QT" | grep \\. >/dev/null; then
			echo "Invalid table name: '$QT' - table names must be qualified with schema" >&2
			return 1
		fi
		SCHEMA=`echo $QT | cut -d . -f 1`
		TABLE=`echo $QT | cut -d . -f 2`
		write_out "    ${QT}"
		mysqldump --defaults-file=$AUX_CONFIG --no-create-db --routines --events --triggers $SCHEMA $TABLE | mysql $TARGET_CRED_OPT $SCHEMA || return 1
	done
}

function create_aux_config()
{
	DIR=$1
	MYSQL_VER=`get_mysql_usage $DIR` || return 1
	if [ -z "$AUX_BASEDIR" ]; then
		echo "Cannot find 'basedir' in '$CONFIG_FILE'" >&2
		return 1
	fi
	if ! [ -d "$AUX_BASEDIR" ]; then
		echo "'$CONFIG_FILE' is not a directory (or access is denied)" >&2
		return 1
	fi
	TARGET_CRED_OPT=`mount_target_credentials_opt "$CONFIG_FILE"`
	TARGET_BASEDIR=`mysql $TARGET_CRED_OPT -e "show variables like 'basedir'" | tail -n 1 | cut -f 2 -d$'\t'`
	LC_MESSAGES_DIR=`mysql $TARGET_CRED_OPT -e "show variables like 'lc_messages_dir'" | tail -n 1 | cut -f 2 -d$'\t'`
	LOWER_CASE_TABLE_NAMES=`mysql $TARGET_CRED_OPT -e "show variables like 'lower_case_table_names'" | tail -n 1 | cut -f 2 -d$'\t'`
	echo "[$SERVER_INI_SECTION]" >$AUX_CONFIG
	echo "datadir=${AUX_DATADIR}" >>$AUX_CONFIG
	echo "explicit_defaults_for_timestamp=1" >>$AUX_CONFIG
	echo "innodb_buffer_pool_size=10M" >>$AUX_CONFIG
	echo "innodb_data_home_dir="$AUX_DATADIR >>$AUX_CONFIG
	echo "innodb_log_group_home_dir=$AUX_REDODIR" >>$AUX_CONFIG
	echo "innodb_undo_directory=$AUX_UNDODIR" >>$AUX_CONFIG
	echo "lc_messages_dir=$LC_MESSAGES_DIR" >>$AUX_CONFIG
	echo "lc_messages=en_US" >>$AUX_CONFIG
	echo "log_bin=${AUX_BINLOG_PREFIX}" >>$AUX_CONFIG
	echo "log_bin_index=${AUX_BINLOG_INDEX}" >>$AUX_CONFIG
	echo "log_error=$AUX_LOG_ERROR" >>$AUX_CONFIG
	echo "log_timestamps=system" >>$AUX_CONFIG
	echo "lower_case_table_names=$LOWER_CASE_TABLE_NAMES" >>$AUX_CONFIG
	echo "max_allowed_packet=100M" >>$AUX_CONFIG
	echo "mysqlx=0" >>$AUX_CONFIG
	echo "pid_file=$AUX_PID_FILE" >>$AUX_CONFIG
	echo "port=$AUX_PORT" >>$AUX_CONFIG
	echo "socket=$AUX_SOCKET" >>$AUX_CONFIG
	echo "skip-grant-tables=1" >>$AUX_CONFIG
	echo "user=mysql" >>$AUX_CONFIG
	echo "[mysql]" >>$AUX_CONFIG
	echo "port=$AUX_PORT" >>$AUX_CONFIG
	echo "socket=$AUX_SOCKET" >>$AUX_CONFIG
	echo "[mysqldump]" >>$AUX_CONFIG
	echo "max_allowed_packet=99M" >>$AUX_CONFIG
	echo "port=$AUX_PORT" >>$AUX_CONFIG
	echo "socket=$AUX_SOCKET" >>$AUX_CONFIG
}

function create_incarnation()
{
	write_out "Creating new backup incarnation"
	MOMENT=$1
	RESTORE_DIR=$RESTORE_BACKUP_DIR/$MOMENT
	mkdir -p "$RESTORE_DIR" || return 1
	mv "$BACKUP_DIR/base" "$BACKUP_DIR/binlog" "$RESTORE_DIR" || return 1
}

function drop_target_database()
{
	if [ -n "$REDODIR" ]; then
		rm -fr "$REDODIR"/* || return 1
	fi
	if [ -n "$UNDODIR" ]; then
		rm -fr "$UNDODIR"/* || return 1
	fi
	if [ -n "$BINLOG_PREFIX" ]; then
		rm -f "$BINLOG_PREFIX"* || return 1
	fi
	if [ -n "$RELAY_LOG_MASK" ]; then
		rm -f "$RELAY_LOG_MASK"* || return 1
	fi
	if [ -n "$BINLOG_INDEX" ]; then
		rm -f "$BINLOG_INDEX" || return 1
	fi
	if [ -n "$RELAY_LOG_INDEX" ]; then
		rm -f "$RELAY_LOG_INDEX" || return 1
	fi
	rm -fr "$DATADIR/"* || return 1
}

function expand_logfile_path()
{
	date "+$1"
}

function exist_base_backup()
{
	if ! [ -d $BASE_BACKUP_DIR ]; then
		return 1
	fi
	COUNT=`ls $BASE_BACKUP_DIR | wc -l`
	if [ $COUNT -eq 0 ]; then
		return 1
	fi
	return 0
}

function fix_timestamps()
{
	cd $BASE_BACKUP_DIR || return 1
	for BACKUP in *; do
		fix_backup_timestamp $BACKUP || return 1
	done
}

function find_aux_port()
{
	FIRST_PORT=10000
	LAST_PORT=19999
	RANGE=`expr $LAST_PORT - $FIRST_PORT`
	while true; do
		PORT=$RANDOM
		let "PORT %= $RANGE"
		PORT=`expr $PORT + $FIRST_PORT`
		if port_available $PORT; then
			echo $PORT
			return
		fi
	done
}

function find_base_backup()
{
	REQ_TIMESTAMP=`date --date="$1" +%Y%m%d%H%M%S` || return 1
	if [ -z "$REQ_TIMESTAMP" ]; then
		return 1
	fi
	cd "$BASE_BACKUP_DIR" || return 1
	for BKP in `ls -r | cut -d . -f 1`; do
		DATE=${BKP:0:10}
		TIME=${BKP:11:8}
		TIME=${TIME//-/:}
		BKP_FMT_TS="$DATE $TIME"
		BKP_TIMESTAMP=`date --date="$BKP_FMT_TS" +%Y%m%d%H%M%S`
		if [ $BKP_TIMESTAMP -le $REQ_TIMESTAMP ]; then
			echo $BKP
			return
		fi
	done
	echo "No backup found for requested timestamp" >&2
	return 1
}

function fix_backup_timestamp()
{
	BACKUP=$1
	write_out "Fixing backup $BACKUP timestamp"
	cd $BASE_BACKUP_DIR || return 1
	LOGSEQ=`get_base_backup_binlog_sequence $BACKUP` || return 1
	POSITION=`get_base_backup_binlog_position $BACKUP` || return 1
	BINLOG=`get_binlog_path $LOGSEQ` || return 1
	NEWNAME=`get_binlog_transaction_timestamp $BINLOG $POSITION` || return 1
	if [ "$BACKUP" != "$NEWNAME" ]; then
		if [ -d ${BACKUP} ]; then
			mv $BACKUP $NEWNAME || return 1
		fi
	fi
}

function get_base_backup_binlog_name()
{
	BACKUP=$1
	grep -w "binlog_position" $BASE_BACKUP_DIR/$BACKUP/meta/backup_variables.txt | cut -d '=' -f 2 | cut -d ':' -f 1 || return 1
}

function get_base_backup_binlog_sequence()
{
	BACKUP=$1
	BINLOG=`get_base_backup_binlog_name $BACKUP`
	get_binlog_sequence $BINLOG || return 1
}

function get_base_backup_binlog_position()
{
	BACKUP=$1
	grep -w "binlog_position" $BASE_BACKUP_DIR/$BACKUP/meta/backup_variables.txt | cut -d '=' -f 2 | cut -d ':' -f 2 || return 1
}

function get_binlog_path()
{
	LOGSEQ=$1
	LONG_LOGSEQ=`seq -f "%06g" $LOGSEQ $LOGSEQ`
	BINLOG=binlog.$LONG_LOGSEQ

	#search in backup
	if [ -f "$BINLOG_BACKUP_DIR/$BINLOG" ]; then
		echo "$BINLOG_BACKUP_DIR/$BINLOG"
		return
	fi

	#search in backup (compressed)
	if [ -f "$BINLOG_BACKUP_DIR/$BINLOG.gz" ]; then
		echo "$BINLOG_BACKUP_DIR/$BINLOG.gz"
		return
	fi

	#search in server repository
	if [ -f "${BINLOG_PREFIX}.$LONG_LOGSEQ" ]; then
		echo "${BINLOG_PREFIX}.$LONG_LOGSEQ"
		return
	fi

	echo "Cannot find binary log $LOGSEQ anywhere" >&2
	return 1
}

function get_binlog_sequence()
{
	BINLOG=$1
	LONG_LOGSEQ=`echo $BINLOG | cut -d . -f 2`
	expr $LONG_LOGSEQ + 0
}

function get_binlog_transaction_timestamp()
{
	BINLOG=$1
	POSITION=$2

	PLAIN_BINLOG=/$BINLOG
	TMP_BINLOG=
	if file $PLAIN_BINLOG | grep -w gzip >/dev/null; then
		TMP_BINLOG=`mktemp /tmp/myfreerman.XXXXXX` || return 1
		PLAIN_BINLOG=$TMP_BINLOG
		gunzip -c $BINLOG >$PLAIN_BINLOG
	fi
	TMP_SQL=`mktemp /tmp/myfreerman.XXXXXX` || return 1
	mysqlbinlog $PLAIN_BINLOG >$TMP_SQL || return 1
	if [ -n "$TMP_BINLOG" ]; then
		rm $TMP_BINLOG
	fi
	LINE=`grep "^#.*end_log_pos $POSITION" $TMP_SQL` || return 1
	rm $TMP_SQL
	TIMESTAMP="${LINE:1:15}"
	date -d"$TIMESTAMP" +%Y-%m-%d_%H-%M-%S
}

function get_mysql_usage()
{
	BACKUP=$1
	grep -w "mysql_usage" $BASE_BACKUP_DIR/$BACKUP/meta/backup_variables.txt | cut -d '=' -f 2 | cut -d '.' -f 1 || return 1
}

function get_oldest_full_backup()
{
	cd "$BACKUP_DIR" || return 1
	mkdir -p "$BASE_BACKUP_DIR" || return 1
	cd "$BASE_BACKUP_DIR" || return 1
	ls | head -n 1
}

function get_current_slave_binlog()
{
	SLAVE_HOSTNAME=`echo $SLAVE_SERVER | cut -d \: -f 1`
	SLAVE_PORT=`echo $SLAVE_SERVER | cut -d \: -f 2`
	if [ -z  "$SLAVE_PORT" ]; then
		SLAVE_PORT=3306
	fi
	SLAVE_CRED_OPT=`mount_slave_credentials_opt`

#before getting slave status, check if we can reach it
	RESULT=1
	if mysqladmin $SLAVE_CRED_OPT status >/dev/null; then
		if mysql $SLAVE_CRED_OPT -e "show slave status\G" | grep Relay_Master_Log_File | cut -d :  -f 2 | sed -e 's/ //'; then
			RESULT=0
		fi
	fi
	return $RESULT
}

function header()
{
	write_out "myfreerman - Free Recovery Manager for MySQL - Release $RELEASE - Host $MYHOST"
}

function kill_pid()
{
	WAIT_TIMEOUT=15
	PID_FILE="$1"
	PID=`cat "$PID_FILE"`
	kill $PID
	sleep 1
	COUNT=1
	while kill -0 $PID 2>/dev/null; do
		COUNT=$((COUNT + 1))
		if [ $COUNT -ge $WAIT_TIMEOUT ]; then
			return 1
		fi
		sleep 1
	done
}

function init()
{
	#error log is required
	LOG_ERROR="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION log_error 2>/dev/null`"
	if [ -z "$LOG_ERROR" ]; then
		write_out "Configuration 'log_error' in server configuration is required"
		return 1
	fi

	#mysqld user
	MYSQLD_USER="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION user 2>/dev/null`"

	#create log error file
	DNAME="`dirname $LOG_ERROR`" || return 1
	mkdir -p "$DNAME" || return 1
	if [ -n "$MYSQLD_USER" ]; then
		chown $MYSQLD_USER "$DNAME" || return 1
	fi
	touch "$LOG_ERROR" || return 1
	if [ -n "$MYSQLD_USER" ]; then
		chown $MYSQLD_USER "$LOG_ERROR" || return 1
	fi

	#datadir
	DATADIR="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION datadir`" 2>/dev/null
	if [ -n "$DATADIR" ]; then
		mkdir -p "$DATADIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DATADIR" || return 1
		fi
	fi

	#redo
	REDODIR="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION innodb_log_group_home_dir 2>/dev/null`"
	if [ -n "$REDODIR" ]; then
		mkdir -p "$REDODIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$REDODIR" || return 1
		fi
	fi

	#undo
	UNDODIR="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION innodb_undo_directory 2>/dev/null`"
	if [ -n "$UNDODIR" ]; then
		mkdir -p "$UNDODIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$UNDODIR" || return 1
		fi
	fi

	#binlog index file
	BINLOG_INDEX="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION log_bin_index 2>/dev/null`"
	if [ -n "$BINLOG_INDEX" ]; then
		DNAME="`dirname $BINLOG_INDEX`" || return 1
		mkdir -p "$DNAME" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DNAME" || return 1
		fi
	fi

	#relay index file
	RELAY_LOG_INDEX="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION relay_log_index 2>/dev/null`"
	if [ -n "$RELAY_LOG_INDEX" ]; then
		DNAME="`dirname $RELAY_LOG_INDEX`" || return 1
		mkdir -p "$DNAME" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DNAME" || return 1
		fi
	fi

	#binlogs directory
	BINLOG_PREFIX="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION log_bin 2>/dev/null`"
	if [ -n "$BINLOG_PREFIX" ]; then
		BINLOG_DIR="`dirname $BINLOG_PREFIX`" || return 1
		mkdir -p "$BINLOG_DIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$BINLOG_DIR" || return 1
		fi
	fi

	#relay logs directory
	RELAY_LOG_PREFIX="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION relay_log 2>/dev/null`"
	if [ -n "$RELAY_LOG_PREFIX" ]; then
		RELAY_LOG_DIR="`dirname $RELAY_LOG_PREFIX`" || return 1
		mkdir -p "$RELAY_LOG_DIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$RELAY_LOG_DIR" || return 1
		fi
	fi

	#secure files directory
	SECURE_DIR="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION secure_file_priv 2>/dev/null`"
	if [ -n "$SECURE_DIR" ]; then
		mkdir -p "$SECURE_DIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$SECURE_DIR" || return 1
			chmod 700 "$SECURE_DIR" || return 1
		fi
	fi

	#tmp directory
	TMP_DIRECTORY="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION tmpdir 2>/dev/null`"
	if [ -n "$TMP_DIRECTORY" ]; then
		mkdir -p "$TMP_DIRECTORY" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$TMP_DIRECTORY" || return 1
		fi
	fi

	#slow query log file
	SLOW_QUERY_LOG_FILE="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION slow_query_log_file 2>/dev/null`"
	if [ -n "$SLOW_QUERY_LOG_FILE" ]; then
		DNAME="`dirname $SLOW_QUERY_LOG_FILE`" || return 1
		mkdir -p "$DNAME" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DNAME" || return 1
		fi
	fi

	#general log file
	GENERAL_LOG_FILE="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION general_log_file 2>/dev/null`"
	if [ -n "$GENERAL_LOG_FILE" ]; then
		DNAME="`dirname $GENERAL_LOG_FILE`" || return 1
		mkdir -p "$DNAME" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DNAME" || return 1
		fi
	fi

	echo -n "Please enter new password for root: "
	read NEW_PASSWORD

	#run initialize
	write_out "Creating server repository"
	if ! mysqld --defaults-group-suffix=$MYSQL_DEFAULT_GROUP_SUFFIX --defaults-file="$CONFIG_FILE" --initialize; then
		write_out "Cannot create server repository. Please check mysql log at '$LOG_ERROR'."
		return 1
	fi
	LINE=`grep -w password "$LOG_ERROR" | tail -n 1`
	PASSWORD=`echo ${LINE##* }`

	mysql_start "$CONFIG_FILE" "init" || return 1

	write_out "Running initial config commands"
	#create tmp file with commands
	SQL=`mktemp /tmp/myfreerman.XXXXXX`
	echo "alter user root@localhost identified by '$NEW_PASSWORD';" >>$SQL
	echo "update mysql.user set host = '%' where user = 'root' and host = 'localhost';" >>$SQL
	echo "flush privileges;" >>$SQL
	echo "grant backup_admin on *.* to root;" >>$SQL
	TARGET_CRED_OPT=`mount_target_credentials_opt "$CONFIG_FILE"` || return 1
	mysql --connect-expired-password --socket=$MYSQL_SOCKET -u root "-p$PASSWORD" <$SQL

	mysql_stop "$CONFIG_FILE" "init"
	rm $SQL
}

function list()
{
	LIST_REMOTE_HOST=
	local OPTIND l_opt
	while getopts "r:" l_opt; do
		case $l_opt in
			r)
				LIST_REMOTE_HOST=${OPTARG}
				;;
			\?)
				echo "Invalid option: -$OPTARG" >&2
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if [ $# -ne 1 ]; then
		usage
		return 1
	fi
	CMD=$1
	check_config_list || return 1
	if [ -n "$LIST_REMOTE_HOST" ]; then
		list_remote $CMD || return 1
		return
	fi
	case $CMD in
		full)
			list_full || return 1
			;;
		binlog)
			list_binlog || return 1
			;;
		*)
			usage
			return 1
			;;
	esac
}

function list_binlog()
{
	cd "$BINLOG_BACKUP_DIR" || return 1
	echo -e SEQUENCE '\t' DATE '\t\t' TIME
	echo "-----------------------------------------"
	LIST=`ls`
	for F in $LIST; do
		BINLOG=`echo $F | cut -d . -f 2`
		LOGSEQ=`expr $BINLOG + 0`
		BKP_FMT_TS="`stat -c %y "$F" | cut -d . -f 1`"
		DATE=${BKP_FMT_TS:0:10}
		TIME=${BKP_FMT_TS:11:8}
		echo -e $LOGSEQ '\t\t' $DATE '\t' $TIME
	done
}

function list_binlog_remote()
{
	ssh -q -o "StrictHostKeyChecking=no" $LIST_REMOTE_HOST MYSQL_SID=$MYSQL_SID myfreerman -q list binlog
}

function list_full()
{
	cd "$BASE_BACKUP_DIR" || return 1
	echo -e DATE '\t\t' TIME
	echo "-------------------------"
	LIST=`ls`
	for BKP in $LIST; do
		DATE=${BKP:0:10}
		TIME=${BKP:11:8}
		TIME=${TIME//-/:}
		echo -e $DATE '\t' $TIME
	done
}

function list_full_remote()
{
	ssh -q -o "StrictHostKeyChecking=no" $LIST_REMOTE_HOST MYSQL_SID=$MYSQL_SID myfreerman -q list full
}

function list_remote()
{
	REMOTE_USER=`whoami`
	REMOTE_INST=`echo $REMOTE_HOST | cut -d . -f 1`
	CONFIG_FILE=/etc/my.cnf
	CMD=$1
	case $CMD in
		full)
			list_full_remote || return 1
			;;
		binlog)
			list_binlog_remote || return 1
			;;
		*)
			usage
			return 1
			;;
	esac
}

function mount_credentials_opt()
{
	RESULT=
	if [ -n "$DB_HOSTNAME" ]; then
		RESULT="$RESULT --host=$DB_HOSTNAME"
	fi
	if [ -n "$DB_USERNAME" ]; then
		RESULT="$RESULT --user=$DB_USERNAME"
	fi
	if [ $USE_AUX_INSTANCE -eq 1 ]; then
		return
	fi
	if [ -n "$DB_PASSWORD" ]; then
		if [ -n "$RESULT" ]; then
			RESULT="$RESULT"
		fi
		RESULT="${RESULT}--password=$DB_PASSWORD"
	fi
	echo -n "$RESULT"
}

function mount_limit_memory_option()
{
	if [ -n "$MAX_MEM" ]; then
		echo "--limit-memory=$MAX_MEM"
	fi
}

function mount_slave_credentials_opt()
{
	RESULT=
	RESULT="--host=$SLAVE_HOSTNAME --port=$SLAVE_PORT"
	if [ -n "$DB_USERNAME" ]; then
		RESULT="$RESULT --user=$DB_USERNAME"
	fi
	if [ -n "$DB_PASSWORD" ]; then
		RESULT="$RESULT --password=$DB_PASSWORD"
	fi
	echo -n "$RESULT"
}

function mount_target_credentials_opt()
{
	RESULT=
	if [ -n "$DB_SOCKET" ]; then
		RESULT="$RESULT --socket=$DB_SOCKET"
	fi
	if [ -n "$DB_HOSTNAME" ]; then
		RESULT="$RESULT --host=$DB_HOSTNAME"
	fi
	if [ -n "$DB_USERNAME" ]; then
		RESULT="$RESULT --user=$DB_USERNAME"
	fi
	if [ -n "$DB_PASSWORD" ]; then
		RESULT="$RESULT --password=$DB_PASSWORD"
	fi
	echo -n "$RESULT"
}

function mount_aux_defaults_file_opt()
{
	if [ $USE_AUX_INSTANCE -eq 1 ]; then
		echo "--defaults-file=$AUX_CONFIG"
	fi
}

function mysql_start()
{
	CONFIG="$1"
	INST_TYPE="$2"
	START_TIMEOUT=60
	LOG_ERROR="`crudini --get \"$CONFIG\" $SERVER_INI_SECTION log_error 2>/dev/null`"
	CMD="mysqld"
	OPTS="--defaults-group-suffix=$MYSQL_DEFAULT_GROUP_SUFFIX --defaults-file=$CONFIG --bind-address=127.0.0.1 --console --super-read-only=off"
	write_out "Starting server (${INST_TYPE})"
	$CMD $OPTS & >"$LOG_ERROR" 2>&1
	PID=$!
	sleep 5
	COUNT=5
	while [ $COUNT -lt $START_TIMEOUT ]; do
		if tail -n 20 "$LOG_ERROR" | grep -iw "ready for connections" >/dev/null; then
			return 0
		fi
		if ! kill -0 $PID 2>/dev/null; then
			write_out "Cannot start server - check logs in '$LOG_ERROR'"
			return 1
		fi
		sleep 1
		COUNT=$((COUNT + 1))
	done
	write_out "Timeout reached waiting for server to start. Please check server logs in '$LOG_ERROR'"
	return 1
}

function mysql_stop()
{
	CONFIG="$1"
	INST_TYPE="$2"
	STOP_TIMEOUT=60
	PID_FILE="`crudini --get \"$CONFIG\" $SERVER_INI_SECTION pid_file 2>/dev/null`"
	LOG_ERROR="`crudini --get \"$CONFIG\" $SERVER_INI_SECTION log_error 2>/dev/null`"
	write_out "Stopping server (${INST_TYPE})"
	PID=`cat "$PID_FILE"`
	kill $PID
	sleep 1
	COUNT=1
	while [ $COUNT -lt $STOP_TIMEOUT ]; do
		if ! kill -0 $PID 2>/dev/null; then
			return 0
		fi
		sleep 1
		COUNT=`expr $COUNT + 1`
	done
	write_out "Timeout reached waiting server to stop. Check server logs [${LOG_ERROR}]."
	return 1
}

function port_available()
{
	PORT=$1
	if netstat -an | grep -w $PORT >/dev/null; then
		return 1
	fi
	return 0
}

function query()
{
	CMD=`echo $1 | awk '{print tolower($0)}'`
	shift
	case $CMD in
		backup_age)
			query_backup_age || return 1
			;;
		*)
			usage
			;;
	esac
}

function query_backup_age()
{
	FULL=`query_full_backup_age` || return 1
	BINLOG=`query_binlog_backup_age` || return 1
	echo "FULL|$FULL"
	echo "BINLOG|$BINLOG"
}

function query_binlog_backup_age()
{
	cd $BINLOG_BACKUP_DIR || return 1
	LAST_FILE=`ls -tr | tail -n 1`
	DATE=${BKP:0:10}
	TIME=${BKP:11:8}
	TIME=${TIME//-/:}
	BKP_FMT_TS="`stat -c %y $LAST_FILE | cut -d . -f 1`"
	BKP_TS_EPOCH=`date -d "$BKP_FMT_TS" +%s`
	DIFF=`expr $NOW_EPOCH - $BKP_TS_EPOCH`
	RESULT=`echo "scale = 2; $DIFF / 3600" | bc`
	echo $RESULT
}

function query_full_backup_age()
{
	cd "$BASE_BACKUP_DIR" || return 1
	BKP=`ls | tail -n 1`
	DATE=${BKP:0:10}
	TIME=${BKP:11:8}
	TIME=${TIME//-/:}
	BKP_FMT_TS="$DATE $TIME"
	BKP_TS_EPOCH=`date -d "$BKP_FMT_TS" +%s`
	DIFF=`expr $NOW_EPOCH - $BKP_TS_EPOCH`
	RESULT=`echo "scale = 2; $DIFF / 3600 / 24" | bc`
	echo $RESULT
}

function read_binlog()
{
	LOGSEQ=$1
	POSITION=$2
	STOP_DATETIME_OPT="--stop-datetime=$3"
	SQL_DEST=$4
	RECOVER_DB=
	if [ $# -ge 5 ]; then
		RECOVER_DB=$5
	fi
	POSITION_OPTION=
	if [ $POSITION -ne 0 ]; then
		POSITION_OPTION="--start-position=$POSITION"
	fi
	BINLOG=`get_binlog_path $LOGSEQ`
	PLAIN_BINLOG=$BINLOG
	TMP_BINLOG=
	if file $PLAIN_BINLOG | grep -w gzip >/dev/null; then
		TMP_BINLOG=`mktemp /tmp/myfreerman.XXXXXX`
		PLAIN_BINLOG=$TMP_BINLOG
		gunzip -c $BINLOG >$PLAIN_BINLOG || return 1
	fi
	DB_OPTION=
	if [ -n "$RECOVER_DB" ]; then
		DB_OPTION="--database=$RECOVER_DB"
	fi
	mysqlbinlog $DB_OPTION "$STOP_DATETIME_OPT" $POSITION_OPTION $PLAIN_BINLOG >>$SQL_DEST || return 1
	if [ -n "$TMP_BINLOG" ]; then
		rm $TMP_BINLOG
	fi
}

function read_config()
{
	#mount ini section
	INI_SECTION=myfreerman
	if [ -n "$MYSQL_SID" ]; then
		INI_SECTION=${INI_SECTION}@${MYSQL_SID}
	fi

	#config file is not required
	#for example, in clusters with vip, oem agent runs on a third host
	#and it must list backups remotely - no configuration required in target host
	if ! [ -f "$CONFIG_FILE" ]; then
		return
	fi

	BACKUP_DIR="`crudini --get "$CONFIG_FILE" $INI_SECTION backup_dir 2>/dev/null`"

	AUX_BASEDIR="`crudini --get "$CONFIG_FILE" $INI_SECTION aux_basedir 2>/dev/null`"

	DB_SOCKET="`crudini --get "$CONFIG_FILE" $INI_SECTION db_socket 2>/dev/null`"
	DB_HOSTNAME="`crudini --get "$CONFIG_FILE" $INI_SECTION db_hostname 2>/dev/null`"
	DB_PASSWORD="`crudini --get "$CONFIG_FILE" $INI_SECTION db_password 2>/dev/null`"
	DB_USERNAME="`crudini --get "$CONFIG_FILE" $INI_SECTION db_username 2>/dev/null`"

	#log directory
	LOG_DIR="`crudini --get "$CONFIG_FILE" $INI_SECTION log_dir 2>/dev/null`"

	#lock file
	LOCK_FILE="`crudini --get "$CONFIG_FILE" $INI_SECTION lock_file 2>/dev/null`"

	#max memory
	MAX_MEM="`crudini --get "$CONFIG_FILE" $INI_SECTION max_mem 2>/dev/null`"

	#read only
	READ_ONLY="`crudini --get "$CONFIG_FILE" $INI_SECTION read_only 2>/dev/null`"
	#default: 0
	if [ -z "${READ_ONLY}" ]; then
		READ_ONLY=0
	fi

	#read threads
	READ_THREADS="`crudini --get "$CONFIG_FILE" $INI_SECTION read_threads 2>/dev/null`"
	#default: 1
	if [ -z "$READ_THREADS" ]; then
		READ_THREADS=1
	fi

	#retention period
	RETENTION_PERIOD="`crudini --get "$CONFIG_FILE" $INI_SECTION retention_period 2>/dev/null`"

	#slave server
	SLAVE_SERVER="`crudini --get "$CONFIG_FILE" $INI_SECTION slave_server 2>/dev/null`"

	#write threads
	WRITE_THREADS="`crudini --get "$CONFIG_FILE" $INI_SECTION write_threads 2>/dev/null`"
	#default: 1
	if [ -z "$WRITE_THREADS" ]; then
		WRITE_THREADS=1
	fi

	check_config || return 1
}

function recover()
{
	BASE_BACKUP=$1
	REQ_TIMESTAMP="$2"
	MY_REQ_TIMESTAMP="${REQ_TIMESTAMP/_/ }"
	CONFIG="$3"
	SOCKET="$4"
	TMP_SQL=`mktemp /tmp/myfreerman.XXXXXX`
	LOGSEQ=`get_base_backup_binlog_sequence $BASE_BACKUP`
	POSITION=`get_base_backup_binlog_position $BASE_BACKUP`
	ITYPE="restricted"
	if [ $USE_AUX_INSTANCE -eq 1 ]; then
		ITYPE="aux"
	fi
	if ! mysql_start "$CONFIG" $ITYPE; then
		if [ $USE_AUX_INSTANCE -eq 1 ]; then
			rm -fr "$AUX_BASEDIR"
		fi
		return 1
	fi
	write_out "Applying binary log sequence $LOGSEQ"
	if ! read_binlog $LOGSEQ $POSITION "$MY_REQ_TIMESTAMP" $TMP_SQL $RECOVER_DB; then
		mysql_stop "$CONFIG" $ITYPE
		return 1
	fi
	if ! apply_binlog $TMP_SQL "$SOCKET"; then
		mysql_stop "$CONFIG" $ITYPE
		return 1
	fi

	LOGSEQ=`expr $LOGSEQ + 1`
	while binlog_backup_exists $LOGSEQ; do
		rm $TMP_SQL || return 1
		touch $TMP_SQL || return 1
		write_out "Applying binary log sequence $LOGSEQ"
		read_binlog $LOGSEQ 0 "$MY_REQ_TIMESTAMP" $TMP_SQL || return 1
		if ! apply_binlog $TMP_SQL "$SOCKET"; then
			mysql_stop "$CONFIG" $ITYPE
			return 1
		fi
		LOGSEQ=`expr $LOGSEQ + 1`
	done
	if [ $USE_AUX_INSTANCE -eq 1 ]; then
		while binlog_exists $LOGSEQ; do
			rm $TMP_SQL || return 1
			touch $TMP_SQL || return 1
			write_out "Applying binary log sequence $LOGSEQ"
			read_binlog $LOGSEQ 0 "$MY_REQ_TIMESTAMP" $TMP_SQL || return 1
			if ! apply_binlog $TMP_SQL "$SOCKET"; then
				mysql_stop "$CONFIG" $ITYPE
				return 1
			fi
			LOGSEQ=`expr $LOGSEQ + 1`
		done
	fi
	rm $TMP_SQL
}

function remove_lock_file()
{
	if [ -n "$LOCK_FILE" ]; then
		rm -f "$LOCK_FILE"
	fi
}

function remove_old_backups()
{
	remove_old_full_backups || return 1
	remove_old_binlog_backups || return 1
}

function remove_old_binlog_backups()
{
	cd "${BINLOG_BACKUP_DIR}" || return 1
	OLDEST_BKP=`ls ${BASE_BACKUP_DIR} | head -n 1`
	LIST=`find . -type f \! -newer "${BASE_BACKUP_DIR}/${OLDEST_BKP}"` || return 1
	for BINLOG in $LIST; do
		write_out "Removing expired backup of binary log sequence $LOGSEQ"
		BINLOG=`basename $BINLOG`
		rm -f $BINLOG || return 1
		BINLOG=`echo $BINLOG | cut -d . -f 2`
		LOGSEQ=`expr $BINLOG + 0`
	done
}

function remove_old_full_backups()
{
	REF_TIMESTAMP=`date --date="-$RETENTION_PERIOD days" +%Y%m%d%H%M%S`
	cd "$BACKUP_DIR" || return 1
	mkdir -p "$BASE_BACKUP_DIR" || return 1
	cd "$BASE_BACKUP_DIR" || return 1
	COUNT=`ls |wc -l`
	if [ $COUNT -eq 0 ]; then
		return 0
	fi
	PREV_BKP=
	for BKP in *; do
		DATE=${BKP:0:10}
		TIME=${BKP:11:8}
		TIME=${TIME//-/:}
		BKP_FMT_TS="$DATE $TIME"
		BKP_TIMESTAMP=`date --date="$BKP_FMT_TS" +%Y%m%d%H%M%S`
		if [ $BKP_TIMESTAMP -ge $REF_TIMESTAMP ]; then
			return
		fi
		if [ -n "$PREV_BKP" ]; then
			write_out "Removing expired full backup $PREV_BKP"
			rm -fr $PREV_BKP || return 1
			PREV_BKP=`echo $PREV_BKP | cut -d . -f 1`
		fi
		PREV_BKP=$BKP
	done
}

function reset_master()
{
	mysql $TARGET_CRED_OPT -e "reset master;" >/dev/null || return 1
}

function restore()
{
	PITR=0
	RESTORE_TABLE_LIST=
	REQ_TIMESTAMP=`date +%Y-%m-%d_%H:%M:%S`
	SLAVE=0
	ANSWER_YES=0
	CUR_SOCKET="$DB_SOCKET"
	local OPTIND l_opt
	while getopts ":f:np:d:st:x:y" l_opt; do
		case $l_opt in
			d)
				RESTORE_DB_OLD_NAME=${OPTARG}
				;;
			f)
				BACKUP_DIR="${OPTARG}"
				;;
			n)
				DB_COPY=1
				;;
			p)
				PITR=1
				REQ_TIMESTAMP=${OPTARG}
				ISO_REQ_TIMESTAMP=${OPTARG/_/ }
				DIR=`find_base_backup "$ISO_REQ_TIMESTAMP"` || return 1
				;;
			s)
				SLAVE=1
				;;
			t)
				RESTORE_TABLE_LIST="$RESTORE_TABLE_LIST ${OPTARG}"
				;;
			x)
				RESTORE_DB_NEW_NAME=${OPTARG}
				;;
			y)
				ANSWER_YES=1
				;;
			\?)
				echo "Invalid option: -$OPTARG" >&2
				return 1
				;;
			: )
				echo "Invalid option: $OPTARG requires an argument" 1>&2
				return 1
				;;
		esac
	done
	restore_validate_options || return 1
	BASE_BACKUP_DIR="$BACKUP_DIR/base"
	BINLOG_BACKUP_DIR="$BACKUP_DIR/binlog"
	DIR=
	if cd "$BASE_BACKUP_DIR" 2>/dev/null; then
		DIR=`ls | tail -n 1 | cut -d . -f 1`
	fi
	if [ -z "$DIR" ]; then
		write_out "No backup to be restored"
		return 1
	fi
	if ! confirm_operation; then
		return 0
	fi
	if ! [ -f "$CONFIG_FILE" ]; then
		write_out "Cannot find readable file '$CONFIG_FILE'"
		return 1
	fi
	#check_backup_consistency || return 1
	cd "$BACKUP_DIR" || return 1
	if [ -n "$RESTORE_DB_OLD_NAME" -o -n "$RESTORE_TABLE_LIST" ]; then
		#only when database is running locally
		if [ -z "$DB_SOCKET" ]; then
			write_out "For schema/table restoration, database must be running locally"
			return 1
		fi
		USE_AUX_INSTANCE=1
		#target instance must be running
		if ! mysqladmin $TARGET_CRED_OPT status >/dev/null 2>&1; then
			write_out "Cannot connect to target instance"
			return 1
		fi
		BINLOG_PREFIX=`mysql $TARGET_CRED_OPT -e "show variables like 'log_bin_basename'" | tail -n 1 | cut -f 2 -d$'\t'` || return 1
	fi
	DB_COPY=0
	MOMENT=`date +%Y%m%d-%H%M%S`
	AUX_SOCKET_OPT=
	if ! [ -d "$BASE_BACKUP_DIR" ]; then
		write_out "No backup to be restored"
		return 1
	fi
	DATADIR="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION datadir`" 2>/dev/null
	REDODIR="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION innodb_log_group_home_dir 2>/dev/null`"
	UNDODIR="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION innodb_undo_directory 2>/dev/null`"
	BINLOG_INDEX="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION log_bin_index 2>/dev/null`"
	RELAY_LOG_INDEX="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION relay_log_index 2>/dev/null`"
	BINLOG_PREFIX="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION log_bin 2>/dev/null`"
	if [ -n "$BINLOG_PREFIX" ]; then
		BINLOG_DIR="`dirname $BINLOG_PREFIX`" || return 1
	fi
	RELAY_LOG_MASK="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION relay_log 2>/dev/null`"
	if [ -n "$RELAY_LOG_MASK" ]; then
		RELAY_LOG_DIR="`dirname $RELAY_LOG_MASK`" || return 1
	fi

	#secure files directory
	SECURE_DIR="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION secure_file_priv 2>/dev/null`"

	#mysqld user
	MYSQLD_USER="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION user 2>/dev/null`"

	if [ "$RESTORE_DB_OLD_NAME" = "mysql" -o "$RESTORE_DB_OLD_NAME" = "sys" -o "$RESTORE_DB_OLD_NAME" = "information_schema" ]; then
		echo "Invalid database name '$RESTORE_DB_OLD_NAME'" >&2
		return 1
	fi
	if [ "$RESTORE_DB_NEW_NAME" = "mysql" -o "$RESTORE_DB_NEW_NAME" = "sys" -o "$RESTORE_DB_NEW_NAME" = "information_schema" ]; then
		echo "Invalid database name '$RESTORE_DB_NEW_NAME'" >&2
		return 1
	fi
	CONFIG="$CONFIG_FILE"
	if [ $USE_AUX_INSTANCE -eq 1 ]; then
		if [ -z "$AUX_BASEDIR" ]; then
			write_out "When restoring a single database or a table, AUX_BASEDIR configuration must be set"
			return 1
		fi
		if ! [ -d "$AUX_BASEDIR" ]; then
			write_out "No such directory: $AUX_BASEDIR" >&2
			return 1
		fi
		check_aux_binaries || return 1
		AUX_BASEDIR=`mktemp -d -p "$AUX_BASEDIR" -t "aux_XXXXXXXX"` || return 1
		BASENAME=`basename "$AUX_BASEDIR"` || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$AUX_BASEDIR" || return 1
		fi
		DB_COPY=1
		AUX_CONFIG=/tmp/${BASENAME}.cnf
		CONFIG="$AUX_CONFIG"
		AUX_BINLOG_PREFIX="${AUX_BASEDIR}/${BINLOG_PREFIX}"
		AUX_BINLOG_INDEX="${AUX_BASEDIR}/${BINLOG_INDEX}"
		AUX_DATADIR="$AUX_BASEDIR/${DATADIR}"
		AUX_LOG_ERROR=`mktemp /tmp/mysql.XXXXXX.log`
		AUX_PID_FILE="$AUX_BASEDIR/pid_file"
		AUX_SOCKET="$AUX_BASEDIR/socket"
		AUX_PORT=`find_aux_port` || return 1
		AUX_REDODIR="${AUX_BASEDIR}/${REDODIR}"
		AUX_SOCKET_OPT="--socket=$AUX_SOCKET"
		AUX_UNDODIR="${AUX_BASEDIR}/${UNDODIR}"
		CUR_SOCKET="$AUX_SOCKET"
	fi
	check_new_db_name || return 1
	write_out "Starting restore"
	MODE=off
	if [ $SLAVE -eq 1 ]; then
		MODE=on
	fi
	write_out "Slave mode: $MODE"
	MYSQLD_USER="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION user`" 2>/dev/null
	if [ $USE_AUX_INSTANCE -eq 0 ]; then	
		restore_target_instance $DIR || return 1
	else
		restore_aux_instance $DIR || return 1
	fi
	if [ $SLAVE -eq 1 ]; then
		return
	fi
	ITYPE="restricted"
	if [ $USE_AUX_INSTANCE -eq 1 ]; then
		ITYPE="aux"
	fi
	recover $DIR "$REQ_TIMESTAMP" "$CONFIG" "$CUR_SOCKET" || return 1
	if [ -n "$RESTORE_DB_OLD_NAME" ]; then
		copy_recovered_db || (mysql_stop "$CONFIG" $ITYPE && return 1)
	fi
	if [ -n "$RESTORE_TABLE_LIST" ]; then
		copy_restored_tables || (mysql_stop "$CONFIG" $ITYPE && return 1)
	fi
	if [ $PITR -eq 1 -a $DB_COPY -eq 0 ]; then
		create_incarnation $MOMENT
		write_out "Resetting binary logs"
		reset_master || return 1
	fi
	mysql_stop "$CONFIG" $ITYPE

	#if using aux instance, remove files
	if [ $USE_AUX_INSTANCE -eq 1 ]; then
		rm -fr "$AUX_BASEDIR"
		rm "$AUX_LOG_ERROR"
	fi
}

function restore_aux_instance()
{
	DIR="${1}"
	create_aux_config $DIR || return 1
	rm -fr "$AUX_DATADIR/*" || return 1
	mkdir -p $AUX_DATADIR || return 1
	LIM_MEM_OPT=`mount_limit_memory_option`
	FULL_DIR="${BASE_BACKUP_DIR}/${DIR}"
	write_out "===== STARTING mysqlbackup ====="
	if [ -n "$LOG_FILE" ]; then
		TMP_LOG=`mktemp /tmp/myfreerman.XXXXXX` || return 1
		mysqlbackup --defaults-group-suffix=$MYSQL_DEFAULT_GROUP_SUFFIX --defaults-file=$AUX_CONFIG --read-threads=$READ_THREADS --write-threads=$WRITE_THREADS --backup-dir="$FULL_DIR" --skip-messages-logdir $LIM_MEM_OPT copy-back --log-bin="${AUX_BINLOG_PREFIX}" --log-bin-index="${AUX_BINLOG_INDEX}" >$TMP_LOG 2>&1
		RETCODE=$?
		cat $TMP_LOG
		cat $TMP_LOG >>"$LOG_FILE"
		rm $TMP_LOG
		if [ $RETCODE -ne 0 ]; then
			return 1
		fi
	else
		mysqlbackup --defaults-group-suffix=$MYSQL_DEFAULT_GROUP_SUFFIX --defaults-file=$AUX_CONFIG --read-threads=$READ_THREADS --write-threads=$WRITE_THREADS --backup-dir="$FULL_DIR" --skip-messages-logdir $LIM_MEM_OPT copy-back --log-bin="${AUX_BINLOG_PREFIX}" --log-bin-index="${AUX_BINLOG_INDEX}" || return 1
	fi
	write_out "===== FINISHED mysqlbackup ===== "

#===========================================
#Rodrigo Tassinari - 2020-03-11
#BUG in MEB 8.0.18:
#Binary log index informed in --log-bin-index is appended a text ".index", and manual does not say that
#So, we rename it
	BUG_BINLOG_INDEX="${AUX_BINLOG_INDEX}.index" 
	mv "$BUG_BINLOG_INDEX" "$AUX_BINLOG_INDEX" || return 1
#===========================================

	#create log file
	touch "$AUX_LOG_ERROR" || return 1
	#change ownership
	if [ -n "$MYSQLD_USER" ]; then
		chown $MYSQLD_USER "$AUX_LOG_ERROR" || return 1
		chown -R $MYSQLD_USER "$AUX_BASEDIR" || return 1
	fi
}

function restore_target_instance()
{
	DIR="${1}"
	#if server is running, abort
	if mysqladmin $TARGET_CRED_OPT >/dev/null 2>&1; then
		write_out "MySQL is running - aborting"
		return 1
	fi
	mkdir -p "$DATADIR" || return 1
	if [ -n "$MYSQLD_USER" ]; then
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DATADIR" || return 1
		fi
	fi

	if [ -n "$UNDODIR" ]; then
		if [ "${UNDODIR:0:1}" != "/" ]; then
			UNDODIR="$DATADIR/$UNDODIR"
		fi
		mkdir -p "$UNDODIR" || return 1
		rm -fr "$UNDODIR/"* || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$UNDODIR" || return 1
		fi
	fi

	#redo
	if [ -n "$REDODIR" ]; then
		if [ "${REDODIR:0:1}" != "/" ]; then
			REDODIR="$DATADIR/$REDODIR"
		fi
		mkdir -p "$REDODIR" || return 1
		if ls -d "$REDODIR"/* >/dev/null 2>&1; then
			write_out "Redo directory [$REDODIR] must be empty"
			return 1
		fi
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$REDODIR" || return 1
		fi
	fi
	if [ -n "$BINLOG_DIR" ]; then
		mkdir -p "$BINLOG_DIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$BINLOG_DIR" || return 1
		fi
	fi
	if [ -n "$SECURE_DIR" ]; then
		mkdir -p "$SECURE_DIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$SECURE_DIR" || return 1
		fi
		chmod 700 "$SECURE_DIR" || return 1
	fi
	check_empty_target_database || return 1
	check_target_instance_config || return 1
	LIM_MEM_OPT=`mount_limit_memory_option`
	FULL_DIR="${BASE_BACKUP_DIR}/${DIR}"
	write_out "===== STARTING mysqlbackup ====="
	if [ -n "$LOG_FILE" ]; then
		TMP_LOG=`mktemp /tmp/myfreerman.XXXXXX` || return 1
		mysqlbackup --defaults-group-suffix=$MYSQL_DEFAULT_GROUP_SUFFIX --defaults-file=$CONFIG_FILE --read-threads=$READ_THREADS --write-threads=$WRITE_THREADS --backup-dir="$FULL_DIR" --skip-messages-logdir $LIM_MEM_OPT copy-back --log-bin="${BINLOG_PREFIX}" --log-bin-index="${BINLOG_INDEX}" >$TMP_LOG 2>&1 
		RETCODE=$?
		cat $TMP_LOG >>"$LOG_FILE"
		cat $TMP_LOG
		rm $TMP_LOG
		if [ $RETCODE -ne 0 ]; then
			return 1
		fi
	else
		mysqlbackup --defaults-group-suffix=$MYSQL_DEFAULT_GROUP_SUFFIX --defaults-file=$CONFIG_FILE --read-threads=$READ_THREADS --write-threads=$WRITE_THREADS --backup-dir="$FULL_DIR" --skip-messages-logdir $LIM_MEM_OPT copy-back --log-bin="${BINLOG_PREFIX}" --log-bin-index="${BINLOG_INDEX}" || return 1 
	fi
	write_out "===== FINISHED mysqlbackup ====="
#===========================================
#Rodrigo Tassinari - 2020-03-11
#BUG in MEB 8.0.18:
#Binary log index informed in --log-bin-index is appended a text ".index", and manual does not say that
#So, we rename it
	BUG_BINLOG_INDEX="${BINLOG_INDEX}.index" 
	mv "$BUG_BINLOG_INDEX" "$BINLOG_INDEX" || return 1
#===========================================
	if [ -n "$MYSQLD_USER" ]; then
		write_out "Setting permissions"
		chown -R $MYSQLD_USER "$DATADIR" || return 1
		if [ -n "$REDODIR" ]; then
			chown -R $MYSQLD_USER "$REDODIR" || return 1
		fi
		if [ -n "$UNDODIR" ]; then
			chown -R $MYSQLD_USER "$UNDODIR" || return 1
		fi
		if [ -n "$BINLOG_INDEX" -a -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$BINLOG_INDEX" || return 1
		fi
		if [ -n "$BINLOG_DIR" -a -n "$MYSQLD_USER" ]; then
			chown -R $MYSQLD_USER "$BINLOG_DIR" || return 1
		fi
		if [ -n "$RELAY_LOG_INDEX" -a -n "$MYSQLD_USER" -a -f "$RELAY_LOG_INDEX" ]; then
			chown $MYSQLD_USER "$RELAY_LOG_INDEX" || return 1
		fi
		if [ -n "$RELAY_LOG_DIR" -a -n "$MYSQLD_USER" ]; then
			chown -R $MYSQLD_USER "$RELAY_LOG_DIR" || return 1
		fi
	fi
}

function restore_validate_options()
{
	#backup directory must exist
	if ! [ -d "$BACKUP_DIR" ]; then
		write_out "Directory not found: $BACKUP_DIR"
		return 1
	fi

	if [ -n "$RESTORE_DB_NEW_NAME" -a -z "$RESTORE_DB_OLD_NAME" ]; then
		echo "Option -x requires -d" >&2
		return 1
	fi
	if [ -n "$RESTORE_DB_OLD_NAME" -a -n "$RESTORE_TABLE_LIST" ]; then
		echo "Options -d and -t cannot be used together" >&2
		return 1
	fi
	if [ -n "$RESTORE_TABLE_LIST" ]; then
		restore_validate_tablenames || return 1
	fi
}

function restore_validate_tablenames()
{
	for QT in $RESTORE_TABLE_LIST; do
		if ! echo "$QT" | grep \\. >/dev/null; then
			echo "Invalid table name: '$QT' - table names must be qualified with schema" >&2
			return 1
		fi
		SCHEMA=`echo $QT | cut -d . -f 1`
		TABLE=`echo $QT | cut -d . -f 2`
		if [ -z "$SCHEMA" -o -z "$TABLE" ]; then
			echo "Invalid table name: '$QT' - table names must be qualified with schema" >&2
			return 1
		fi
	done
}

function run()
{
	CONFIG_FILE=/etc/my.cnf
	LOG_FILE_BASENAME=
	QUIET=0
	while getopts "l:c:q" opt; do
		case $opt in
			l)
				LOG_FILE_BASENAME=`date "+$OPTARG"` || return 1
				;;
			c)
				CONFIG_FILE="$OPTARG"
				;;
			q)
				QUIET=1
				;;
			\?)
				echo "Invalid option: -$OPTARG" >&2
				;;
		esac
	done
	shift $((OPTIND-1))
	if [ $QUIET -eq 0 ]; then
		header
	fi
	if [ $# -lt 1 ]; then
		usage
		return 1
	fi
	read_config || return 1
	LOG_FILE=
	if [ -n "$LOG_FILE_BASENAME" ]; then
		LOG_FILE="${LOG_DIR}/$LOG_FILE_BASENAME"
	fi
	TARGET_CRED_OPT=`mount_target_credentials_opt` || return 1
	MYHOST=`hostname`
	BASE_BACKUP_DIR="$BACKUP_DIR/base"
	BINLOG_BACKUP_DIR="$BACKUP_DIR/binlog"
	RESTORE_BACKUP_DIR="$BACKUP_DIR/restore"
	CMD=`echo $1 | awk '{print tolower($0)}'`
	shift
	USE_AUX_INSTANCE=0
	SERVER_INI_SECTION=mysqld
	if [ -n "$MYSQL_SID" ]; then
		SERVER_INI_SECTION="${SERVER_INI_SECTION}@$MYSQL_SID"
		MYSQL_DEFAULT_GROUP_SUFFIX="@$MYSQL_SID"
	fi
	case $CMD in
		query)
			query $* || return 1
			;;
		backup)
			check_lock_file || return 1
			if ! backup $*; then
				remove_lock_file
				return 1
			fi
			remove_lock_file
			write_out "Finished"
			;;
		init)
			init || return 1
			write_out "Finished"
			;;
		list)
			if ! list $*; then
				return 1
			fi
			;;
		restore)
			check_lock_file || return 1
			if ! restore $*; then
				remove_lock_file
				return 1
			fi
			remove_lock_file
			write_out "Finished"
			;;
		*)
			if [ -n "$CMD" ]; then
				echo "Invalid command: $CMD" >&2
			fi
			usage
			return 1
			;;
	esac
}

function uncompress_backup()
{
	BKP="$1"
	TAR_FILE="${BASE_BACKUP_DIR}/${BKP}.tgz"
	tar -C "${BASE_BACKUP_DIR}" -x -z -f "${TAR_FILE}" || return 1
}

function usage()
{
	echo "Usage:  myfreerman [ -c <config file> ] [ -l <log file format> ] [ -q ] <command> [ <cmd options> ]"
	echo "- options:"
	echo "   -c   use a specific config file"
	echo "   -l   specify format for log file name"
	echo "   -q   quiet mode - do not print release information"
	echo "- command:"
	echo "   init"
	echo "   backup full|binlog"
	echo "   restore [ -y ] [ -n ] [ -f <directory> ] [ -p yyyy-mm-dd_hh24:mi:ss ] [ -d <schema> [ -x <schema> ] | [ -t <schema1.table1> [ -t <schema2.table2> [ ... ] ] ] ]"
	echo "   list [-h <hostname> [-P <port>]] full|binlog"
}

function wait_server_start()
{
	START_TIMEOUT=60
	PID=$1
	CONF_FILE="$2"
	LOG_ERROR="`crudini --get \"$CONF_FILE\" $SERVER_INI_SECTION log_error 2>/dev/null`"
	sleep 5
	COUNT=5
	while [ $COUNT -lt $START_TIMEOUT ]; do
		if tail -n 20 "$LOG_ERROR" | grep -iw "ready for connections" >/dev/null; then
			return 0
		fi
		if ! kill -0 $PID 2>/dev/null; then
			return 1
		fi
		sleep 1
		COUNT=$((COUNT + 1))
	done
}

function write_out()
{
	MSG="$1"
	TS=`date +"%H:%M:%S"`
	echo "[$TS] $MSG"
	if [ -n "$LOG_FILE" ]; then
		echo "[$TS] $MSG" >>"$LOG_FILE"
	fi
}

if [ "$DEBUG" == "1" ]; then
	set -x
fi
NOW_EPOCH=`date +%s`
DATE_VAL=`date +%Y-%m-%d`
TIME_VAL=`date +%H:%M:%S`
MAX_READ_THREADS=20
MAX_WRITE_THREADS=20
READ_THREADS=1
WRITE_THREADS=1
READ_ONLY=0
LOG_FILE=
check_depends || exit -1
run $*
RETCODE=$?
exit $RETCODE
