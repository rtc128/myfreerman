#!/bin/bash
RELEASE=1.5.12

function apply_binlog()
{
	FILENAME="$1"
	SOCKET="$2"
	#mysql $TARGET_CRED_OPT --socket="$SOCKET" <"$FILENAME" || return 1
	mysql --socket="$SOCKET" <"$FILENAME" || return 1
}

function backup()
{
	local OPTIND l_opt
	while getopts "h" opt; do
		case $opt in
			h)
				help_backup
				return
				;;
			\?)
				echo "Invalid option: -$OPTARG" >&2
				main_help
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if [ $# -lt 1 ]; then
		help_backup
		return 1
	fi
	check_config_backup || return 1
	if [ $READ_ONLY -eq 1 ]; then
		write_out "Read-only mode is enabled in configuration"
		return 1
	fi

	TARGET_CRED_OPT=`mount_target_credentials_opt`
	if ! mysqladmin $TARGET_CRED_OPT ping >/dev/null 2>&1; then
		write_out "No MySQL server running - ignoring backup"
		return
	fi
	if ! which mysqlbackup >/dev/null 2>&1; then
		write_out "Cannot find 'mysqlbackup' in PATH"
		return 1
	fi
	BKP_TYPE=`echo $1 | awk '{print tolower($0)}'`
	shift
	BINLOG_PREFIX=`mysql $TARGET_CRED_OPT -e "show variables like 'log_bin_basename'" | tail -n 1 | cut -f 2 -d$'\t'` || return 1
	BINLOG_DIR="`dirname \"$BINLOG_PREFIX\"`" || return 1
	DATADIR=`mysql $TARGET_CRED_OPT -e "show variables like 'datadir'" | tail -n 1 | cut -f 2 -d$'\t'` || return 1
	case $BKP_TYPE in
		full)
			backup_full $* || return 1
			;;
		binlog)
			backup_binlog $* || return 1
			;;
		*)
			echo "Invalid backup type '$BKP_TYPE'" >&2
			help_backup
			return 1
			;;
	esac
}

function backup_binlog()
{
	local OPTIND l_opt
	while getopts "h" opt; do
		case $opt in
			h)
				help_backup_binlog
				return
				;;
			\?)
				help_backup_binlog
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if [ $# -ne 0 ]; then
		help_backup_binlog
		return 1
	fi
	check_config_backup_binlog || return 1
	cd "$BACKUP_DIR" || return 1
	if ! exist_base_backup; then
		echo "No full backup was previously done" >&2
		return 1
	fi

	#create binlog backup dir
	mkdir -p "$BINLOG_BACKUP_DIR" || return 1

	#flush logs
	mysqladmin $TARGET_CRED_OPT flush-logs || return 1

	BINLOG_PREFIX="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION log_bin 2>/dev/null`"
	if [ -n "$BINLOG_PREFIX" ]; then
		BINLOG_DIR="`dirname $BINLOG_PREFIX`" || return 1
		BINLOG_BNAME="`basename $BINLOG_PREFIX`" || return 1
	fi

	check_lock_file || return 1
	#list binlogs, just ignoring the last one
	LIST_FILE=`mktemp /tmp/myfreerman.XXXXXX` || return 1
	mysql $TARGET_CRED_OPT -e "show binary logs\G" | grep -wi log_name | cut -d \  -f 3 >$LIST_FILE || { remove_lock_file && return 1; }
			
	TOTAL=`cat $LIST_FILE | wc -l` || { remove_lock_file && return 1; }
	COUNT=$((TOTAL - 1))
	LIST=`head -n $COUNT $LIST_FILE`
	LAST_BINLOG=`tail -n 1 $LIST_FILE`
	rm $LIST_FILE
	for BINLOG in $LIST; do
		if ! [ -f "$BINLOG_BACKUP_DIR/${BINLOG}.gz" ]; then
			LONG_LOGSEQ=`echo $BINLOG | cut -d . -f 2`
			LOGSEQ=`expr $LONG_LOGSEQ + 0`
			write_out "Saving binary log sequence $LOGSEQ"
			gzip -c9 "$BINLOG_DIR/$BINLOG" >"$BINLOG_BACKUP_DIR/${BINLOG}.gz" || { remove_lock_file && return 1; }
		fi
	done
	check_purge_binlogs $LAST_BINLOG || { remove_lock_file && return 1; }
	remove_lock_file
}

function backup_full()
{
	local OPTIND l_opt
	while getopts "d:h" opt; do
		case $opt in
			d)
				BACKUP_DIR="$OPTARG"
				;;
			h)
				help_backup_full
				return
				;;
			\?)
				help_backup_full
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if  [ $# -ne 0 ]; then
		help_backup_full
		return 1
	fi
	if ! [ -d "$BACKUP_DIR" ]; then
		write_out "Cannot find directory '$BACKUP_DIR'"
		return 1
	fi
	cd "$BACKUP_DIR" || return 1

	BASE_BACKUP_DIR="$BACKUP_DIR/base"
	TMP_BACKUP_DIR="$BACKUP_DIR/tmp"

	mkdir -p "$TMP_BACKUP_DIR" || return 1
	mkdir -p "$BASE_BACKUP_DIR" || return 1
	DATE_VAL=`date +%Y-%m-%d`
	TIME_VAL=`date +%H-%M-%S`
	TIMESTAMP=${DATE_VAL}_${TIME_VAL}
	TMP_DIRECTORY="${TMP_BACKUP_DIR}/${TIMESTAMP}" || return 1
	mkdir "${TMP_DIRECTORY}" || return 1
	DIRECTORY="${BASE_BACKUP_DIR}/${TIMESTAMP}" || return 1
	LIM_MEM_OPT=`mount_limit_memory_option`
	write_out "===== STARTING mysqlbackup ====="
	if [ -n "$LOG_FILE" ]; then
		TMP_LOG=`mktemp /tmp/myfreerman.XXXXXX` || return 1
		mysqlbackup $TARGET_CRED_OPT --read-threads=$READ_THREADS --write-threads=$WRITE_THREADS --process-threads=$PROCESS_THREADS --backup-dir="${TMP_DIRECTORY}" $LIM_MEM_OPT backup-and-apply-log >$TMP_LOG 2>&1 
		RETCODE=$?
		cat $TMP_LOG
		cat $TMP_LOG >>"$LOG_FILE"
		rm $TMP_LOG
		if [ $RETCODE -ne 0 ]; then
			rm -fr "$TMP_DIRECTORY"
			return 1
		fi
	else
		mysqlbackup $TARGET_CRED_OPT --read-threads=$READ_THREADS --write-threads=$WRITE_THREADS --process-threads=$PROCESS_THREADS --backup-dir="${TMP_DIRECTORY}" $LIM_MEM_OPT backup-and-apply-log
	fi
	RETCODE=$?
	write_out "===== FINISHED mysqlbackup ====="
	#check_backup_consistency
	if [ $RETCODE -ne 0 ]; then
		rm -fr "${TMP_DIRECTORY}"
		return 1
	fi
	#move tmp directory to permanent dst
	mv "${TMP_DIRECTORY}" "${BASE_BACKUP_DIR}" || return 1
	cd "$BASE_BACKUP_DIR" || return 1
	LAST_BACKUP=`ls | tail -n 1` || return 1
	fix_backup_timestamp $LAST_BACKUP || return 1
}

function help_backup()
{
	echo "* Make backups"
	echo "	backup binlog | full [ ... ]"
	echo "  		binlog: backup binary logs"
	echo "	  	full: backup full database"
}

function help_backup_binlog()
{
	echo "* Make binary log backups"
	echo "	backup binlog"
}

function help_backup_full()
{
	echo "* Make full database backups"
	echo "	backup full [ -d <dir> ]"
	echo "		-d Save backup in <dir>, instead of directory set in configuration"
}

function help_drop()
{
	echo "* Drop data from local server"
	echo "   drop database: drop current database - datafiles, redo, undo, binary logs and relay logs"
}

function help_drop_database()
{
	echo "* Drop current database - datafiles, redo, undo, binary logs and relay logs"
	echo "Syntax: drop database"
}

function help_init()
{
	echo "* Initialize a database"
	echo "   init database | slave ..."
	echo "      database: a new empty database"
	echo "      slave: a slave for a replication environment"
}

function help_init_database
{
	echo "* Initialize a new empty database"
	echo "   init database"
}

function help_restore()
{
	echo "* Restore data from backup"
	echo "   restore config"
	echo "   restore database"
}

function help_restore_config()
{
	echo "* Restore server configuration from backup"
	echo "** Configuration is printed to standard output"
   echo "   restore config [ -o <dir> ] [ -p <timestamp> ]"
   echo "      -o use backup saved in <dir>, and not directory set in configuration"
   echo "      -p restore config in use in <timestmap>"
   echo "         <timestmap>: hhmm | ddhhmm | MMddhhmm | yyyy-MM-dd_hh:mm:ss"
   echo "            hh: hour, mm: minute, dd: day, MM: month, yyyy: year, ss: second"
}

function help_restore_database()
{
	echo "* Restore a database from backup"
   echo "   restore database [ -n ] [ -o <dir> ] [ -p <timestamp> ] [ -s <schema>[:<new name>] ] | [ -t <schema1.table1[:<new name>]> [ -t <schema2.table2[:<new name>] [ ... ] ] ]"
   echo "      -n do not create a new database incarnation"
   echo "      -o use backup saved in <dir>, and not directory set in configuration (also, do not create a new database incarnation)"
   echo "      -p restore until <timestmap>"
   echo "         <timestmap>: hhmm | ddhhmm | MMddhhmm | yyyy-MM-dd_hh:mm:ss"
   echo "            hh: hour, mm: minute, dd: day, MM: month, yyyy: year, ss: second"
   echo "      -s Restore only specific schema (optionally using a new name)"
   echo "      -t Restore only specific table (optionally using a new name)"
   echo "         Multiple -t options are allowed"
}

function help_init_slave
{
	echo "* Initialize a new slave"
	echo "   init slave <host>[:<port>] <username> <dir>"
	echo "      host: master hostname (optional port)"
	echo "      username: replication username created in master"
	echo "      dir: master backup directory"
}

function help_list
{
	echo "* List backups"
	echo "   list [ -r <hostname> ] full"
	echo "      List full backups"
	echo "   list [ -r <hostname> ] binlog"
	echo "      List binlog backups"
	echo
	echo "   OPTIONS:"
	echo "      -r List backups that are saved in remote host <hostname>"
}

function binlog_backup_exists()
{
	if ! [ -d "$BINLOG_BACKUP_DIR" ]; then
		return 1
	fi
	cd "$BINLOG_BACKUP_DIR" || return 1
	LOGSEQ=$1
	LONG_LOGSEQ=`seq -f "%06g" $LOGSEQ $LOGSEQ`
	BINLOG=binlog.${LONG_LOGSEQ}
	if [ -f "${BINLOG}" ]; then
		return 0
	fi
	if [ -f "${BINLOG}.gz" ]; then
		return 0
	fi
	return 1
}

function binlog_exists()
{
	LOGSEQ=$1
	LONG_LOGSEQ=`seq -f "%06g" $LOGSEQ $LOGSEQ`
	FILEPATH="${BINLOG_PREFIX}.$LONG_LOGSEQ"
	if [ -f "$FILEPATH" ]; then
		return 0
	fi
	return 1
}


function check_aux_binaries()
{
	if ! which mysqld >/dev/null 2>&1; then
		echo "Cannot find 'mysqld' in PATH" >&2
		return 1
	fi
	if ! which mysqldump >/dev/null 2>&1; then
		echo "Cannot find 'mysqldump' in PATH" >&2
		return 1
	fi
}

function check_aux_dir_space()
{
	DIR=$1
	BKP_SIZE=`du -s -m "$DIR/datadir" | cut -f 1`
	REQ_SIZE=`expr $BKP_SIZE + 100`
	FREE_SIZE=`df -m $AUX_BASEDIR | tail -n 1 | tr -s ' ' | cut -d ' ' -f 4` || return 1
	if [ $FREE_SIZE -lt $REQ_SIZE ]; then
		echo "Not enough space in $AUX_BASEDIR - a minimum of ${REQ_SIZE}M is required" >&2
		return 1
	fi
}

function check_backup_consistency()
{
	write_out "Checking backup consistency"
	if ! [ -d "$BASE_BACKUP_DIR" ]; then
		return
	fi
	cd "$BASE_BACKUP_DIR" || return 1
	for BKP in `ls`; do
		if [ -d "$BKP" ]; then
			if ! consistent_backup "$BKP"; then
				rm -r "$BKP"
			fi
		fi
	done
}

function check_config()
{
	#LOG_DIR
	#if -l option used, log_dir is required
	if [ -n "$LOG_FILE_BASENAME" -a -z "$LOG_DIR" ]; then
		echo "Configuration variable 'log_dir' is required when log file is defined" >&2
		return 1
	fi

	#LOG_DIR - if defined, must exist
	if [ -n "$LOG_DIR" ]; then
		if ! [ -d "$LOG_DIR" ]; then
			echo "'$LOG_DIR': no such directory" >&2
			return 1
		fi
	fi

	#READ_ONLY - must be 0 or 1
	if [ $READ_ONLY -ne 0 -a $READ_ONLY -ne 1 ]; then
		echo "Configuration 'read_only' must be 0 or 1" >&2
		return 1
	fi

	#READ_THREADS
	if [ $READ_THREADS -lt 1 -o $READ_THREADS -gt $MAX_READ_THREADS ]; then
		echo "Configuration 'read_threads' must be between 1 and $MAX_READ_THREADS" >&2
		return 1
	fi

	#WRITE_THREADS
	if [ $WRITE_THREADS -lt 1 -o $WRITE_THREADS -gt $MAX_WRITE_THREADS ]; then
		echo "Configuration WRITE_THREADS must be between 1 and $MAX_WRITE_THREADS" >&2
		return 1
	fi

	#DB_HOSTNAME and DB_SOCKET cannot both be set mutually
	if [ -n "$DB_HOSTNAME" -a -n "$DB_SOCKET" ]; then
		echo "Configurations DB_HOSTNAME and DB_SOCKET cannot both be set"
		return 1
	fi
}

function check_config_backup()
{
	#BACKUP_DIR
	if [ -z "$BACKUP_DIR" ]; then
		echo "Configuration 'backup_dir' is required" >&2
		return 1
	fi
	if [ ! -d "$BACKUP_DIR" ]; then
		echo "'$BACKUP_DIR': no such directory" >&2
		return 1
	fi

}

function check_config_backup_binlog()
{
	#LOCK_FILE - required
	if [ -z "$LOCK_FILE" ]; then
		echo "Configuration 'lock_file' is required" >&2
		return 1
	fi
}

function check_config_list()
{
	if [ -z "$LIST_REMOTE_HOST" ]; then
		#BACKUP_DIR
		if [ -z "$BACKUP_DIR" ]; then
			echo "Configuration 'backup_dir' is required" >&2
			return 1
		fi
		if [ ! -d "$BACKUP_DIR" ]; then
			echo "'$BACKUP_DIR': no such directory" >&2
			return 1
		fi
	fi
}

function check_depends()
{
	#crudini
	if ! rpm -q crudini >/dev/null 2>&1; then
		write_out "Cannot find package 'crudini'"
		return 1
	fi
}

function check_empty_target_database()
{
	#datadir must be empty
	if ls -d "$DATADIR"/* >/dev/null 2>&1; then
		write_out "Data directory [$DATADIR] must be empty"
		return 1
	fi

	#check there is no binary log
	if [ -n "$BINLOG_PREFIX" ] && ls "$BINLOG_PREFIX"* >/dev/null 2>&1; then
		write_out "No binary logs [${BINLOG_PREFIX}*] might exist"
		return 1
	fi

	#binlog index file must not exist
	if [ -n "$BINLOG_INDEX" -a -f "$BINLOG_INDEX" >/dev/null 2>&1 ]; then
		write_out "Binary log index [$BINLOG_INDEX] must not exist"
		return 1
	fi

	#check there is no relay log
	if [ -n "$RELAY_LOG_PREFIX" ] && ls "$RELAY_LOG_PREFIX"* >/dev/null 2>&1; then
		write_out "No relay logs [${RELAY_LOG_PREFIX}*] might exist"
		return 1
	fi

	#relay log index file must not exist
	if [ -n "$RELAY_LOG_INDEX" -a -f "$RELAY_LOG_INDEX" ]; then
		write_out "Relay log index [$RELAY_LOG_INDEX] must not exist"
		return 1
	fi
}

function check_lock_file()
{
	MAX_WAIT_TIME_MIN=10
	SLEEP_TIME=15

	MAX_WAIT_TIME_SEC=`expr $MAX_WAIT_TIME_MIN \* 60`
	TOT_WAIT_TIME=0

	if [ -n "$LOCK_FILE" ]; then
		while [ -f "$LOCK_FILE" ]; do
			if [ $TOT_WAIT_TIME -ge $MAX_WAIT_TIME_SEC ]; then
				write_out "Timeout reached waiting for another instance"
				return 1
			fi
			write_out "Waiting for another instance - lock file: $LOCK_FILE"
			sleep $SLEEP_TIME
			TOT_WAIT_TIME=`expr $TOT_WAIT_TIME + $SLEEP_TIME`
		done
		touch "$LOCK_FILE" || return 1
	fi
}

function check_purge_binlogs()
{
	if [ -n "$SLAVE_SERVER" -a $USE_AUX_INSTANCE -eq 0 ]; then
		LIMIT_LOG=`get_current_slave_binlog`
	else
		LIMIT_LOG=$1
	fi
	if [ $? -ne 0 ]; then
		write_out "Cannot contact slave server - no binary log will be purged"
		return
	fi
	if [ -z "$LIMIT_LOG" ]; then
		write_out "Cannot retrieve slave server's current slave status - no binary log will be purged"
		return
	fi
	purge_binlogs $LIMIT_LOG || return 1
}

function check_target_instance_config()
{
	START_TIMEOUT=300
	write_out "Checking target instance configuration"

	#pid file
	PID_FILE="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION pid_file 2>/dev/null`"
	#create pid file's folder and set owner
	if [ -n "$PID_FILE" ]; then
		DNAME="`dirname $PID_FILE`" || return 1
		mkdir -p "$DNAME" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DNAME" || return 1
		fi
	fi

	#general log file
	GENERAL_LOG_FILE="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION general_log_file 2>/dev/null`"
	if [ -n "$GENERAL_LOG_FILE" ]; then
		DNAME="`dirname $GENERAL_LOG_FILE`" || return 1
		mkdir -p "$DNAME" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DNAME" || return 1
		fi
	fi

	#create directory for binlog index
	if [ -n "$BINLOG_INDEX" ]; then
		DN="`dirname \"$BINLOG_INDEX\"`"
		mkdir -p "$DN" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DN" || return 1
		fi
	fi

	#create directory for binlogs
	if [ -n "$BINLOG_DIR" ]; then
		mkdir -p "$BINLOG_DIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$BINLOG_DIR" || return 1
		fi
	fi
	
	#create directory for relay log index
	if [ -n "$RELAY_LOG_INDEX" ]; then
		DN="`dirname \"$RELAY_LOG_INDEX\"`"
		mkdir -p "$DN" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DN" || return 1
		fi
	fi

	#create directory for relay logs
	if [ -n "$RELAY_LOG_DIR" ]; then
		mkdir -p "$RELAY_LOG_DIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$RELAY_LOG_DIR" || return 1
		fi
	fi

	#tmp directory
	TMP_DIRECTORY="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION tmpdir 2>/dev/null`"
	if [ -n "$TMP_DIRECTORY" ]; then
		mkdir -p "$TMP_DIRECTORY" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$TMP_DIRECTORY" || return 1
		fi
	fi


	LOG_ERROR="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION log_error 2>/dev/null`"
	if [ -z "$LOG_ERROR" ]; then
		write_out "MySQL configuration mysqld:log_error cannot be empty"
		return 1
	fi
	PID_FILE="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION pid_file 2>/dev/null`"
	if [ -z "$PID_FILE" ]; then
		write_out "MySQL configuration mysqld:pid_file cannot be empty"
		return 1
	fi
	if ! which mysqld >/dev/null 2>&1; then
		write_out "Cannot find 'mysqld' executable file"
		return 1
	fi
	TMP_LOG=`mktemp /tmp/myfreerman.XXXXXX` || return 1
	TMP_CONF=`mktemp /tmp/myfreerman.XXXXXX` || return 1
	grep -v "^audit" "$CONFIG_FILE" >$TMP_CONF || return 1
	if ! mysqld --defaults-group-suffix=$MYSQL_DEFAULT_GROUP_SUFFIX --defaults-file="$TMP_CONF" --initialize >>"$TMP_LOG" 2>&1; then
		write_out "Cannot check target instance configuration. Check server output in '$TMP_LOG' and logs in '$LOG_ERROR'."
		drop_target_database
		rm $TMP_LOG $TMP_CONF
		return 1
	fi
	mysqld --defaults-group-suffix=$MYSQL_DEFAULT_GROUP_SUFFIX --defaults-file="$TMP_CONF" --bind-address=127.0.0.1 &
	PID=$!
	if ! wait_server_start $PID "$TMP_CONF"; then
		write_out "Cannot check target instance configuration. Check server logs in '$LOG_ERROR'."
		drop_target_database
		rm $TMP_LOG $TMP_CONF
		return 1
	fi
	kill_pid "$PID_FILE"
	rm $TMP_LOG $TMP_CONF
	drop_target_database || return 1
}

function confirm_operation()
{
	if [ $ANSWER_YES -eq 1 ]; then
		return 0
	fi
	echo -n "Are you sure? (You must type 'yes' to confirm): "
	read ANSWER
	LANSWER=`echo "$ANSWER" | awk '{print tolower($0)}'`
	if [ "$LANSWER" == "yes" ]; then
		return 0
	fi
	return 1
}

function consistent_backup()
{
	TMP_BKP_DIR="$1"
	TMP_BACKUP_VARS="$TMP_BKP_DIR/meta/backup_variables.txt"
	if ! [ -f "$TMP_BACKUP_VARS" ]; then
		return 1
	fi
	TMP_APPLY_LOG_DONE="`crudini --get \"$TMP_BACKUP_VARS\" backup_variables apply_log_done`" || return 1
	if [ "$TMP_APPLY_LOG_DONE" != "1" ]; then
		return 1
	fi
	return 0
}

function copy_recovered_db()
{
	write_out "Copying recovered database from aux instance"
	mysql $TARGET_CRED_OPT -e "create database if not exists $RESTORE_SCHEMA_NEW_NAME;" >/dev/null || return 1
	mysqldump --socket=$AUX_SOCKET --no-create-db --routines --events --triggers --set-gtid-purged=off $RESTORE_SCHEMA_OLD_NAME | mysql $TARGET_CRED_OPT $RESTORE_SCHEMA_NEW_NAME || return 1
}

function copy_restored_tables()
{
	TARGET_CRED_OPT=`mount_target_credentials_opt "$CONFIG_FILE"`
	write_out "Copying restored tables from aux instance"
	for QT in $RESTORE_TABLE_LIST; do
		if ! echo "$QT" | grep \\. >/dev/null; then
			echo "Invalid table name: '$QT' - table names must be qualified with schema" >&2
			return 1
		fi
		SCHEMA=`echo $QT | cut -d . -f 1`
		TABLE=`echo $QT | cut -d . -f 2`
		ORIG_TABLE=`echo $TABLE | cut -d \: -f 1`
		NEW_TABLE=`echo $TABLE | cut -d \: -f 2`
		if [ -z "$NEW_TABLE" ]; then
			NEW_TABLE=$ORIG_TABLE
		fi
		write_out "    ${QT}"
		mysqldump --defaults-file=$AUX_CONFIG --skip-lock-tables --no-create-db --routines --events --triggers --set-gtid-purged=off $SCHEMA $ORIG_TABLE | \
				sed	-e s/^\\\(drop\ table\ if\ exists\ \\\)\`$ORIG_TABLE\`/\\1\`$NEW_TABLE\`/i \
						-e s/^\\\(create\ table\ \\\)\`$ORIG_TABLE\`/\\1\`$NEW_TABLE\`/i \
						-e s/^\\\(insert\ into\ \\\)\`$ORIG_TABLE\`/\\1\`$NEW_TABLE\`/i \
						-e s/^\\\(lock\ tables\ \\\)\`$ORIG_TABLE\`/\\1\`$NEW_TABLE\`/i \
						-e s/^\\\(.*alter\ table\ \\\)\`$ORIG_TABLE\`/\\1\`$NEW_TABLE\`/i \
						| mysql $TARGET_CRED_OPT $SCHEMA || return 1
	done
}

function create_aux_config()
{
	DIR=$1
	MYSQL_VER=`get_mysql_main_help $DIR` || return 1
	if [ -z "$AUX_BASEDIR" ]; then
		echo "Cannot find 'basedir' in '$CONFIG_FILE'" >&2
		return 1
	fi
	if ! [ -d "$AUX_BASEDIR" ]; then
		echo "'$CONFIG_FILE' is not a directory (or access is denied)" >&2
		return 1
	fi
	TARGET_CRED_OPT=`mount_target_credentials_opt "$CONFIG_FILE"`
	TARGET_BASEDIR=`mysql $TARGET_CRED_OPT -e "show variables like 'basedir'" | tail -n 1 | cut -f 2 -d$'\t'`
	LC_MESSAGES_DIR=`mysql $TARGET_CRED_OPT -e "show variables like 'lc_messages_dir'" | tail -n 1 | cut -f 2 -d$'\t'`
	LOWER_CASE_TABLE_NAMES=`mysql $TARGET_CRED_OPT -e "show variables like 'lower_case_table_names'" | tail -n 1 | cut -f 2 -d$'\t'`
	echo "[$SERVER_INI_SECTION]" >$AUX_CONFIG
	echo "datadir=${AUX_DATADIR}" >>$AUX_CONFIG
	echo "explicit_defaults_for_timestamp=1" >>$AUX_CONFIG
	echo "innodb_buffer_pool_size=10M" >>$AUX_CONFIG
	echo "innodb_data_home_dir="$AUX_DATADIR >>$AUX_CONFIG
	echo "innodb_log_group_home_dir=$AUX_REDODIR" >>$AUX_CONFIG
	echo "innodb_undo_directory=$AUX_UNDODIR" >>$AUX_CONFIG
	echo "lc_messages_dir=$LC_MESSAGES_DIR" >>$AUX_CONFIG
	echo "lc_messages=en_US" >>$AUX_CONFIG
	echo "log_bin=${AUX_BINLOG_PREFIX}" >>$AUX_CONFIG
	echo "log_bin_index=${AUX_BINLOG_INDEX}" >>$AUX_CONFIG
	echo "log_bin_trust_function_creators=on" >>$AUX_CONFIG
	echo "log_error=$AUX_LOG_ERROR" >>$AUX_CONFIG
	echo "log_timestamps=system" >>$AUX_CONFIG
	echo "lower_case_table_names=$LOWER_CASE_TABLE_NAMES" >>$AUX_CONFIG
	echo "max_allowed_packet=100M" >>$AUX_CONFIG
	echo "mysqlx=0" >>$AUX_CONFIG
	echo "pid_file=$AUX_PID_FILE" >>$AUX_CONFIG
	echo "port=$AUX_PORT" >>$AUX_CONFIG
	#relay log (prefix)
	if [ -n "$AUX_RELAY_LOG_PREFIX" ]; then
		echo "relay_log=$AUX_RELAY_LOG_PREFIX" >>$AUX_CONFIG
	fi
	#relay log (index)
	if [ -n "$AUX_RELAY_LOG_INDEX" ]; then
		echo "relay_log_index=$AUX_RELAY_LOG_INDEX" >>$AUX_CONFIG
	fi
	echo "socket=$AUX_SOCKET" >>$AUX_CONFIG
	echo "skip-grant-tables=1" >>$AUX_CONFIG
	echo "user=mysql" >>$AUX_CONFIG

	#copy GTID params to aux config
	ENFORCE_GTID_CONSISTENCY=`mysql $TARGET_CRED_OPT -e "show variables like 'enforce_gtid_consistency'" | tail -n 1 | cut -f 2 -d$'\t'`
	echo "enforce_gtid_consistency=$ENFORCE_GTID_CONSISTENCY" >>$AUX_CONFIG

	GTID_MODE=`mysql $TARGET_CRED_OPT -e "show variables like 'gtid_mode'" | tail -n 1 | cut -f 2 -d$'\t'`
	echo "gtid_mode=$GTID_MODE" >>$AUX_CONFIG

	echo "[mysql]" >>$AUX_CONFIG
	echo "port=$AUX_PORT" >>$AUX_CONFIG
	echo "socket=$AUX_SOCKET" >>$AUX_CONFIG
	echo "[mysqldump]" >>$AUX_CONFIG
	echo "max_allowed_packet=99M" >>$AUX_CONFIG
	echo "port=$AUX_PORT" >>$AUX_CONFIG
	echo "socket=$AUX_SOCKET" >>$AUX_CONFIG

	cat $AUX_CONFIG
}

function create_incarnation()
{
	write_out "Creating new backup incarnation"
	MOMENT=$1
	RESTORE_DIR=$RESTORE_BACKUP_DIR/$MOMENT
	mkdir -p "$RESTORE_DIR" || return 1
	mv "$BACKUP_DIR/base" "$BACKUP_DIR/binlog" "$RESTORE_DIR" || return 1
}

function drop_target_database()
{
	if [ -n "$REDODIR" ]; then
		rm -fr "$REDODIR"/* || return 1
	fi
	if [ -n "$UNDODIR" ]; then
		rm -fr "$UNDODIR"/* || return 1
	fi
	if [ -n "$BINLOG_PREFIX" ]; then
		rm -f "$BINLOG_PREFIX"* || return 1
	fi
	if [ -n "$RELAY_LOG_PREFIX" ]; then
		rm -f "$RELAY_LOG_PREFIX"* || return 1
	fi
	if [ -n "$BINLOG_INDEX" ]; then
		rm -f "$BINLOG_INDEX" || return 1
	fi
	if [ -n "$RELAY_LOG_INDEX" ]; then
		rm -f "$RELAY_LOG_INDEX" || return 1
	fi
	rm -fr "$DATADIR/"* || return 1
}

function expand_logfile_path()
{
	date "+$1"
}

function expand_timestamp()
{
	TS=$1
	if [ ${#TS} -eq 4 ]; then
		H=${TS:0:2}
		M=${TS:2:2}
		date +%Y-%m-%d_${H}:${M}:00 || return 1
		return
	fi
	if [ ${#TS} -eq 6 ]; then
		D=${TS:0:2}
		H=${TS:2:2}
		M=${TS:4:2}
		date +%Y-%m-${D}_${H}:${M}:00 || return 1
		return
	fi
	if [ ${#TS} -eq 8 ]; then
		MON=${TS:0:2}
		D=${TS:2:2}
		H=${TS:4:2}
		MIN=${TS:6:2}
		date +%Y-${MON}-${D}_${H}:${MIN}:00 || return 1
		return
	fi
	echo $TS
}

function exist_base_backup()
{
	if ! [ -d $BASE_BACKUP_DIR ]; then
		return 1
	fi
	COUNT=`ls $BASE_BACKUP_DIR | wc -l`
	if [ $COUNT -eq 0 ]; then
		return 1
	fi
	return 0
}

function fix_timestamps()
{
	cd $BASE_BACKUP_DIR || return 1
	for BACKUP in *; do
		fix_backup_timestamp $BACKUP || return 1
	done
}

function find_aux_port()
{
	FIRST_PORT=10000
	LAST_PORT=19999
	RANGE=`expr $LAST_PORT - $FIRST_PORT`
	while true; do
		PORT=$RANDOM
		let "PORT %= $RANGE"
		PORT=`expr $PORT + $FIRST_PORT`
		if port_available $PORT; then
			echo $PORT
			return
		fi
	done
}

function find_base_backup()
{
	[ -d "$BASE_BACKUP_DIR" ] || { echo "No backup found" >&2 && return 1; }
	REQ_TIMESTAMP=`date --date="$1" +%Y%m%d%H%M%S` || return 1
	if [ -z "$REQ_TIMESTAMP" ]; then
		return 1
	fi
	for BKP in `ls -r "$BASE_BACKUP_DIR" | cut -d . -f 1`; do
		DATE=${BKP:0:10}
		TIME=${BKP:11:8}
		TIME=${TIME//-/:}
		BKP_FMT_TS="$DATE $TIME"
		BKP_TIMESTAMP=`date --date="$BKP_FMT_TS" +%Y%m%d%H%M%S`
		if [ $BKP_TIMESTAMP -le $REQ_TIMESTAMP ]; then
			echo $BKP
			return
		fi
	done
	echo "No backup found" >&2
	return 1
}

function fix_backup_timestamp()
{
	BACKUP=$1
	cd $BASE_BACKUP_DIR || return 1
	LOGSEQ=`get_base_backup_binlog_sequence $BACKUP` || return 1
	POSITION=`get_base_backup_binlog_position $BACKUP` || return 1
	BINLOG=`get_binlog_path $LOGSEQ` || return 1
	NEWNAME=`get_binlog_transaction_timestamp $BINLOG $POSITION` || return 1
	if [ "$BACKUP" != "$NEWNAME" ]; then
		if [ -d ${BACKUP} ]; then
			mv $BACKUP $NEWNAME || return 1
		fi
	fi
}

function get_base_backup_binlog_name()
{
	BACKUP=$1
	grep -w "binlog_position" $BASE_BACKUP_DIR/$BACKUP/meta/backup_variables.txt | cut -d '=' -f 2 | cut -d ':' -f 1 || return 1
}

function get_base_backup_binlog_sequence()
{
	BACKUP=$1
	BINLOG=`get_base_backup_binlog_name $BACKUP`
	get_binlog_sequence $BINLOG || return 1
}

function get_base_backup_binlog_position()
{
	BACKUP=$1
	grep -w "binlog_position" $BASE_BACKUP_DIR/$BACKUP/meta/backup_variables.txt | cut -d '=' -f 2 | cut -d ':' -f 2 || return 1
}

function get_binlog_path()
{
	LOGSEQ=$1
	LONG_LOGSEQ=`seq -f "%06g" $LOGSEQ $LOGSEQ`
	BINLOG=binlog.$LONG_LOGSEQ

	#search in backup
	if [ -f "$BINLOG_BACKUP_DIR/$BINLOG" ]; then
		echo "$BINLOG_BACKUP_DIR/$BINLOG"
		return
	fi

	#search in backup (compressed)
	if [ -f "$BINLOG_BACKUP_DIR/$BINLOG.gz" ]; then
		echo "$BINLOG_BACKUP_DIR/$BINLOG.gz"
		return
	fi

	#search in server repository
	if [ -f "${BINLOG_PREFIX}.$LONG_LOGSEQ" ]; then
		echo "${BINLOG_PREFIX}.$LONG_LOGSEQ"
		return
	fi

	echo "Cannot find binary log $LOGSEQ anywhere" >&2
	return 1
}

function get_binlog_sequence()
{
	BINLOG=$1
	LONG_LOGSEQ=`echo $BINLOG | cut -d . -f 2`
	expr $LONG_LOGSEQ + 0
}

function get_binlog_transaction_timestamp()
{
	BINLOG=$1
	POSITION=$2

	PLAIN_BINLOG=/$BINLOG
	TMP_BINLOG=
	if file $PLAIN_BINLOG | grep -w gzip >/dev/null; then
		TMP_BINLOG=`mktemp /tmp/myfreerman.XXXXXX` || return 1
		PLAIN_BINLOG=$TMP_BINLOG
		gunzip -c $BINLOG >$PLAIN_BINLOG
	fi
	TMP_SQL=`mktemp /tmp/myfreerman.XXXXXX` || return 1
	mysqlbinlog $PLAIN_BINLOG >$TMP_SQL || return 1
	if [ -n "$TMP_BINLOG" ]; then
		rm $TMP_BINLOG
	fi
	LINE=`grep "^#.*end_log_pos $POSITION" $TMP_SQL` || return 1
	rm $TMP_SQL
	TIMESTAMP="${LINE:1:15}"
	date -d"$TIMESTAMP" +%Y-%m-%d_%H-%M-%S
}

function get_mysql_main_help()
{
	BACKUP=$1
	grep -w "mysql_main_help" $BASE_BACKUP_DIR/$BACKUP/meta/backup_variables.txt | cut -d '=' -f 2 | cut -d '.' -f 1 || return 1
}

function get_oldest_full_backup()
{
	cd "$BACKUP_DIR" || return 1
	mkdir -p "$BASE_BACKUP_DIR" || return 1
	cd "$BASE_BACKUP_DIR" || return 1
	ls | head -n 1
}

function get_current_slave_binlog()
{
	MIN_LOG=999999
	SLAVE_SERVERS=`echo $SLAVE_SERVER | tr "," "\n"`
	for S in $SLAVE_SERVERS; do
		SLAVE_HOSTNAME=`echo $S | cut -d \: -f 1`
		SLAVE_PORT=`echo $S | cut -d \: -f 2`
		if [ -z  "$SLAVE_PORT" ]; then
			SLAVE_PORT=3306
		fi
		SLAVE_CRED_OPT=`mount_slave_credentials_opt`

#before getting slave status, check if we can reach it
		RESULT=1
		if mysqladmin $SLAVE_CRED_OPT status >/dev/null; then
			CUR_LOG=`mysql $SLAVE_CRED_OPT -e "show slave status\G" | grep Relay_Master_Log_File | cut -d :  -f 2 | sed -e 's/ //'`
			if [ $? -ne 0 ]; then
				return $?
			fi
			CUR_LOG=`echo $CUR_LOG | cut -d . -f 2`
			if [ -z "$CUR_LOG" ]; then
				return 1
			fi
			CUR_LOG=`expr $CUR_LOG + 0`
			if [ $CUR_LOG -lt $MIN_LOG ]; then
				MIN_LOG=$CUR_LOG
			fi
		else
			return 1
		fi
	done

	#decrement one, because sometimes it looses sync and master purges an unapplied binlog
	MIN_LOG=$((MIN_LOG-1))

	LONG_LOGSEQ=`seq -f "%06g" $MIN_LOG $MIN_LOG`
	echo ${BINLOG_BNAME}.${LONG_LOGSEQ}
	return 0
}

function header()
{
	write_out "myfreerman - Free Recovery Manager for MySQL - Release $RELEASE - Host $MYHOST"
}

function kill_pid()
{
	WAIT_TIMEOUT=45
	PID_FILE="$1"
	PID=`cat "$PID_FILE"`
	kill $PID
	sleep 1
	COUNT=1
	while kill -0 $PID 2>/dev/null; do
		COUNT=$((COUNT + 1))
		if [ $COUNT -ge $WAIT_TIMEOUT ]; then
			return 1
		fi
		sleep 1
	done
}

function drop()
{
	local OPTIND l_opt
	while getopts "h" l_opt; do
		case $l_opt in
			h)
				help_drop
				return
				;;
			\?)
				help_drop
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if [ $# -lt 1 ]; then
		help_drop
		return 1
	fi
	CMD=$1
	shift
	case $CMD in
		database)
			drop_database $* || return 1
			;;
		*)
			echo "Invalid drop command: $CMD" >&2
			help_drop
			return 1
			;;
	esac
}

function drop_database()
{
	local OPTIND l_opt
	while getopts "h" l_opt; do
		case $l_opt in
			h)
				help_drop_database
				return
				;;
			\?)
				help_drop_database
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if [ $# -gt 0 ]; then
		help_drop_database
		return 1
	fi
	PID_FILE="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION pid_file 2>/dev/null`"
	if [ -f "$PID_FILE" ]; then
		PID=`cat "$PID_FILE"`
		if kill -0 $PID; then
			write_out "Server is running - cannot drop database"
			return 1
		fi
	fi
	if ! confirm_operation; then
		return 1
	fi
	write_out "Dropping database"

	#datadir
	DATADIR="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION datadir`" 2>/dev/null
	if [ "$DATADIR" == "/" ]; then
		write_out "Invalid data directory (datadir)"
		return 1
	fi
	if [ -n "$DATADIR" ]; then
		rm -fr "$DATADIR/"* || return 1
	fi

	#redo
	REDODIR="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION innodb_log_group_home_dir 2>/dev/null`"
	if [ "$REDODIR" == "/" ]; then
		write_out "Invalid redo directory"
		return 1
	fi
	if [ -n "$REDODIR" ]; then
		rm -fr "$REDODIR/"* || return 1
	fi

	#undo
	UNDODIR="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION innodb_undo_directory 2>/dev/null`"
	if [ "$UNDODIR" == "/" ]; then
		write_out "Invalid undo directory"
		return 1
	fi
	if [ -n "$UNDODIR" ]; then
		rm -fr "$UNDODIR/"* || return 1
	fi

	#binlog index file
	BINLOG_INDEX="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION log_bin_index 2>/dev/null`"
	if [ -n "$BINLOG_INDEX" ]; then
		rm -f "$BINLOG_INDEX" || return 1
	fi

	#relay index file
	RELAY_LOG_INDEX="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION relay_log_index 2>/dev/null`"
	if [ -n "$RELAY_LOG_INDEX" ]; then
		rm -f "$RELAY_LOG_INDEX" || return 1
	fi

	#binlogs directory
	BINLOG_PREFIX="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION log_bin 2>/dev/null`"
	if [ -n "$BINLOG_PREFIX" ]; then
		rm -f "${BINLOG_PREFIX}"* || return 1
	fi

	#relay logs directory
	RELAY_LOG_PREFIX="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION relay_log 2>/dev/null`"
	if [ -n "$RELAY_LOG_PREFIX" ]; then
		rm -f "${RELAY_LOG_PREFIX}"* || return 1
	fi
}

function init()
{
	local OPTIND l_opt
	while getopts "h" l_opt; do
		case $l_opt in
			h)
				help_init
				return
				;;
			\?)
				help_init
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if [ $# -eq 0 ]; then
		help_init
		return 1
	fi

	CMD=$1
	shift
	case $CMD in
		database)
			init_database $* || return 1
			;;
		slave)
			init_slave $* || return 1
			;;
		*)
			help_init
			return 1
			;;
	esac
}

function init_database()
{
	local OPTIND l_opt
	while getopts "h" l_opt; do
		case $l_opt in
			h)
				help_init_database
				return
				;;
			\?)
				help_init_database
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))

	if [ $# -ne 0 ]; then
		help_init_database
		return 1
	fi

	#error log is required
	LOG_ERROR="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION log_error 2>/dev/null`"
	if [ -z "$LOG_ERROR" ]; then
		write_out "Configuration 'log_error' in server configuration is required"
		return 1
	fi

	#mysqld user
	MYSQLD_USER="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION user 2>/dev/null`"

	#create log error file
	DNAME="`dirname $LOG_ERROR`" || return 1
	mkdir -p "$DNAME" || return 1
	if [ -n "$MYSQLD_USER" ]; then
		chown $MYSQLD_USER "$DNAME" || return 1
	fi
	touch "$LOG_ERROR" || return 1
	if [ -n "$MYSQLD_USER" ]; then
		chown $MYSQLD_USER "$LOG_ERROR" || return 1
	fi

	#datadir
	DATADIR="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION datadir`" 2>/dev/null
	if [ -n "$DATADIR" ]; then
		mkdir -p "$DATADIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DATADIR" || return 1
		fi
	fi

	#redo
	REDODIR="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION innodb_log_group_home_dir 2>/dev/null`"
	if [ -n "$REDODIR" ]; then
		mkdir -p "$REDODIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$REDODIR" || return 1
		fi
	fi

	#undo
	UNDODIR="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION innodb_undo_directory 2>/dev/null`"
	if [ -n "$UNDODIR" ]; then
		mkdir -p "$UNDODIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$UNDODIR" || return 1
		fi
	fi

	#binlog index file
	BINLOG_INDEX="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION log_bin_index 2>/dev/null`"
	if [ -n "$BINLOG_INDEX" ]; then
		DNAME="`dirname $BINLOG_INDEX`" || return 1
		mkdir -p "$DNAME" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DNAME" || return 1
		fi
	fi

	#relay index file
	RELAY_LOG_INDEX="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION relay_log_index 2>/dev/null`"
	if [ -n "$RELAY_LOG_INDEX" ]; then
		DNAME="`dirname $RELAY_LOG_INDEX`" || return 1
		mkdir -p "$DNAME" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DNAME" || return 1
		fi
	fi

	#binlogs directory
	BINLOG_PREFIX="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION log_bin 2>/dev/null`"
	if [ -n "$BINLOG_PREFIX" ]; then
		BINLOG_DIR="`dirname $BINLOG_PREFIX`" || return 1
		BINLOG_BNAME="`basename $BINLOG_PREFIX`" || return 1
		mkdir -p "$BINLOG_DIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$BINLOG_DIR" || return 1
		fi
	fi

	#relay logs directory
	RELAY_LOG_PREFIX="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION relay_log 2>/dev/null`"
	if [ -n "$RELAY_LOG_PREFIX" ]; then
		RELAY_LOG_DIR="`dirname $RELAY_LOG_PREFIX`" || return 1
		mkdir -p "$RELAY_LOG_DIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$RELAY_LOG_DIR" || return 1
		fi
	fi

	#secure files directory
	SECURE_DIR="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION secure_file_priv 2>/dev/null`"
	if [ -n "$SECURE_DIR" ]; then
		mkdir -p "$SECURE_DIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$SECURE_DIR" || return 1
			chmod 700 "$SECURE_DIR" || return 1
		fi
	fi

	#tmp directory
	TMP_DIRECTORY="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION tmpdir 2>/dev/null`"
	if [ -n "$TMP_DIRECTORY" ]; then
		mkdir -p "$TMP_DIRECTORY" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$TMP_DIRECTORY" || return 1
		fi
	fi

	#slow query log file
	SLOW_QUERY_LOG_FILE="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION slow_query_log_file 2>/dev/null`"
	if [ -n "$SLOW_QUERY_LOG_FILE" ]; then
		DNAME="`dirname $SLOW_QUERY_LOG_FILE`" || return 1
		mkdir -p "$DNAME" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DNAME" || return 1
		fi
	fi

	#general log file
	GENERAL_LOG_FILE="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION general_log_file 2>/dev/null`"
	if [ -n "$GENERAL_LOG_FILE" ]; then
		DNAME="`dirname $GENERAL_LOG_FILE`" || return 1
		mkdir -p "$DNAME" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DNAME" || return 1
		fi
	fi

	#server socket
	SERVER_SOCKET="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION socket 2>/dev/null`"
	#create socket's folder and set owner
	if [ -n "$SERVER_SOCKET" ]; then
		DNAME="`dirname $SERVER_SOCKET`" || return 1
		mkdir -p "$DNAME" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DNAME" || return 1
		fi
	fi

	#pid file
	PID_FILE="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION pid_file 2>/dev/null`"
	#create pid file's folder and set owner
	if [ -n "$PID_FILE" ]; then
		DNAME="`dirname $PID_FILE`" || return 1
		mkdir -p "$DNAME" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DNAME" || return 1
		fi
	fi

	echo -n "Please enter initial password for root: "
	read NEW_PASSWORD

	#run initialize
	write_out "Creating server repository"
	if ! mysqld --defaults-group-suffix=$MYSQL_DEFAULT_GROUP_SUFFIX --defaults-file="$CONFIG_FILE" --initialize; then
		write_out "Cannot create server repository. Please check mysql log at '$LOG_ERROR'."
		return 1
	fi
	LINE=`grep -w password "$LOG_ERROR" | tail -n 1`
	PASSWORD=`echo ${LINE##* }`

	mysql_start "$CONFIG_FILE" "init" || return 1

	write_out "Running initial config commands"
	#create tmp file with commands
	SQL=`mktemp /tmp/myfreerman.XXXXXX`
	echo "alter user root@localhost identified by '$NEW_PASSWORD';" >>$SQL
	echo "update mysql.user set host = '%' where user = 'root' and host = 'localhost';" >>$SQL
	echo "flush privileges;" >>$SQL
	echo "grant backup_admin on *.* to root;" >>$SQL
	TARGET_CRED_OPT=`mount_target_credentials_opt "$CONFIG_FILE"` || return 1
	mysql --connect-expired-password --socket="$SERVER_SOCKET" -u root "-p$PASSWORD" <$SQL
	mysql_stop "$CONFIG_FILE" "init"
	rm $SQL
}

function init_slave()
{
	local OPTIND l_opt
	while getopts "h" l_opt; do
		case $l_opt in
			h)
				help_init_slave
				return
				;;
			\?)
				help_init_slave
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))

	if [ $# -ne 3 ]; then
		help_init_slave
		return 1
	fi

	MASTER_HOST=$1
	MASTER_PORT=`echo $MASTER_HOST | cut -s -d \: -f 2`
	if [ -z "$MASTER_PORT" ]; then
		MASTER_PORT=3306
	else
		MASTER_HOST=`echo $MASTER_HOST | cut -s -d \: -f 1`
	fi
	REPL_USERNAME=$2
	BACKUP_DIRECTORY="$3"

	read -s -p "Replication user password: " REPL_PASSWD
	if [ -z "$REPL_PASSWD" ]; then
		return 1
	fi

	if ! mysqladmin -h $MASTER_HOST -P $MASTER_PORT -u $REPL_USERNAME -p"${REPL_PASSWD}" status >/dev/null; then
		return 1
	fi
	ANSWER_YES=1
	SLAVE=1
	restore -n -o "$BACKUP_DIRECTORY" || exit 1

	#start server
	mysql_start "$CONFIG_FILE" slave || return 1

	#query binlog info at the time of the backup
	TARGET_CRED_OPT=`mount_target_credentials_opt` || return 1

	#mount command to config slave
	CMD="change master to master_host='$MASTER_HOST', master_port=$MASTER_PORT, master_auto_position=1, master_ssl=1, master_user='$REPL_USERNAME', master_password='$REPL_PASSWD'";
	write_out "Setting new slave configuration"
	if ! mysql $TARGET_CRED_OPT -e "$CMD"; then
		mysql_stop "$CONFIG_FILE" slave || return 1
		return 1
	fi
	if ! mysql $TARGET_CRED_OPT -e "start slave"; then
		mysql_stop "$CONFIG_FILE" slave || return 1
		return 1
	fi
	sleep 1
	mysql $TARGET_CRED_OPT -e "show slave status\G" | grep -E "Slave_SQL_Running_State|Last_IO_Error"
	mysql_stop "$CONFIG_FILE" slave || return 1
}

function list()
{
	LIST_REMOTE_HOST=
	local OPTIND l_opt
	while getopts "hr:" l_opt; do
		case $l_opt in
			h)
				help_list
				return
				;;
			r)
				LIST_REMOTE_HOST=${OPTARG}
				;;
			\?)
				help_list
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if [ $# -lt 1 ]; then
		help_list
		return 1
	fi
	CMD=$1
	check_config_list || return 1
	if [ -n "$LIST_REMOTE_HOST" ]; then
		list_remote $CMD || return 1
		return
	fi
	case $CMD in
		full)
			list_full || return 1
			;;
		binlog)
			list_binlog || return 1
			;;
		*)
			help_list
			return 1
			;;
	esac
}

function list_binlog()
{
	BINLOG_BACKUP_DIR="$BACKUP_DIR/binlog"
	mkdir -p "$BINLOG_BACKUP_DIR" || return 1
	echo -e SEQUENCE '\t' DATE '\t\t' TIME
	echo "-----------------------------------------"
	LIST=`ls "$BINLOG_BACKUP_DIR"`
	for F in $LIST; do
		FULL="${BINLOG_BACKUP_DIR}/${F}"
		BINLOG=`echo $F | cut -d . -f 2`
		LOGSEQ=`expr $BINLOG + 0`
		BKP_FMT_TS="`stat -c %y "$FULL" | cut -d . -f 1`"
		DATE=${BKP_FMT_TS:0:10}
		TIME=${BKP_FMT_TS:11:8}
		echo -e $LOGSEQ '\t\t' $DATE '\t' $TIME
	done
}

function list_binlog_remote()
{
	ssh -q -o "StrictHostKeyChecking=no" $LIST_REMOTE_HOST MYSQL_SID=$MYSQL_SID myfreerman -q list binlog
}

function list_full()
{
	BASE_BACKUP_DIR="$BACKUP_DIR/base"
	mkdir -p "$BASE_BACKUP_DIR" || return 1
	echo -e DATE '\t\t' TIME
	echo "-------------------------"
	LIST=`ls "$BASE_BACKUP_DIR"`
	for BKP in $LIST; do
		DATE=${BKP:0:10}
		TIME=${BKP:11:8}
		TIME=${TIME//-/:}
		echo -e $DATE '\t' $TIME
	done
}

function list_full_remote()
{
	ssh -q -o "StrictHostKeyChecking=no" $LIST_REMOTE_HOST MYSQL_SID=$MYSQL_SID myfreerman -q list full
}

function list_remote()
{
	REMOTE_USER=`whoami`
	REMOTE_INST=`echo $REMOTE_HOST | cut -d . -f 1`
	CONFIG_FILE=/etc/my.cnf
	CMD=$1
	case $CMD in
		full)
			list_full_remote || return 1
			;;
		binlog)
			list_binlog_remote || return 1
			;;
		*)
			main_help
			return 1
			;;
	esac
}

function mount_credentials_opt()
{
	RESULT=
	if [ -n "$DB_HOSTNAME" ]; then
		RESULT="$RESULT --host=$DB_HOSTNAME"
	fi
	if [ -n "$DB_USERNAME" ]; then
		RESULT="$RESULT --user=$DB_USERNAME"
	fi
	if [ $USE_AUX_INSTANCE -eq 1 ]; then
		return
	fi
	if [ -n "$DB_PASSWORD" ]; then
		if [ -n "$RESULT" ]; then
			RESULT="$RESULT"
		fi
		RESULT="${RESULT}--password=$DB_PASSWORD"
	fi
	echo -n "$RESULT"
}

function mount_limit_memory_option()
{
	if [ -n "$MAX_MEM" ]; then
		echo "--limit-memory=$MAX_MEM"
	fi
}

function mount_slave_credentials_opt()
{
	RESULT=
	RESULT="--host=$SLAVE_HOSTNAME --port=$SLAVE_PORT"
	if [ -n "$DB_USERNAME" ]; then
		RESULT="$RESULT --user=$DB_USERNAME"
	fi
	if [ -n "$DB_PASSWORD" ]; then
		RESULT="$RESULT --password=$DB_PASSWORD"
	fi
	echo -n "$RESULT"
}

function mount_target_credentials_opt()
{
	RESULT=
	if [ -n "$DB_SOCKET" ]; then
		RESULT="$RESULT --socket=$DB_SOCKET"
	fi
	if [ -n "$DB_HOSTNAME" ]; then
		RESULT="$RESULT --host=$DB_HOSTNAME"
	fi
	if [ -n "$DB_USERNAME" ]; then
		RESULT="$RESULT --user=$DB_USERNAME"
	fi
	if [ -n "$DB_PASSWORD" ]; then
		RESULT="$RESULT --password=$DB_PASSWORD"
	fi
	echo -n "$RESULT"
}

function mount_aux_defaults_file_opt()
{
	if [ $USE_AUX_INSTANCE -eq 1 ]; then
		echo "--defaults-file=$AUX_CONFIG"
	fi
}

function mysql_start()
{
	CONFIG="$1"
	INST_TYPE="$2"
	START_TIMEOUT=300
	LOG_ERROR="`crudini --get \"$CONFIG\" $SERVER_INI_SECTION log_error 2>/dev/null`"
	CMD="mysqld"
	OPTS="--defaults-group-suffix=$MYSQL_DEFAULT_GROUP_SUFFIX --defaults-file=$CONFIG --bind-address=127.0.0.1 --console --super-read-only=off --skip-grant-tables"
	write_out "Starting server (${INST_TYPE})"
	$CMD $OPTS >"$LOG_ERROR" 2>&1 &
	PID=$!
	sleep 5
	COUNT=5
	while [ $COUNT -lt $START_TIMEOUT ]; do
		if tail -n 20 "$LOG_ERROR" | grep -iw "ready for connections" >/dev/null; then
			return 0
		fi
		if ! kill -0 $PID 2>/dev/null; then
			write_out "Cannot start server - check logs in '$LOG_ERROR'"
			return 1
		fi
		sleep 1
		COUNT=$((COUNT + 1))
	done
	write_out "Timeout reached waiting for server to start. Please check server logs in '$LOG_ERROR'"
	return 1
}

function mysql_stop()
{
	CONFIG="$1"
	INST_TYPE="$2"
	STOP_TIMEOUT=300
	PID_FILE="`crudini --get \"$CONFIG\" $SERVER_INI_SECTION pid_file 2>/dev/null`"
	LOG_ERROR="`crudini --get \"$CONFIG\" $SERVER_INI_SECTION log_error 2>/dev/null`"
	write_out "Stopping server (${INST_TYPE})"
	PID=`cat "$PID_FILE"`
	kill $PID
	sleep 1
	COUNT=1
	while [ $COUNT -lt $STOP_TIMEOUT ]; do
		if ! kill -0 $PID 2>/dev/null; then
			return 0
		fi
		sleep 1
		COUNT=`expr $COUNT + 1`
	done
	write_out "Timeout reached waiting server to stop. Check server logs [${LOG_ERROR}]."
	return 1
}

function port_available()
{
	PORT=$1
	if netstat -an | grep -w $PORT >/dev/null; then
		return 1
	fi
	return 0
}

function purge_binlogs()
{
	LIMIT_LOG=$1
	write_out "Purging binary logs (limit: $LIMIT_LOG)"
	TARGET_CRED_OPT=`mount_target_credentials_opt "$CONFIG_FILE"` || return 1
	mysql --defaults-file="$CONFIG_FILE" $TARGET_CRED_OPT -e "purge binary logs to '$LIMIT_LOG';" >/dev/null || return 1
}

function query()
{
	CMD=`echo $1 | awk '{print tolower($0)}'`
	shift
	case $CMD in
		backup_age)
			query_backup_age || return 1
			;;
		*)
			main_help
			;;
	esac
}

function query_backup_age()
{
	FULL=`query_full_backup_age` || return 1
	BINLOG=`query_binlog_backup_age` || return 1
	echo "FULL|$FULL"
	echo "BINLOG|$BINLOG"
}

function query_binlog_backup_age()
{
	cd $BINLOG_BACKUP_DIR || return 1
	LAST_FILE=`ls -tr | tail -n 1`
	DATE=${BKP:0:10}
	TIME=${BKP:11:8}
	TIME=${TIME//-/:}
	BKP_FMT_TS="`stat -c %y $LAST_FILE | cut -d . -f 1`"
	BKP_TS_EPOCH=`date -d "$BKP_FMT_TS" +%s`
	DIFF=`expr $NOW_EPOCH - $BKP_TS_EPOCH`
	RESULT=`echo "scale = 2; $DIFF / 3600" | bc`
	echo $RESULT
}

function query_full_backup_age()
{
	cd "$BASE_BACKUP_DIR" || return 1
	BKP=`ls | tail -n 1`
	DATE=${BKP:0:10}
	TIME=${BKP:11:8}
	TIME=${TIME//-/:}
	BKP_FMT_TS="$DATE $TIME"
	BKP_TS_EPOCH=`date -d "$BKP_FMT_TS" +%s`
	DIFF=`expr $NOW_EPOCH - $BKP_TS_EPOCH`
	RESULT=`echo "scale = 2; $DIFF / 3600 / 24" | bc`
	echo $RESULT
}

function read_binlog()
{
	LOGSEQ=$1
	POSITION=$2
	STOP_DATETIME_OPT="--stop-datetime=$3"
	SQL_DEST=$4
	RECOVER_DB=
	if [ $# -ge 5 ]; then
		RECOVER_DB=$5
	fi
	POSITION_OPTION=
	if [ $POSITION -ne 0 ]; then
		POSITION_OPTION="--start-position=$POSITION"
	fi
	BINLOG=`get_binlog_path $LOGSEQ`
	PLAIN_BINLOG=$BINLOG
	TMP_BINLOG=
	if file $PLAIN_BINLOG | grep -w gzip >/dev/null; then
		TMP_BINLOG=`mktemp /tmp/myfreerman.XXXXXX`
		PLAIN_BINLOG=$TMP_BINLOG
		gunzip -c $BINLOG >$PLAIN_BINLOG || return 1
	fi
	DB_OPTION=
	if [ -n "$RECOVER_DB" ]; then
		DB_OPTION="--database=$RECOVER_DB"
	fi
	mysqlbinlog $DB_OPTION "$STOP_DATETIME_OPT" $POSITION_OPTION $PLAIN_BINLOG >>$SQL_DEST || return 1
	if [ -n "$TMP_BINLOG" ]; then
		rm $TMP_BINLOG
	fi
}

function read_config()
{
	#mount ini section
	INI_SECTION=myfreerman
	if [ -n "$MYSQL_SID" ]; then
		INI_SECTION=${INI_SECTION}@${MYSQL_SID}
	fi

	#config file is not required
	#for example, in clusters with vip, oem agent runs on a third host
	#and it must list backups remotely - no configuration required in target host
	if ! [ -f "$CONFIG_FILE" ]; then
		return
	fi

	BACKUP_DIR="`crudini --get "$CONFIG_FILE" $INI_SECTION backup_dir 2>/dev/null`"

	AUX_BASEDIR="`crudini --get "$CONFIG_FILE" $INI_SECTION aux_basedir 2>/dev/null`"

	DB_SOCKET="`crudini --get "$CONFIG_FILE" $INI_SECTION db_socket 2>/dev/null`"
	DB_HOSTNAME="`crudini --get "$CONFIG_FILE" $INI_SECTION db_hostname 2>/dev/null`"
	DB_PASSWORD="`crudini --get "$CONFIG_FILE" $INI_SECTION db_password 2>/dev/null`"
	DB_USERNAME="`crudini --get "$CONFIG_FILE" $INI_SECTION db_username 2>/dev/null`"

	#log directory
	LOG_DIR="`crudini --get "$CONFIG_FILE" $INI_SECTION log_dir 2>/dev/null`"

	#lock file
	LOCK_FILE="`crudini --get "$CONFIG_FILE" $INI_SECTION lock_file 2>/dev/null`"

	#max memory
	MAX_MEM="`crudini --get "$CONFIG_FILE" $INI_SECTION max_mem 2>/dev/null`"

	#read only
	READ_ONLY="`crudini --get "$CONFIG_FILE" $INI_SECTION read_only 2>/dev/null`"
	#default: 0
	if [ -z "${READ_ONLY}" ]; then
		READ_ONLY=0
	fi

	#process threads
	PROCESS_THREADS="`crudini --get "$CONFIG_FILE" $INI_SECTION process_threads 2>/dev/null`"
	#default: 1
	if [ -z "$PROCESS_THREADS" ]; then
		PROCESS_THREADS=1
	fi

	#read threads
	READ_THREADS="`crudini --get "$CONFIG_FILE" $INI_SECTION read_threads 2>/dev/null`"
	#default: 1
	if [ -z "$READ_THREADS" ]; then
		READ_THREADS=1
	fi

	#slave server
	SLAVE_SERVER="`crudini --get "$CONFIG_FILE" $INI_SECTION slave_server 2>/dev/null`"

	#write threads
	WRITE_THREADS="`crudini --get "$CONFIG_FILE" $INI_SECTION write_threads 2>/dev/null`"
	#default: 1
	if [ -z "$WRITE_THREADS" ]; then
		WRITE_THREADS=1
	fi

	check_config || return 1
}

function recover()
{
	BASE_BACKUP=$1
	REQ_TIMESTAMP="$2"
	MY_REQ_TIMESTAMP="${REQ_TIMESTAMP/_/ }"
	CONFIG="$3"
	SOCKET="$4"
	TMP_SQL=`mktemp /tmp/myfreerman.XXXXXX`
	LOGSEQ=`get_base_backup_binlog_sequence $BASE_BACKUP`
	POSITION=`get_base_backup_binlog_position $BASE_BACKUP`
	ITYPE="restricted"
	if [ $USE_AUX_INSTANCE -eq 1 ]; then
		ITYPE="aux"
	fi
	if ! mysql_start "$CONFIG" $ITYPE; then
		if [ $USE_AUX_INSTANCE -eq 1 ]; then
			rm -fr "$AUX_BASEDIR"
		fi
		return 1
	fi
	while binlog_backup_exists $LOGSEQ; do
		rm $TMP_SQL || return 1
		touch $TMP_SQL || return 1
		write_out "Applying binary log sequence $LOGSEQ"
		read_binlog $LOGSEQ $POSITION "$MY_REQ_TIMESTAMP" $TMP_SQL || return 1
		if ! apply_binlog $TMP_SQL "$SOCKET"; then
			mysql_stop "$CONFIG" $ITYPE
			return 1
		fi
		LOGSEQ=`expr $LOGSEQ + 1`
		POSITION=0
	done
	if [ $USE_AUX_INSTANCE -eq 1 ]; then
		while binlog_exists $LOGSEQ; do
			rm $TMP_SQL || return 1
			touch $TMP_SQL || return 1
			write_out "Applying binary log sequence $LOGSEQ"
			read_binlog $LOGSEQ 0 "$MY_REQ_TIMESTAMP" $TMP_SQL || return 1
			if ! apply_binlog $TMP_SQL "$SOCKET"; then
				mysql_stop "$CONFIG" $ITYPE
				return 1
			fi
			LOGSEQ=`expr $LOGSEQ + 1`
		done
	fi
	rm $TMP_SQL
}

function remove_lock_file()
{
	if [ -n "$LOCK_FILE" ]; then
		rm -f "$LOCK_FILE"
	fi
}

function remove_expired_backups()
{
	if ! confirm_operation; then
		return 1
	fi
	#retention period
	RETENTION_PERIOD="`crudini --get "$CONFIG_FILE" $INI_SECTION retention_period 2>/dev/null`"
	if [ -z "$RETENTION_PERIOD" ]; then
		write_out "Configuration 'retention_period' is required"
		return 1
	fi

	remove_expired_full_backups || return 1
	remove_expired_binlog_backups || return 1
}

function remove_expired_binlog_backups()
{
	cd "${BINLOG_BACKUP_DIR}" || return 1
	OLDEST_BKP=`ls ${BASE_BACKUP_DIR} | head -n 1`
	LIST=`find . -type f \! -newer "${BASE_BACKUP_DIR}/${OLDEST_BKP}"` || return 1
	for BINLOG in $LIST; do
		write_out "Removing expired backup of binary log sequence $LOGSEQ"
		BINLOG=`basename $BINLOG`
		rm -f $BINLOG || return 1
		BINLOG=`echo $BINLOG | cut -d . -f 2`
		LOGSEQ=`expr $BINLOG + 0`
	done
}

function remove_expired_full_backups()
{
	BASE_BACKUP_DIR="$BACKUP_DIR/base"
	REF_TIMESTAMP=`date --date="-$RETENTION_PERIOD days" +%Y%m%d%H%M%S`
	mkdir -p "$BASE_BACKUP_DIR" || return 1
	COUNT=`ls "$BASE_BACKUP_DIR" | wc -l`
	if [ $COUNT -eq 0 ]; then
		return 0
	fi
	PREV_BKP=
	for BKP in `ls "$BASE_BACKUP_DIR"`; do
		DATE=${BKP:0:10}
		TIME=${BKP:11:8}
		TIME=${TIME//-/:}
		BKP_FMT_TS="$DATE $TIME"
		BKP_TIMESTAMP=`date --date="$BKP_FMT_TS" +%Y%m%d%H%M%S`
		if [ $BKP_TIMESTAMP -ge $REF_TIMESTAMP ]; then
			return
		fi
		if [ -n "$PREV_BKP" ]; then
			write_out "Removing expired full backup $PREV_BKP"
			rm -fr "$BASE_BACKUP_DIR/$PREV_BKP" || return 1
			PREV_BKP=`echo $PREV_BKP | cut -d . -f 1`
		fi
		PREV_BKP=$BKP
	done
}

function help_remove()
{
	echo "* Remove backups"
	echo "	remove expired"
	echo "		expired: Remove expired backups, according to retention policy set in configuration"
}

function reset_master()
{
	mysql $TARGET_CRED_OPT -e "reset master;" >/dev/null || return 1
}

function restore()
{
	local OPTIND l_opt
	while getopts "h" l_opt; do
		case $l_opt in
			h)
				help_restore
				return
				;;
			\?)
				help_restore
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if [ $# -lt 1 ]; then
		help_restore
		return 1
	fi

#backup dir is required
	if [ -z "$BACKUP_DIR" ]; then
		echo "Configuration 'backup_dir' is required" >&2
		return 1
	fi
	CMD=$1
	shift
	case $CMD in
		config)
			restore_config $* || return 1
			;;
		database)
			restore_database $* || return 1
			;;
		*)
			help_restore
			return 1
			;;
	esac
}

function restore_config()
{
	local OPTIND l_opt
	while getopts "ho:p:" l_opt; do
		case $l_opt in
			h)
				help_restore_config
				return
				;;
			o)
				BACKUP_DIR="${OPTARG}"
				;;
			p)
				USER_TIMESTAMP="${OPTARG}"
				;;
			\?)
				help_restore_config
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if [ $# -ne 0 ]; then
		help_restore_config
		return 1
	fi
	BASE_BACKUP_DIR="$BACKUP_DIR/base"
	[ -d "$BASE_BACKUP_DIR" ] || { write_out "No backup found" && return 1; }
	REQ_TIMESTAMP=`date +%Y-%m-%d_%H:%M:%S`
	if [ -n "$USER_TIMESTAMP" ]; then
		REQ_TIMESTAMP=`expand_timestamp $USER_TIMESTAMP` || return 1
		write_out "Requested timestamp: $REQ_TIMESTAMP"
	fi
	ISO_REQ_TIMESTAMP="${REQ_TIMESTAMP/_/ }"
	DIR=`find_base_backup "$ISO_REQ_TIMESTAMP"` || return 1
	CONF="$BASE_BACKUP_DIR/$DIR/server-my.cnf"
	if ! [ -f "$CONF" ]; then
		write_out "Cannot find server configuration file in backup!"
		return 1
	fi
	grep -v "^#" "$CONF"
}

function restore_database()
{
	DORESET=1
	PITR=0
	RESTORE_TABLE_LIST=
	REQ_TIMESTAMP=`date +%Y-%m-%d_%H:%M:%S`
	CUR_SOCKET="$DB_SOCKET"
	local OPTIND l_opt
	while getopts "hno:s:p:t:" l_opt; do
		case $l_opt in
			s)
				RESTORE_SCHEMA=${OPTARG}
				;;
			h)
				help_restore_database
				return
				;;
			o)
				BACKUP_DIR="${OPTARG}"
				DORESET=0
				;;
			n)
				DORESET=0
				;;
			p)
				PITR=1
				USER_TIMESTAMP="${OPTARG}"
				;;
			t)
				RESTORE_TABLE_LIST="$RESTORE_TABLE_LIST ${OPTARG}"
				;;
			\?)
				help_restore_database
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if [ $# -ne 0 ]; then
		help_restore_database
		return 1
	fi
	restore_validate_options || return 1
	if [ $PITR -eq 1 ]; then
		REQ_TIMESTAMP=`expand_timestamp $USER_TIMESTAMP` || return 1
		write_out "Requested timestamp: $REQ_TIMESTAMP"
	fi
	ISO_REQ_TIMESTAMP="${REQ_TIMESTAMP/_/ }"
	TMP_BACKUP_DIR="$BACKUP_DIR/tmp"
	BASE_BACKUP_DIR="$BACKUP_DIR/base"
	BINLOG_BACKUP_DIR="$BACKUP_DIR/binlog"
	DIR=
	if cd "$BASE_BACKUP_DIR" 2>/dev/null; then
		DIR=`ls | tail -n 1 | cut -d . -f 1`
	fi
	if [ $PITR -eq 1 ]; then
		DIR=`find_base_backup "$ISO_REQ_TIMESTAMP"` || return 1
	fi
	if [ -z "$DIR" ]; then
		write_out "No backup to be restored"
		return 1
	fi
	if ! confirm_operation; then
		return 1
	fi
	if ! [ -f "$CONFIG_FILE" ]; then
		write_out "Cannot find readable file '$CONFIG_FILE'"
		return 1
	fi
	#check_backup_consistency || return 1
	cd "$BACKUP_DIR" || return 1
	if [ -n "$RESTORE_SCHEMA" -o -n "$RESTORE_TABLE_LIST" ]; then
		USE_AUX_INSTANCE=1
		#target instance must be running
		if ! mysqladmin $TARGET_CRED_OPT status >/dev/null 2>&1; then
			write_out "Cannot connect to target instance"
			return 1
		fi
		BINLOG_PREFIX=`mysql $TARGET_CRED_OPT -e "show variables like 'log_bin_basename'" | tail -n 1 | cut -f 2 -d$'\t'` || return 1
	fi
	MOMENT=`date +%Y%m%d-%H%M%S`
	AUX_SOCKET_OPT=
	if ! [ -d "$BASE_BACKUP_DIR" ]; then
		write_out "No backup to be restored"
		return 1
	fi
	DATADIR="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION datadir`" 2>/dev/null
	REDODIR="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION innodb_log_group_home_dir 2>/dev/null`"
	UNDODIR="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION innodb_undo_directory 2>/dev/null`"
	BINLOG_INDEX="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION log_bin_index 2>/dev/null`"
	RELAY_LOG_INDEX="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION relay_log_index 2>/dev/null`"
	BINLOG_PREFIX="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION log_bin 2>/dev/null`"
	if [ -n "$BINLOG_PREFIX" ]; then
		BINLOG_DIR="`dirname $BINLOG_PREFIX`" || return 1
	fi
	RELAY_LOG_PREFIX="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION relay_log 2>/dev/null`"
	if [ -n "$RELAY_LOG_PREFIX" ]; then
		RELAY_LOG_DIR="`dirname $RELAY_LOG_PREFIX`" || return 1
	fi

	#secure files directory
	SECURE_DIR="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION secure_file_priv 2>/dev/null`"

	#mysqld user
	MYSQLD_USER="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION user 2>/dev/null`"

	RESTORE_SCHEMA_OLD_NAME=`echo $RESTORE_SCHEMA | cut -d \: -f 1`
	RESTORE_SCHEMA_NEW_NAME=`echo $RESTORE_SCHEMA | cut -d \: -f 2`
	if [ -z "$RESTORE_SCHEMA_NEW_NAME" ]; then
		RESTORE_SCHEMA_NEW_NAME=$RESTORE_SCHEMA_OLD_NAME
	fi

	if [ "$RESTORE_SCHEMA_OLD_NAME" = "mysql" -o "$RESTORE_SCHEMA_OLD_NAME" = "sys" -o "$RESTORE_SCHEMA_OLD_NAME" = "information_schema" -o "$RESTORE_SCHEMA_OLD_NAME" = "performance_schema" ]; then
		write_out "Invalid schema name '$RESTORE_SCHEMA_OLD_NAME'"
		return 1
	fi
	if [ "$RESTORE_SCHEMA_NEW_NAME" = "mysql" -o "$RESTORE_SCHEMA_NEW_NAME" = "sys" -o "$RESTORE_SCHEMA_NEW_NAME" = "information_schema" -o "$RESTORE_SCHEMA_NEW_NAME" = "performance_schema" ]; then
		write_out "Invalid schema name '$RESTORE_SCHEMA_NEW_NAME'"
		return 1
	fi
	CONFIG="$CONFIG_FILE"
	if [ $USE_AUX_INSTANCE -eq 1 ]; then
		if [ -z "$AUX_BASEDIR" ]; then
			write_out "When restoring a single database or a table, AUX_BASEDIR configuration must be set"
			return 1
		fi
		if ! [ -d "$AUX_BASEDIR" ]; then
			write_out "No such directory: $AUX_BASEDIR" >&2
			return 1
		fi
		check_aux_binaries || return 1
		AUX_BASEDIR=`mktemp -d -p "$AUX_BASEDIR" -t "aux_XXXXXXXX"` || return 1
		BASENAME=`basename "$AUX_BASEDIR"` || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$AUX_BASEDIR" || return 1
		fi
		DORESET=0
		AUX_CONFIG=/tmp/${BASENAME}.cnf
		CONFIG="$AUX_CONFIG"
		AUX_BINLOG_PREFIX="${AUX_BASEDIR}/binlog/binlog"
		AUX_BINLOG_INDEX="${AUX_BASEDIR}/binlog.index"
		AUX_DATADIR="$AUX_BASEDIR/datadir"
		AUX_LOG_ERROR=`mktemp /tmp/mysql.XXXXXX.log`
		AUX_PID_FILE="$AUX_BASEDIR/pid_file"
		AUX_SOCKET="$AUX_BASEDIR/socket"
		AUX_PORT=`find_aux_port` || return 1
		AUX_REDODIR="${AUX_BASEDIR}/redo"
		AUX_SOCKET_OPT="--socket=$AUX_SOCKET"
		AUX_UNDODIR="${AUX_BASEDIR}/undo"
		CUR_SOCKET="$AUX_SOCKET"

		#relay
		if [ -n "$RELAY_LOG_INDEX" ]; then
			AUX_RELAY_LOG_INDEX="${AUX_BASEDIR}/relay.index"
		fi
		if [ -n "$RELAY_LOG_PREFIX" ]; then
			AUX_RELAY_LOG_PREFIX="${AUX_BASEDIR}/relay/relay"
		fi
	fi
	write_out "Starting restore"
	MYSQLD_USER="`crudini --get \"$CONFIG_FILE\" $SERVER_INI_SECTION user`" 2>/dev/null
	if [ $USE_AUX_INSTANCE -eq 0 ]; then	
		restore_target_instance $DIR || return 1
	else
		restore_aux_instance $DIR || return 1
	fi
	if [ $SLAVE -eq 1 ]; then
		return
	fi
	ITYPE="restricted"
	if [ $USE_AUX_INSTANCE -eq 1 ]; then
		ITYPE="aux"
	fi
	recover $DIR "$REQ_TIMESTAMP" "$CONFIG" "$CUR_SOCKET" || return 1
	if [ -n "$RESTORE_SCHEMA_OLD_NAME" ]; then
		copy_recovered_db || { mysql_stop "$CONFIG" $ITYPE && return 1; }
	fi
	if [ -n "$RESTORE_TABLE_LIST" ]; then
		copy_restored_tables || { mysql_stop "$CONFIG" $ITYPE && return 1; }
	fi
	if [ $USE_AUX_INSTANCE -eq 0 -a $DORESET -eq 1 ]; then
		create_incarnation $MOMENT
		reset_master || return 1
	fi
	mysql_stop "$CONFIG" $ITYPE

	#if using aux instance, remove files
	if [ $USE_AUX_INSTANCE -eq 1 ]; then
		rm -fr "$AUX_BASEDIR"
		rm "$AUX_LOG_ERROR"
	fi
}

function restore_aux_instance()
{
	DIR="${1}"
	create_aux_config $DIR || return 1
	rm -fr "$AUX_DATADIR/*" || return 1
	mkdir -p $AUX_DATADIR || return 1
	LIM_MEM_OPT=`mount_limit_memory_option`
	FULL_DIR="${BASE_BACKUP_DIR}/${DIR}"

	RELAY_LOG_OPTS=
	if [ -n "$AUX_RELAY_LOG_PREFIX" ]; then
		RELAY_LOG_OPTS="--relay-log=$AUX_RELAY_LOG_PREFIX"
	fi
	if [ -n "$AUX_RELAY_LOG_INDEX" ]; then
		RELAY_LOG_OPTS="$RELAY_LOG_OPTS --relay-log-index=$AUX_RELAY_LOG_INDEX"
	fi

	write_out "===== STARTING mysqlbackup ====="
	if [ -n "$LOG_FILE" ]; then
		TMP_LOG=`mktemp /tmp/myfreerman.XXXXXX` || return 1
		mysqlbackup --defaults-group-suffix=$MYSQL_DEFAULT_GROUP_SUFFIX --defaults-file=$AUX_CONFIG --read-threads=$READ_THREADS --write-threads=$WRITE_THREADS --backup-dir="$FULL_DIR" --skip-messages-logdir $LIM_MEM_OPT copy-back --log-bin="${AUX_BINLOG_PREFIX}" --log-bin-index="${AUX_BINLOG_INDEX}" $RELAY_LOG_OPTS >$TMP_LOG 2>&1
		RETCODE=$?
		cat $TMP_LOG
		cat $TMP_LOG >>"$LOG_FILE"
		rm $TMP_LOG
		if [ $RETCODE -ne 0 ]; then
			return 1
		fi
	else
		mysqlbackup --defaults-group-suffix=$MYSQL_DEFAULT_GROUP_SUFFIX --defaults-file=$AUX_CONFIG --read-threads=$READ_THREADS --write-threads=$WRITE_THREADS --backup-dir="$FULL_DIR" --skip-messages-logdir $LIM_MEM_OPT copy-back --log-bin="${AUX_BINLOG_PREFIX}" --log-bin-index="${AUX_BINLOG_INDEX}" $RELAY_LOG_OPTS || return 1
	fi
	write_out "===== FINISHED mysqlbackup ===== "

#===========================================
#Rodrigo Tassinari - 2020-03-11
#BUG in MEB 8.0.18:
#Binary log index informed in --log-bin-index is appended a text ".index", and manual does not say that
#So, we rename it
	BUG_BINLOG_INDEX="${AUX_BINLOG_INDEX}.index" 
	mv "$BUG_BINLOG_INDEX" "$AUX_BINLOG_INDEX" || return 1
#===========================================

	#create log file
	touch "$AUX_LOG_ERROR" || return 1
	#change ownership
	if [ -n "$MYSQLD_USER" ]; then
		chown $MYSQLD_USER "$AUX_LOG_ERROR" || return 1
		chown -R $MYSQLD_USER "$AUX_BASEDIR" || return 1
	fi
}

function restore_target_instance()
{
	DIR="${1}"
	#if server is running, abort
	if mysqladmin $TARGET_CRED_OPT >/dev/null 2>&1; then
		write_out "MySQL is running - aborting"
		return 1
	fi
	mkdir -p "$DATADIR" || return 1
	if [ -n "$MYSQLD_USER" ]; then
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DATADIR" || return 1
		fi
	fi

	if [ -n "$UNDODIR" ]; then
		if [ "${UNDODIR:0:1}" != "/" ]; then
			UNDODIR="$DATADIR/$UNDODIR"
		fi
		mkdir -p "$UNDODIR" || return 1
		rm -fr "$UNDODIR/"* || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$UNDODIR" || return 1
		fi
	fi

	#redo
	if [ -n "$REDODIR" ]; then
		if [ "${REDODIR:0:1}" != "/" ]; then
			REDODIR="$DATADIR/$REDODIR"
		fi
		mkdir -p "$REDODIR" || return 1
		if ls -d "$REDODIR"/* >/dev/null 2>&1; then
			write_out "Redo directory [$REDODIR] must be empty"
			return 1
		fi
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$REDODIR" || return 1
		fi
	fi
	if [ -n "$BINLOG_DIR" ]; then
		mkdir -p "$BINLOG_DIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$BINLOG_DIR" || return 1
		fi
	fi
	if [ -n "$SECURE_DIR" ]; then
		mkdir -p "$SECURE_DIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$SECURE_DIR" || return 1
		fi
		chmod 700 "$SECURE_DIR" || return 1
	fi
	check_empty_target_database || return 1
	check_target_instance_config || return 1
	LIM_MEM_OPT=`mount_limit_memory_option`
	FULL_DIR="${BASE_BACKUP_DIR}/${DIR}"
	write_out "===== STARTING mysqlbackup ====="
	if [ -n "$LOG_FILE" ]; then
		TMP_LOG=`mktemp /tmp/myfreerman.XXXXXX` || return 1
		mysqlbackup --defaults-group-suffix=$MYSQL_DEFAULT_GROUP_SUFFIX --defaults-file=$CONFIG_FILE --read-threads=$READ_THREADS --write-threads=$WRITE_THREADS --backup-dir="$FULL_DIR" --skip-messages-logdir $LIM_MEM_OPT copy-back --log-bin="${BINLOG_PREFIX}" --log-bin-index="${BINLOG_INDEX}" >$TMP_LOG 2>&1 
		RETCODE=$?
		cat $TMP_LOG >>"$LOG_FILE"
		cat $TMP_LOG
		rm $TMP_LOG
		if [ $RETCODE -ne 0 ]; then
			return 1
		fi
	else
		mysqlbackup --defaults-group-suffix=$MYSQL_DEFAULT_GROUP_SUFFIX --defaults-file=$CONFIG_FILE --read-threads=$READ_THREADS --write-threads=$WRITE_THREADS --backup-dir="$FULL_DIR" --skip-messages-logdir $LIM_MEM_OPT copy-back --log-bin="${BINLOG_PREFIX}" --log-bin-index="${BINLOG_INDEX}" || return 1 
	fi
	write_out "===== FINISHED mysqlbackup ====="
#===========================================
#Rodrigo Tassinari - 2020-03-11
#BUG in MEB 8.0.18:
#Binary log index informed in --log-bin-index is appended a text ".index", and manual does not say that
#So, we rename it
	if [ -n "$BINLOG_INDEX" ]; then
		BUG_BINLOG_INDEX="${BINLOG_INDEX}.index" 
		mv "$BUG_BINLOG_INDEX" "$BINLOG_INDEX" || return 1
#===========================================
	fi
	if [ -n "$MYSQLD_USER" ]; then
		write_out "Setting permissions"
		chown -R $MYSQLD_USER "$DATADIR" || return 1
		if [ -n "$REDODIR" ]; then
			chown -R $MYSQLD_USER "$REDODIR" || return 1
		fi
		if [ -n "$UNDODIR" ]; then
			chown -R $MYSQLD_USER "$UNDODIR" || return 1
		fi
		if [ -n "$BINLOG_INDEX" -a -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$BINLOG_INDEX" || return 1
		fi
		if [ -n "$BINLOG_DIR" -a -n "$MYSQLD_USER" ]; then
			chown -R $MYSQLD_USER "$BINLOG_DIR" || return 1
		fi
		if [ -n "$RELAY_LOG_INDEX" -a -n "$MYSQLD_USER" -a -f "$RELAY_LOG_INDEX" ]; then
			chown $MYSQLD_USER "$RELAY_LOG_INDEX" || return 1
		fi
		if [ -n "$RELAY_LOG_DIR" -a -n "$MYSQLD_USER" ]; then
			chown -R $MYSQLD_USER "$RELAY_LOG_DIR" || return 1
		fi
	fi
}

function restore_validate_options()
{
	#backup directory must exist
	if ! [ -d "$BACKUP_DIR" ]; then
		write_out "Directory not found: $BACKUP_DIR"
		return 1
	fi

	#for restoration of a specific schema or a specific table, target instance must be local
	if [ -n "$RESTORE_SCHEMA_OLD_NAME" -o -n "$RESTORE_TABLE_LIST" ]; then
		if [ -z "$DB_SOCKET" ]; then
			echo "Restoring specific schemas or tables are not allowed for remote instances" >&2
			return 1
		fi
	fi

	if [ -n "$RESTORE_SCHEMA_OLD_NAME" -a -n "$RESTORE_TABLE_LIST" ]; then
		echo "Options -s and -t cannot be used together" >&2
		return 1
	fi
	if [ -n "$RESTORE_TABLE_LIST" ]; then
		restore_validate_tablenames || return 1
	fi
}

function restore_validate_tablenames()
{
	for QT in $RESTORE_TABLE_LIST; do
		if ! echo "$QT" | grep \\. >/dev/null; then
			echo "Invalid table name: '$QT' - table names must be qualified with schema" >&2
			return 1
		fi
		SCHEMA=`echo $QT | cut -d . -f 1`
		TABLE=`echo $QT | cut -d . -f 2`
		if [ -z "$SCHEMA" -o -z "$TABLE" ]; then
			echo "Invalid table name: '$QT' - table names must be qualified with schema" >&2
			return 1
		fi
	done
}

function run()
{
	CONFIG_FILE=/etc/my.cnf
	LOG_FILE_BASENAME=
	ANSWER_YES=0
	QUIET=0
	while getopts "l:c:qy" opt; do
		case $opt in
			l)
				LOG_FILE_BASENAME=`date "+$OPTARG"` || return 1
				;;
			c)
				CONFIG_FILE="$OPTARG"
				;;
			q)
				QUIET=1
				;;
			y)
				ANSWER_YES=1
				;;
			\?)
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if [ ${CONFIG_FILE:0:1} != "/" ]; then
		CONFIG_FILE="${PWD}/${CONFIG_FILE}"
	fi

	if [ $QUIET -eq 0 ]; then
		header
	fi
	if [ $# -lt 1 ]; then
		main_help
		return 1
	fi
	read_config || return 1
	LOG_FILE=
	if [ -n "$LOG_FILE_BASENAME" ]; then
		LOG_FILE="${LOG_DIR}/$LOG_FILE_BASENAME"
	fi
	SLAVE=0
	TARGET_CRED_OPT=`mount_target_credentials_opt` || return 1
	MYHOST=`hostname`
	BINLOG_BACKUP_DIR="$BACKUP_DIR/binlog"
	RESTORE_BACKUP_DIR="$BACKUP_DIR/restore"
	CMD=`echo $1 | awk '{print tolower($0)}'`
	shift
	USE_AUX_INSTANCE=0
	SERVER_INI_SECTION=mysqld
	if [ -n "$MYSQL_SID" ]; then
		SERVER_INI_SECTION="${SERVER_INI_SECTION}@$MYSQL_SID"
		MYSQL_DEFAULT_GROUP_SUFFIX="@$MYSQL_SID"
	fi
	case $CMD in
		query)
			query $* || return 1
			;;
		backup)
			backup $* || return 1
			;;
		remove)
			remove $* || return 1
			;;
		drop)
			drop $* || return 1
			;;
		init)
			init $* || return 1
			;;
		list)
			list $* || return 1
			;;
		restore)
			restore $* || return 1
			;;
		*)
			if [ -n "$CMD" ]; then
				echo "Invalid command: $CMD" >&2
			fi
			main_help
			return 1
			;;
	esac
}

function remove()
{
	local OPTIND l_opt
	while getopts "h" opt; do
		case $opt in
			h)
				help_remove
				return
				;;
			\?)
				help_remove
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if [ $# -ne 1 ]; then
		help_remove
		return 1
	fi
	case $1 in
		expired)
			remove_expired_backups || return 1
			;;
		*)
			help_remove
			return 1
			;;
	esac
}

function uncompress_backup()
{
	BKP="$1"
	TAR_FILE="${BASE_BACKUP_DIR}/${BKP}.tgz"
	tar -C "${BASE_BACKUP_DIR}" -x -z -f "${TAR_FILE}" || return 1
}

function main_help()
{
	echo "$0 [ -c <config file> ] [ -l <log file format> ] [ -q ] [ -y ] <command> [ -h ] ..."
	echo "options:"
	echo "   c: use a specific config file"
	echo "   l: specify format for log file name"
	echo "   q: quiet mode - do not print release information"
	echo "   y: assume YES for all questions"
	echo "   h: print help for command"
	echo "commands:"
   echo "   backup"
   echo "   list"
   echo "   init"
   echo "   drop"
   echo "   remove"
}

function wait_server_start()
{
	START_TIMEOUT=600
	PID=$1
	CONF_FILE="$2"
	LOG_ERROR="`crudini --get \"$CONF_FILE\" $SERVER_INI_SECTION log_error 2>/dev/null`"
	sleep 5
	COUNT=5
	while [ $COUNT -lt $START_TIMEOUT ]; do
		if tail -n 20 "$LOG_ERROR" | grep -iw "ready for connections" >/dev/null; then
			return 0
		fi
		if ! kill -0 $PID 2>/dev/null; then
			return 1
		fi
		sleep 1
		COUNT=$((COUNT + 1))
	done
}

function write_out()
{
	MSG="$1"
	TS=`date +"%H:%M:%S"`
	echo "[$TS] $MSG"
	if [ -n "$LOG_FILE" ]; then
		echo "[$TS] $MSG" >>"$LOG_FILE"
	fi
}

if [ "$DEBUG" == "1" ]; then
	set -x
fi
NOW_EPOCH=`date +%s`
DATE_VAL=`date +%Y-%m-%d`
TIME_VAL=`date +%H:%M:%S`
MAX_READ_THREADS=20
MAX_WRITE_THREADS=20
READ_THREADS=1
WRITE_THREADS=1
READ_ONLY=0
LOG_FILE=
check_depends || exit -1
run $*
RETCODE=$?
exit $RETCODE
