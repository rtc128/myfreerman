#!/bin/bash
RELEASE=1.3.23

function apply_binlog()
{
	LOGSEQ="$1"
	CONFIG="$2"
	FILENAME="$3"
	CRED_OPT=`mount_target_credentials_opt`
	if ! mysql --defaults-file="$CONFIG" $CRED_OPT <"$FILENAME"; then
		ITYPE="restricted"
		if [ $USE_AUX_INSTANCE -eq 1 ]; then
			ITYPE="aux"
		fi
		mysql_stop "$CONFIG" $ITYPE
		return 1
	fi
	#rotate binlogs
	CRED_OPT=`mount_target_credentials_opt`
	mysqladmin --defaults-file="$MYSQL_CONF_FILE" $CRED_OPT flush-logs || return 1
	CUR_BINLOG=`tail "$BINLOG_INDEX"` || return 1
	BN="`basename \"$CUR_BINLOG\"`" || return 1
	purge_binlogs $BN || return 1
}

function binlog_backup_exists()
{
	cd $BINLOG_BACKUP_DIR || return 1
	LOGSEQ=$1
	LONG_LOGSEQ=`seq -f "%06g" $LOGSEQ $LOGSEQ`
	BINLOG=binlog.$LONG_LOGSEQ
	if [ -f $BINLOG ]; then
		return 0
	fi
	if [ -f $BINLOG.gz ]; then
		return 0
	fi
	return 1
}

function check_aux_binaries()
{
	if ! which mysqld >/dev/null 2>&1; then
		echo "Cannot find 'mysqld' in PATH" >&2
		return 1
	fi
	if ! which mysqldump >/dev/null 2>&1; then
		echo "Cannot find 'mysqldump' in PATH" >&2
		return 1
	fi
}

function check_aux_dir_space()
{
	DIR=$1
	BKP_SIZE=`du -s -m "$DIR/datadir" | cut -f 1`
	REQ_SIZE=`expr $BKP_SIZE + 100`
	FREE_SIZE=`df -m $AUX_BASEDIR | tail -n 1 | tr -s ' ' | cut -d ' ' -f 4` || return 1
	if [ $FREE_SIZE -lt $REQ_SIZE ]; then
		echo "Not enough space in $AUX_BASEDIR - a minimum of ${REQ_SIZE}M is required" >&2
		return 1
	fi
}

function check_backup_consistency()
{
	write_out "Checking backup consistency"
	if ! [ -d "$BASE_BACKUP_DIR" ]; then
		return
	fi
	cd "$BASE_BACKUP_DIR" || return 1
	for BKP in `ls`; do
		if [ -d "$BKP" ]; then
			if ! consistent_backup "$BKP"; then
				rm -r "$BKP"
			fi
		fi
	done
}

function check_config()
{
	if [ $READ_THREADS -lt 1 -o $READ_THREADS -gt $MAX_READ_THREADS ]; then
		echo "READ_THREADS config must be between 1 and $MAX_READ_THREADS" >&2
		return 1
	fi
	if [ $WRITE_THWRITES -lt 1 -o $WRITE_THWRITES -gt $MAX_WRITE_THWRITES ]; then
		echo "WRITE_THREADS config must be between 1 and $MAX_WRITE_THREADS" >&2
		return 1
	fi
}

function check_depends()
{
	#crudini
	if ! rpm -q crudini >/dev/null 2>&1; then
		write_out "Cannot find package 'crudini'"
		return 1
	fi
}

function check_empty_target_database()
{
	#datadir must be empty
	if ls -d "$DATADIR"/* >/dev/null 2>&1; then
		write_out "Data directory [$DATADIR] must be empty"
		return 1
	fi
	if [ -n "$BINLOG_MASK" ] && ls "$BINLOG_MASK"* >/dev/null 2>&1; then
		write_out "No binary logs [${BINLOG_MASK}*] might exist"
		return 1
	fi

	#binlog index file must not exist
	if [ -n "$BINLOG_INDEX" -a -f "$BINLOG_INDEX" >/dev/null 2>&1 ]; then
		write_out "Binary log index [$BINLOG_INDEX] must not exist"
		return 1
	fi
}

function check_log_config()
{
	if [ $BG_MODE -eq 0 ]; then
		return
	fi
	if [ -z "$LOG_DIR" ]; then
		echo "Configuration LOG_DIR is required in background mode" >&2
		return 1
	fi
	if ! [ -d "$LOG_DIR" ]; then
		echo "Log directory LOG_DIR does not exist or is not a directory." >&2
		return 1
	fi
}

function check_lock_file()
{
	MAX_WAIT_TIME_MIN=10
	SLEEP_TIME=15

	MAX_WAIT_TIME_SEC=`expr $MAX_WAIT_TIME_MIN \* 60`
	TOT_WAIT_TIME=0

	if [ -n "$LOCK_FILE" ]; then
		while [ -f "$LOCK_FILE" ]; do
			if [ $TOT_WAIT_TIME -ge $MAX_WAIT_TIME_SEC ]; then
				write_out "Timeout reached waiting for another instance"
				return 1
			fi
			write_out "Waiting for another instance - lock file: $LOCK_FILE"
			sleep $SLEEP_TIME
			TOT_WAIT_TIME=`expr $TOT_WAIT_TIME + $SLEEP_TIME`
		done
		touch "$LOCK_FILE" || return 1
	fi
}

function check_new_db_name()
{
	if [ -n "$RESTORE_DB_NEW_NAME" ]; then
		if ls $DATADIR/$RESTORE_DB_NEW_NAME >/dev/null 2>&1; then
			echo "Database '$RESTORE_DB_NEW_NAME' already exists" >&2
			return 1
		fi
	fi
}

function check_target_instance_config()
{
	START_TIMEOUT=30
	write_out "Checking target instance configuration"
	LOG_ERROR="`crudini --get \"$MYSQL_CONF_FILE\" mysqld log_error 2>/dev/null`"
	if [ -z "$LOG_ERROR" ]; then
		write_out "MySQL configuration mysqld:log_error cannot be empty"
		return 1
	fi
	PID_FILE="`crudini --get \"$MYSQL_CONF_FILE\" mysqld pid_file 2>/dev/null`"
	if [ -z "$PID_FILE" ]; then
		write_out "MySQL configuration mysqld:pid_file cannot be empty"
		return 1
	fi
	if ! which mysqld >/dev/null 2>&1; then
		write_out "Cannot find 'mysqld' executable file"
		return 1
	fi
	TMP_LOG=`mktemp /tmp/mysqld.XXXXXX.log` || return 1
	TMP_CONF=`mktemp /tmp/mysql.XXXXXX.cnf` || return 1
	grep -v "^audit" "$MYSQL_CONF_FILE" >$TMP_CONF || return 1
	if ! mysqld --defaults-file="$TMP_CONF" --initialize >>"$TMP_LOG" 2>&1; then
		write_out "Cannot check target instance configuration. Check server output in '$TMP_LOG' and logs in '$LOG_ERROR'."
		drop_target_database
		return 1
	fi
	mysqld --defaults-file="$TMP_CONF" --bind-address=127.0.0.1 &
	if ! wait_server_start "$TMP_CONF"; then
		write_out "Cannot check target instance configuration. Check server logs in '$LOG_ERROR'."
		drop_target_database
		return 1
	fi
	kill_pid "$PID_FILE"
	rm $TMP_CONF
	drop_target_database || return 1
}

function compress_all_backups()
{
	cd "$BASE_BACKUP_DIR" || exit -1
	LIST=`find . -mindepth 1 -maxdepth 1 -type d | sort | sed -e 's/\.\///'`
	for BKP in $LIST; do
		if [ $BG_MODE -eq 0 ]; then
			echo "[$TS] Compressing backup ${BKP}"
		else
			echo "[$TS] Compressing backup ${BKP}" >>"$LOG_FILE"
		fi
		TAR_FILE="${BKP}.tgz"
		if ! [ -f "$TAR_FILE" ]; then
			tar -c -z -f "$TAR_FILE" "${BKP}" || return 1
		fi
		rm -fr "${BKP}" || return 1
	done
}

function confirm_operation()
{
	if [ $BG_MODE -eq 1 -o $ANSWER_YES -eq 1 ]; then
		return 0
	fi
	echo -n "Are you sure? (You must type 'yes' to confirm): "
	read ANSWER
	LANSWER=`echo "$ANSWER" | awk '{print tolower($0)}'`
	if [ "$LANSWER" == "yes" ]; then
		return 0
	fi
	return 1
}

function consistent_backup()
{
	TMP_BKP_DIR="$1"
	TMP_BACKUP_VARS="$TMP_BKP_DIR/meta/backup_variables.txt"
	if ! [ -f "$TMP_BACKUP_VARS" ]; then
		return 1
	fi
	TMP_APPLY_LOG_DONE="`crudini --get \"$TMP_BACKUP_VARS\" backup_variables apply_log_done`" || return 1
	if [ "$TMP_APPLY_LOG_DONE" != "1" ]; then
		return 1
	fi
	return 0
}

function copy_recovered_db()
{
	CRED_OPT=`mount_target_credentials_opt`
	if [ -z "$RESTORE_DB_NEW_NAME" ]; then
		RESTORE_DB_NEW_NAME=$RESTORE_DB_OLD_NAME
		write_out "Dropping target database '$RESTORE_DB_NEW_NAME'"
		mysql $CRED_OPT -e "drop database if exists $RESTORE_DB_NEW_NAME;" || return 1
	fi
	write_out "Copying recovered database from aux instance"
	mysql $CRED_OPT -e "create database $RESTORE_DB_NEW_NAME;" >/dev/null || return 1
	mysqldump --defaults-file=$AUX_CONFIG --no-create-db --routines --events --triggers $RESTORE_DB_OLD_NAME | mysql $CRED_OPT $RESTORE_DB_NEW_NAME
	stop_aux_instance
}

function copy_restored_tables()
{
	CRED_OPT=`mount_target_credentials_opt`
	write_out "Copying restored tables from aux instance"
	for QT in $RESTORE_TABLE_LIST; do
		if ! echo "$QT" | grep \\. >/dev/null; then
			echo "Invalid table name: '$QT' - table names must be qualified with schema" >&2
			return 1
		fi
		SCHEMA=`echo $QT | cut -d . -f 1`
		TABLE=`echo $QT | cut -d . -f 2`
		if [ $BG_MODE -eq 0 ]; then
			echo "[$TS]    ${QT}"
		else
			echo "[$TS]    ${QT}" >>"$LOG_FILE"
		fi
		mysqldump --defaults-file=$AUX_CONFIG --no-create-db --routines --events --triggers $SCHEMA $TABLE | mysql $CRED_OPT $SCHEMA
	done
	stop_aux_instance
}

function create_aux_config()
{
	DIR=$1
	MYSQL_VER=`get_mysql_usage $DIR` || return 1
	if [ -z "$AUX_BASEDIR" ]; then
		echo "Cannot find 'basedir' in '$MYSQL_CONF_FILE'" >&2
		return 1
	fi
	if ! [ -d "$AUX_BASEDIR" ]; then
		echo "'$MYSQL_CONF_FILE' is not a directory (or access is denied)" >&2
		return 1
	fi
	CRED_OPT=`mount_target_credentials_opt`
	TARGET_BASEDIR=`mysql $CRED_OPT -e "show global variables like 'basedir'" | tail -n 1 | cut -f 2 -d$'\t'`
	LC_MESSAGES_DIR=`mysql $CRED_OPT -e "show global variables like 'lc_messages_dir'" | tail -n 1 | cut -f 2 -d$'\t'`
	echo "[mysqld]" >$AUX_CONFIG
	echo "datadir=$AUX_DATADIR" >>$AUX_CONFIG
	echo "explicit_defaults_for_timestamp=1" >>$AUX_CONFIG
	echo "innodb_buffer_pool_size=10M" >>$AUX_CONFIG
	echo "innodb_data_home_dir="$AUX_DATADIR >>$AUX_CONFIG
	echo "innodb_log_group_home_dir=$AUX_DATADIR" >>$AUX_CONFIG
	echo "innodb_undo_directory=$AUX_DATADIR" >>$AUX_CONFIG
	echo "lc_messages_dir=$LC_MESSAGES_DIR" >>$AUX_CONFIG
	echo "lc_messages=en_US" >>$AUX_CONFIG
	echo "log_error=$AUX_LOG_ERROR" >>$AUX_CONFIG
	echo "log_timestamps=system" >>$AUX_CONFIG
	echo "max_allowed_packet=100M" >>$AUX_CONFIG
	echo "pid_file=$AUX_PID_FILE" >>$AUX_CONFIG
	echo "port=$AUX_PORT" >>$AUX_CONFIG
	echo "socket=$AUX_SOCKET" >>$AUX_CONFIG
	echo "skip-grant-tables=1" >>$AUX_CONFIG
	echo "user=mysql" >>$AUX_CONFIG
	if [ $MYSQL_VER -eq 8 ]; then
		echo "mysqlx=off" >>$AUX_CONFIG
	fi
	echo "[mysql]" >>$AUX_CONFIG
	echo "port=$AUX_PORT" >>$AUX_CONFIG
	echo "socket=$AUX_SOCKET" >>$AUX_CONFIG
	echo "[mysqldump]" >>$AUX_CONFIG
	echo "max_allowed_packet=99M" >>$AUX_CONFIG
	echo "port=$AUX_PORT" >>$AUX_CONFIG
	echo "socket=$AUX_SOCKET" >>$AUX_CONFIG
}

function create_incarnation()
{
	write_out "Creating new backup incarnation"
	MOMENT=$1
	RESTORE_DIR=$RESTORE_BACKUP_DIR/$MOMENT
	mkdir -p "$RESTORE_DIR" || return 1
	mv "$BACKUP_DIR/base" "$BACKUP_DIR/binlog" "$RESTORE_DIR" || return 1
}

function drop_target_database()
{
	if [ -n "$REDODIR" ]; then
		rm -fr "$REDODIR"/* || return 1
	fi
	if [ -n "$UNDODIR" ]; then
		rm -fr "$UNDODIR"/* || return 1
	fi
	if [ -n "$BINLOG_MASK" ]; then
		rm -f "$BINLOG_MASK"* || return 1
	fi
	if [ -n "$BINLOG_INDEX" ]; then
		rm -f "$BINLOG_INDEX" || return 1
	fi
	rm -fr "$DATADIR/"* || return 1
}

function exist_base_backup()
{
	if ! [ -d $BASE_BACKUP_DIR ]; then
		return 1
	fi
	COUNT=`ls $BASE_BACKUP_DIR | wc -l`
	if [ $COUNT -eq 0 ]; then
		return 1
	fi
	return 0
}

function fix_timestamps()
{
	cd $BASE_BACKUP_DIR || return 1
	for BACKUP in *; do
		fix_backup_timestamp $BACKUP || return 1
	done
}

function find_aux_port()
{
	FIRST_PORT=10000
	LAST_PORT=19999
	RANGE=`expr $LAST_PORT - $FIRST_PORT`
	while true; do
		PORT=$RANDOM
		let "PORT %= $RANGE"
		PORT=`expr $PORT + $FIRST_PORT`
		if port_available $PORT; then
			echo $PORT
			return
		fi
	done
}

function find_base_backup()
{
	REQ_TIMESTAMP=`date --date="$1" +%Y%m%d%H%M%S` || return 1
	if [ -z "$REQ_TIMESTAMP" ]; then
		return 1
	fi
	cd "$BASE_BACKUP_DIR" || return 1
	for BKP in `ls -r | cut -d . -f 1`; do
		DATE=${BKP:0:10}
		TIME=${BKP:11:8}
		TIME=${TIME//-/:}
		BKP_FMT_TS="$DATE $TIME"
		BKP_TIMESTAMP=`date --date="$BKP_FMT_TS" +%Y%m%d%H%M%S`
		if [ $BKP_TIMESTAMP -le $REQ_TIMESTAMP ]; then
			echo $BKP
			return
		fi
	done
	echo "No backup found for requested timestamp" >&2
	return 1
}

function fix_backup_timestamp()
{
	BACKUP=$1
	write_out "Fixing backup $BACKUP timestamp"
	cd $BASE_BACKUP_DIR || return 1
	LOGSEQ=`get_base_backup_binlog_sequence $BACKUP` || return 1
	POSITION=`get_base_backup_binlog_position $BACKUP` || return 1
	BINLOG=`get_binlog_path $LOGSEQ` || return 1
	NEWNAME=`get_binlog_transaction_timestamp $BINLOG $POSITION` || return 1
	if [ "$BACKUP" != "$NEWNAME" ]; then
		if [ -d ${BACKUP} ]; then
			mv $BACKUP $NEWNAME || return 1
		fi
	fi
}

function get_base_backup_binlog_name()
{
	BACKUP=$1
	grep -w "binlog_position" $BASE_BACKUP_DIR/$BACKUP/meta/backup_variables.txt | cut -d '=' -f 2 | cut -d ':' -f 1 || return 1
}

function get_base_backup_binlog_sequence()
{
	BACKUP=$1
	BINLOG=`get_base_backup_binlog_name $BACKUP`
	get_binlog_sequence $BINLOG || return 1
}

function get_base_backup_binlog_position()
{
	BACKUP=$1
	grep -w "binlog_position" $BASE_BACKUP_DIR/$BACKUP/meta/backup_variables.txt | cut -d '=' -f 2 | cut -d ':' -f 2 || return 1
}

function get_binlog_path()
{
	LOGSEQ=$1
	LONG_LOGSEQ=`seq -f "%06g" $LOGSEQ $LOGSEQ`
	BINLOG=binlog.$LONG_LOGSEQ
	if [ -f "$BINLOG_DIR/$BINLOG" ]; then
		echo "$BINLOG_DIR/$BINLOG"
		return
	fi
	if [ -f $BINLOG_BACKUP_DIR/$BINLOG ]; then
		echo $BINLOG_BACKUP_DIR/$BINLOG
		return
	fi
	if [ -f $BINLOG_BACKUP_DIR/$BINLOG.gz ]; then
		echo $BINLOG_BACKUP_DIR/$BINLOG.gz
		return
	fi
	echo "Cannot find binary log $LOGSEQ anywhere" >&2
	return 1
}

function get_binlog_backup_path()
{
	LOGSEQ=$1
	LONG_LOGSEQ=`seq -f "%06g" $LOGSEQ $LOGSEQ`
	BINLOG=binlog.$LONG_LOGSEQ
	if [ -f $BINLOG_BACKUP_DIR/$BINLOG ]; then
		echo $BINLOG_BACKUP_DIR/$BINLOG
		return
	fi
	if [ -f $BINLOG_BACKUP_DIR/$BINLOG.gz ]; then
		echo $BINLOG_BACKUP_DIR/$BINLOG.gz
		return
	fi
	echo "Cannot find binary log $LOGSEQ anywhere" >&2
	return 1
}

function get_binlog_sequence()
{
	BINLOG=$1
	LONG_LOGSEQ=`echo $BINLOG | cut -d . -f 2`
	expr $LONG_LOGSEQ + 0
}

function get_binlog_transaction_timestamp()
{
	BINLOG=$1
	POSITION=$2

	PLAIN_BINLOG=/$BINLOG
	TMP_BINLOG=
	if file $PLAIN_BINLOG | grep -w gzip >/dev/null; then
		TMP_BINLOG=`mktemp /tmp/tmp-binlog.XXXXXX` || return 1
		PLAIN_BINLOG=$TMP_BINLOG
		gunzip -c $BINLOG >$PLAIN_BINLOG
	fi
	TMP_SQL=`mktemp /tmp/tmp-sql.XXXXXX` || return 1
	mysqlbinlog $PLAIN_BINLOG >$TMP_SQL || return 1
	if [ -n "$TMP_BINLOG" ]; then
		rm $TMP_BINLOG
	fi
	LINE=`grep "^#.*end_log_pos $POSITION" $TMP_SQL` || return 1
	rm $TMP_SQL
	TIMESTAMP="${LINE:1:15}"
	date -d"$TIMESTAMP" +%Y-%m-%d_%H-%M-%S
}

function get_mysql_usage()
{
	BACKUP=$1
	grep -w "mysql_usage" $BASE_BACKUP_DIR/$BACKUP/meta/backup_variables.txt | cut -d '=' -f 2 | cut -d '.' -f 1 || return 1
}

function get_oldest_full_backup()
{
	cd "$BACKUP_DIR" || return 1
	mkdir -p "$BASE_BACKUP_DIR" || return 1
	cd "$BASE_BACKUP_DIR" || return 1
	ls | head -n 1
}

function header()
{
	write_out "MyTJRSRman - TJRS Backup Utility for MySQL - Release $RELEASE - Host $MYHOST"
}

function kill_pid()
{
	WAIT_TIMEOUT=15
	PID_FILE="$1"
	PID=`cat "$PID_FILE"`
	kill $PID
	sleep 1
	COUNT=1
	while kill -0 $PID 2>/dev/null; do
		COUNT=$((COUNT + 1))
		if [ $COUNT -ge $WAIT_TIMEOUT ]; then
			return 1
		fi
		sleep 1
	done
}

function init()
{
	#mysqld user
	MYSQLD_USER="`crudini --get \"$MYSQL_CONF_FILE\" mysqld user 2>/dev/null`"

	#datadir
	DATADIR="`crudini --get \"$MYSQL_CONF_FILE\" mysqld datadir`" 2>/dev/null
	if [ -n "$DATADIR" ]; then
		mkdir -p "$DATADIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DATADIR" || return 1
		fi
	fi

	#redo
	REDODIR="`crudini --get \"$MYSQL_CONF_FILE\" mysqld innodb_log_group_home_dir 2>/dev/null`"
	if [ -n "$REDODIR" ]; then
		mkdir -p "$REDODIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$REDODIR" || return 1
		fi
	fi

	#undo
	UNDODIR="`crudini --get \"$MYSQL_CONF_FILE\" mysqld innodb_undo_directory 2>/dev/null`"
	if [ -n "$UNDODIR" ]; then
		mkdir -p "$UNDODIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$UNDODIR" || return 1
		fi
	fi

	#binlog index file
	BINLOG_INDEX="`crudini --get \"$MYSQL_CONF_FILE\" mysqld log_bin_index 2>/dev/null`"
	if [ -n "$BINLOG_INDEX" ]; then
		DNAME="`dirname $BINLOG_INDEX`" || return 1
		mkdir -p "$DNAME" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DNAME" || return 1
		fi
	fi

	#binlogs directory
	BINLOG_PREFIX="`crudini --get \"$MYSQL_CONF_FILE\" mysqld log_bin 2>/dev/null`"
	if [ -n "$BINLOG_PREFIX" ]; then
		BINLOG_DIR="`dirname $BINLOG_PREFIX`" || return 1
		mkdir -p "$BINLOG_DIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$BINLOG_DIR" || return 1
		fi
	fi

	#secure files directory
	SECURE_DIR="`crudini --get \"$MYSQL_CONF_FILE\" mysqld secure_file_priv 2>/dev/null`"
	if [ -n "$SECURE_DIR" ]; then
		mkdir -p "$SECURE_DIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$SECURE_DIR" || return 1
			chmod 700 "$SECURE_DIR" || return 1
		fi
	fi

	#tmp directory
	TMP_DIRECTORY="`crudini --get \"$MYSQL_CONF_FILE\" mysqld tmpdir 2>/dev/null`"
	if [ -n "$TMP_DIRECTORY" ]; then
		mkdir -p "$TMP_DIRECTORY" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$TMP_DIRECTORY" || return 1
		fi
	fi

	#slow query log file
	SLOW_QUERY_LOG_FILE="`crudini --get \"$MYSQL_CONF_FILE\" mysqld slow_query_log_file 2>/dev/null`"
	if [ -n "$SLOW_QUERY_LOG_FILE" ]; then
		DNAME="`dirname $SLOW_QUERY_LOG_FILE`" || return 1
		mkdir -p "$DNAME" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DNAME" || return 1
		fi
	fi

	#general log file
	GENERAL_LOG_FILE="`crudini --get \"$MYSQL_CONF_FILE\" mysqld general_log_file 2>/dev/null`"
	if [ -n "$GENERAL_LOG_FILE" ]; then
		DNAME="`dirname $GENERAL_LOG_FILE`" || return 1
		mkdir -p "$DNAME" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DNAME" || return 1
		fi
	fi
}

function list()
{
	LIST_REMOTE_HOST=
	local OPTIND l_opt
	while getopts "r:" l_opt; do
		case $l_opt in
			r)
				LIST_REMOTE_HOST=${OPTARG}
				;;
			\?)
				echo "Invalid option: -$OPTARG" >&2
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	CMD=$1
	if [ -n "$LIST_REMOTE_HOST" ]; then
		list_remote $CMD || return 1
		return
	fi
	case $CMD in
		full)
			list_full || return 1
			;;
		binlog)
			list_binlog || return 1
			;;
		*)
			usage
			return 1
			;;
	esac
}

function list_binlog()
{
	cd "$BINLOG_BACKUP_DIR" || return 1
	echo -e SEQUENCE '\t' DATE '\t\t' TIME
	echo "-----------------------------------------"
	LIST=`ls`
	for F in $LIST; do
		BINLOG=`echo $F | cut -d . -f 2`
		LOGSEQ=`expr $BINLOG + 0`
		BKP_FMT_TS="`stat -c %y "$F" | cut -d . -f 1`"
		DATE=${BKP_FMT_TS:0:10}
		TIME=${BKP_FMT_TS:11:8}
		echo -e $LOGSEQ '\t\t' $DATE '\t' $TIME
	done
}

function list_binlog_remote
{
	ssh -q -o "StrictHostKeyChecking=no" $LIST_REMOTE_HOST mytjrsrman -c /etc/mytjrsrman/${LIST_REMOTE_HOST}.conf list binlog
}

function list_full()
{
	cd "$BASE_BACKUP_DIR" || return 1
	echo -e DATE '\t\t' TIME
	echo "-------------------------"
	LIST=`ls`
	for BKP in $LIST; do
		DATE=${BKP:0:10}
		TIME=${BKP:11:8}
		TIME=${TIME//-/:}
		echo -e $DATE '\t' $TIME
	done
}

function list_full_remote
{
	ssh -q -o "StrictHostKeyChecking=no" $LIST_REMOTE_HOST mytjrsrman -c /etc/mytjrsrman/${LIST_REMOTE_HOST}.conf list full
}

function list_remote
{
	REMOTE_USER=`whoami`
	REMOTE_INST=`echo $REMOTE_HOST | cut -d . -f 1`
	CONFIG_FILE=/etc/mytjrsrman.conf
	if [ -n "$REMOTE_INST" ]; then
		CONFIG_FILE=/etc/mytjrsrman/${REMOTE_INST}.conf 
	fi
	CMD=$1
	case $CMD in
		full)
			list_full_remote || return 1
			;;
		binlog)
			list_binlog_remote || return 1
			;;
	esac
}

function mount_credentials_opt()
{
	RESULT=
	if [ -n "$DB_HOSTNAME" ]; then
		RESULT="$RESULT --host=$DB_HOSTNAME"
	fi
	if [ -n "$DB_USERNAME" ]; then
		RESULT="$RESULT --user=$DB_USERNAME"
	fi
	if [ $USE_AUX_INSTANCE -eq 1 ]; then
		return
	fi
	if [ -n "$DB_PASSWORD" ]; then
		if [ -n "$RESULT" ]; then
			RESULT="$RESULT"
		fi
		RESULT="${RESULT}--password=$DB_PASSWORD"
	fi
	echo -n "$RESULT"
}

function mount_limit_memory_option()
{
	if [ -n "$MAX_MEM" ]; then
		echo "--limit-memory=$MAX_MEM"
	fi
}

function mount_target_credentials_opt()
{
	RESULT=
	if [ -n "$DB_HOSTNAME" ]; then
		RESULT="$RESULT --host=$DB_HOSTNAME"
	fi
	if [ -n "$DB_USERNAME" ]; then
		RESULT="$RESULT --user=$DB_USERNAME"
	fi
	if [ -n "$DB_PASSWORD" ]; then
		RESULT="$RESULT --password=$DB_PASSWORD"
	fi
	echo -n "$RESULT"
}

function mount_aux_defaults_file_opt()
{
	if [ $USE_AUX_INSTANCE -eq 1 ]; then
		echo "--defaults-file=$AUX_CONFIG"
	fi
}

function mysql_start()
{
	CONFIG="$1"
	INST_TYPE="$2"

	START_TIMEOUT=240

	LOG_ERROR="`crudini --get \"$CONFIG\" mysqld log_error 2>/dev/null`"
	PID_FILE="`crudini --get \"$CONFIG\" mysqld pid_file 2>/dev/null`"
	CMD="mysqld"
	OPTS="--defaults-file=$CONFIG --bind-address=127.0.0.1 --console"
	write_out "Starting server (${INST_TYPE})"
	$CMD $OPTS & >"$LOG_ERROR" 2>&1
	sleep 5
	COUNT=5
	while [ $COUNT -lt $START_TIMEOUT ]; do
		if tail -n 20 "$LOG_ERROR" | grep -iw "ready for connections" >/dev/null; then
			return 0
		fi
		if ! [ -f "$PID_FILE" ]; then
			write_out "Cannot start server - check logs in '$LOG_ERROR'"
			return 1
		fi
		sleep 1
		COUNT=$((COUNT + 1))
	done
	write_out "Timeout reached waiting for server to start. Please check server logs in '$LOG_ERROR'"
	return 1
}

function mysql_start_aux()
{
	START_TIMEOUT=120
	write_out "Starting aux instance"
	CMD="mysqld --defaults-file=$AUX_CONFIG"
	$CMD &
	sleep 2
	COUNT=2
	while [ $COUNT -lt $START_TIMEOUT ]; do
		sleep 1
		COUNT=`expr $COUNT + 1`
		if [ -f $AUX_LOG_ERROR ] && grep -w "\\[ERROR\\]" $AUX_LOG_ERROR >/dev/null; then
			if [ -f $AUX_PID_FILE ]; then
				PID=`cat $AUX_PID_FILE`
				kill $PID
			fi
			echo "Cannot start aux instance. Please check log file $AUX_LOG_ERROR" >&2
			return 1
		fi
		if [ -f $AUX_LOG_ERROR ] && grep -w "ready for connections" $AUX_LOG_ERROR >/dev/null; then
			return
		fi
	done
	if [ -f $AUX_PID_FILE ]; then
		PID=`cat $AUX_PID_FILE`
		kill $PID
	fi
	echo "Timeout reached waiting for aux instance to start. Please check log file $AUX_LOG_ERROR" >&2
	return 1
}

function mysql_stop()
{
	CONFIG="$1"
	INST_TYPE="$2"
	STOP_TIMEOUT=30
	PID_FILE="`crudini --get \"$CONFIG\" mysqld pid_file 2>/dev/null`"
	LOG_ERROR="`crudini --get \"$CONFIG\" mysqld log_error 2>/dev/null`"
	write_out "Stopping server (${INST_TYPE})"
	PID=`cat "$PID_FILE"`
	kill $PID
	sleep 3
	COUNT=3
	while [ $COUNT -lt $STOP_TIMEOUT ]; do
		if ! kill -0 $PID 2>/dev/null; then
			return 0
		fi
		sleep 1
		COUNT=`expr $COUNT + 1`
	done
	write_out "Timeout reached waiting server to stop. Check server logs [${LOG_ERROR}]."
	return 1
}

function port_available()
{
	PORT=$1
	if netstat -an | grep -w $PORT >/dev/null; then
		return 1
	fi
	return 0
}

function purge_binlogs()
{
	LIMIT_LOG=$1
	CRED_OPT=`mount_credentials_opt` || return 1
	mysql --defaults-file="$MYSQL_CONF_FILE" $CRED_OPT -e "purge binary logs to '$LIMIT_LOG';" >/dev/null || return 1
}

function query()
{
	CMD=`echo $1 | awk '{print tolower($0)}'`
	shift
	case $CMD in
		backup_age)
			query_backup_age || return 1
			;;
		*)
			usage
			;;
	esac
}
function query_backup_age()
{
	FULL=`query_full_backup_age` || return 1
	BINLOG=`query_binlog_backup_age` || return 1
	echo "FULL|$FULL"
	echo "BINLOG|$BINLOG"
}

function query_binlog_backup_age()
{
	cd $BINLOG_BACKUP_DIR || return 1
	LAST_FILE=`ls -tr | tail -n 1`
	DATE=${BKP:0:10}
	TIME=${BKP:11:8}
	TIME=${TIME//-/:}
	BKP_FMT_TS="`stat -c %y $LAST_FILE | cut -d . -f 1`"
	BKP_TS_EPOCH=`date -d "$BKP_FMT_TS" +%s`
	DIFF=`expr $NOW_EPOCH - $BKP_TS_EPOCH`
	RESULT=`echo "scale = 2; $DIFF / 3600" | bc`
	echo $RESULT
}

function query_full_backup_age()
{
	cd "$BASE_BACKUP_DIR" || return 1
	BKP=`ls | tail -n 1`
	DATE=${BKP:0:10}
	TIME=${BKP:11:8}
	TIME=${TIME//-/:}
	BKP_FMT_TS="$DATE $TIME"
	BKP_TS_EPOCH=`date -d "$BKP_FMT_TS" +%s`
	DIFF=`expr $NOW_EPOCH - $BKP_TS_EPOCH`
	RESULT=`echo "scale = 2; $DIFF / 3600 / 24" | bc`
	echo $RESULT
}

function read_binlog()
{
	LOGSEQ=$1
	POSITION=$2
	STOP_DATETIME_OPT="--stop-datetime=$3"
	SQL_DEST=$4
	RECOVER_DB=
	if [ $# -ge 5 ]; then
		RECOVER_DB=$5
	fi
	POSITION_OPTION=
	if [ $POSITION -ne 0 ]; then
		POSITION_OPTION="--start-position=$POSITION"
	fi
	BINLOG=`get_binlog_backup_path $LOGSEQ`
	PLAIN_BINLOG=$BINLOG
	TMP_BINLOG=
	if file $PLAIN_BINLOG | grep -w gzip >/dev/null; then
		TMP_BINLOG=`mktemp /tmp/tmp-binlog.XXXXXX`
		PLAIN_BINLOG=$TMP_BINLOG
		gunzip -c $BINLOG >$PLAIN_BINLOG || return 1
	fi
	DB_OPTION=
	if [ -n "$RECOVER_DB" ]; then
		DB_OPTION="--database=$RECOVER_DB"
	fi
	mysqlbinlog $DB_OPTION "$STOP_DATETIME_OPT" $POSITION_OPTION $PLAIN_BINLOG >>$SQL_DEST || return 1
	if [ -n "$TMP_BINLOG" ]; then
		rm $TMP_BINLOG
	fi
}

function recover()
{
	BASE_BACKUP=$1
	REQ_TIMESTAMP="$2"
	MY_REQ_TIMESTAMP="${REQ_TIMESTAMP/_/ }"
	CONFIG="$3"
	CRED_OPT=`mount_credentials_opt` || return 1
	TMP_SQL=`mktemp /tmp/recover.XXXXXX.sql`
	LOGSEQ=`get_base_backup_binlog_sequence $BASE_BACKUP`
	POSITION=`get_base_backup_binlog_position $BASE_BACKUP`
	ITYPE="restricted"
	if [ $USE_AUX_INSTANCE -eq 1 ]; then
		ITYPE="aux"
	fi
	mysql_start "$CONFIG" $ITYPE || return 1
	write_out "Applying binary log sequence $LOGSEQ"
	if ! read_binlog $LOGSEQ $POSITION "$MY_REQ_TIMESTAMP" $TMP_SQL $RECOVER_DB; then
		mysql_stop "$CONFIG" $ITYPE
		return 1
	fi
	apply_binlog $LOGSEQ "$CONFIG" $TMP_SQL || return 1

	LOGSEQ=`expr $LOGSEQ + 1`
	while binlog_backup_exists $LOGSEQ; do
		rm $TMP_SQL || return 1
		touch $TMP_SQL || return 1
		write_out "Applying binary log sequence $LOGSEQ"
		read_binlog $LOGSEQ 0 "$MY_REQ_TIMESTAMP" $TMP_SQL || return 1
		apply_binlog $LOGSEQ "$CONFIG" $TMP_SQL || return 1
		LOGSEQ=`expr $LOGSEQ + 1`
	done
	rm $TMP_SQL
}

function remove_lock_file()
{
	if [ -n "$LOCK_FILE" ]; then
		rm -f "$LOCK_FILE"
	fi
}

function remove_old_backups()
{
	remove_old_full_backups || return 1
	remove_old_binlog_backups || return 1
}

function remove_old_binlog_backups()
{
	cd "${BINLOG_BACKUP_DIR}" || return 1
	OLDEST_BKP=`ls ${BASE_BACKUP_DIR} | head -n 1`
	LIST=`find . \! -newer "${BASE_BACKUP_DIR}/${OLDEST_BKP}"` || return 1
	for BINLOG in $LIST; do
		write_out "Removing expired backup of binary log sequence $LOGSEQ"
		BINLOG=`basename $BINLOG`
		rm -f $BINLOG || return 1
		BINLOG=`echo $BINLOG | cut -d . -f 2`
		LOGSEQ=`expr $BINLOG + 0`
	done
}

function remove_old_full_backups()
{
	REF_TIMESTAMP=`date --date="-$RETENTION_PERIOD days" +%Y%m%d%H%M%S`
	cd "$BACKUP_DIR" || return 1
	mkdir -p "$BASE_BACKUP_DIR" || return 1
	cd "$BASE_BACKUP_DIR" || return 1
	COUNT=`ls |wc -l`
	if [ $COUNT -eq 0 ]; then
		return 0
	fi
	PREV_BKP=
	for BKP in *; do
		DATE=${BKP:0:10}
		TIME=${BKP:11:8}
		TIME=${TIME//-/:}
		BKP_FMT_TS="$DATE $TIME"
		BKP_TIMESTAMP=`date --date="$BKP_FMT_TS" +%Y%m%d%H%M%S`
		if [ $BKP_TIMESTAMP -ge $REF_TIMESTAMP ]; then
			return
		fi
		if [ -n "$PREV_BKP" ]; then
			write_out "Removing expired full backup $PREV_BKP"
			rm -fr $PREV_BKP || return 1
			PREV_BKP=`echo $PREV_BKP | cut -d . -f 1`
		fi
		PREV_BKP=$BKP
	done
}

function reset_master()
{
	CRED_OPT=`mount_credentials_opt` || return 1
	mysql --defaults-file="$MYSQL_CONF_FILE" $CRED_OPT -e "reset master;" >/dev/null || return 1
}

function restore()
{
	PITR=0
	RESTORE_TABLE_LIST=
	REQ_TIMESTAMP=`date +%Y-%m-%d_%H:%M:%S`
	SLAVE=0
	ANSWER_YES=0
	cd "$BASE_BACKUP_DIR" || return 1
	DIR=`ls | tail -n 1 | cut -d . -f 1`
	if [ -z "$DIR" ]; then
		write_out "No backup to be restored"
		return 1
	fi
	local OPTIND l_opt
	while getopts "np:d:st:x:y" l_opt; do
		case $l_opt in
			d)
				RESTORE_DB_OLD_NAME=${OPTARG}
				;;
			n)
				DB_COPY=1
				;;
			p)
				PITR=1
				REQ_TIMESTAMP=${OPTARG}
				ISO_REQ_TIMESTAMP=${OPTARG/_/ }
				DIR=`find_base_backup "$ISO_REQ_TIMESTAMP"` || return 1
				;;
			s)
				SLAVE=1
				;;
			t)
				RESTORE_TABLE_LIST="$RESTORE_TABLE_LIST ${OPTARG}"
				;;
			x)
				RESTORE_DB_NEW_NAME=${OPTARG}
				;;
			y)
				ANSWER_YES=1
				;;
			\?)
				echo "Invalid option: -$OPTARG" >&2
				;;
		esac
	done
	if ! confirm_operation; then
		return 0
	fi
	restore_validate_options || return 1
	if ! [ -f "$MYSQL_CONF_FILE" ]; then
		write_out "Cannot find readable file '$MYSQL_CONF_FILE'"
		return 1
	fi
	#check_backup_consistency || return 1
	cd "$BACKUP_DIR" || return 1
	if [ -n "$RESTORE_DB_OLD_NAME" -o -n "$RESTORE_TABLE_LIST" ]; then
		USE_AUX_INSTANCE=1
	fi
	DB_COPY=0
	MOMENT=`date +%Y%m%d-%H%M%S`
	AUX_SOCKET_OPT=
	if ! [ -d "$BASE_BACKUP_DIR" ]; then
		write_out "No backup to be restored"
		return 1
	fi
	DATADIR="`crudini --get \"$MYSQL_CONF_FILE\" mysqld datadir`" 2>/dev/null
	REDODIR="`crudini --get \"$MYSQL_CONF_FILE\" mysqld innodb_log_group_home_dir 2>/dev/null`"
	UNDODIR="`crudini --get \"$MYSQL_CONF_FILE\" mysqld innodb_undo_directory 2>/dev/null`"
	BINLOG_INDEX="`crudini --get \"$MYSQL_CONF_FILE\" mysqld log_bin_index 2>/dev/null`"
	BINLOG_MASK="`crudini --get \"$MYSQL_CONF_FILE\" mysqld log_bin 2>/dev/null`"
	if [ -n "$BINLOG_MASK" ]; then
		BINLOG_DIR="`dirname $BINLOG_MASK`" || return 1
	fi

	#secure files directory
	SECURE_DIR="`crudini --get \"$MYSQL_CONF_FILE\" mysqld secure_file_priv 2>/dev/null`"

	#mysqld user
	MYSQLD_USER="`crudini --get \"$MYSQL_CONF_FILE\" mysqld user 2>/dev/null`"

	if [ "$RESTORE_DB_OLD_NAME" = "mysql" -o "$RESTORE_DB_OLD_NAME" = "sys" -o "$RESTORE_DB_OLD_NAME" = "information_schema" ]; then
		echo "Invalid database name '$RESTORE_DB_OLD_NAME'" >&2
		return 1
	fi
	if [ "$RESTORE_DB_NEW_NAME" = "mysql" -o "$RESTORE_DB_NEW_NAME" = "sys" -o "$RESTORE_DB_NEW_NAME" = "information_schema" ]; then
		echo "Invalid database name '$RESTORE_DB_NEW_NAME'" >&2
		return 1
	fi
	CONFIG="$MYSQL_CONF_FILE"
	if [ $USE_AUX_INSTANCE -eq 1 ]; then
		cd "$AUX_BASEDIR" || return 1
		cd -
		check_aux_binaries || return 1
		check_aux_dir_space $DIR || return 1
		if [ -z "$AUX_BASEDIR" ]; then
			echo "When restoring a single database or a table, AUX_BASEDIR configuration must be set" >&2
			return 1
		fi
		if ! [ -d "$AUX_BASEDIR" ]; then
			echo "AUX_BASEDIR: not a directory (or access is denied)" >&2
			return 1
		fi
		AUX_BASEDIR=`mktemp -d -p "$AUX_BASEDIR" -t "aux_XXXXXXXX"` || return 1
		BASENAME=`basename "$AUX_BASEDIR"` || return 1
		chown mysql "$AUX_BASEDIR" || return 1
		DB_COPY=1
		AUX_CONFIG=/tmp/${BASENAME}.cnf
		CONFIG="$AUX_CONFIG"
		AUX_DATADIR="$AUX_BASEDIR/datadir"
		AUX_LOG_ERROR="$AUX_BASEDIR/mysql.log"
		AUX_PID_FILE="$AUX_BASEDIR/pid_file"
		AUX_SOCKET="$AUX_BASEDIR/socket"
		AUX_PORT=`find_aux_port` || return 1
		AUX_SOCKET_OPT="--socket=$AUX_SOCKET"
	fi
	check_new_db_name || return 1
	write_out "Starting restore"
	MODE=off
	if [ $SLAVE -eq 1 ]; then
		MODE=on
	fi
	write_out "Slave mode: $MODE"
	if [ $USE_AUX_INSTANCE -eq 0 ]; then	
		restore_target_instance $DIR || return 1
	else 
		restore_aux_instance $DIR || return 1
	fi
	if [ $SLAVE -eq 1 ]; then
		show_binlog_position $DIR
		return
	fi
	recover $DIR "$REQ_TIMESTAMP" "$CONFIG" || return 1
	if [ -n "$RESTORE_DB_OLD_NAME" ]; then
		copy_recovered_db || return 1
	fi
	if [ -n "$RESTORE_TABLE_LIST" ]; then
		copy_restored_tables || return 1
	fi
	if [ $PITR -eq 1 -a $DB_COPY -eq 0 ]; then
		create_incarnation $MOMENT
		write_out "Resetting binary logs"
		reset_master || return 1
	fi
	ITYPE="restricted"
	if [ $USE_AUX_INSTANCE -eq 1 ]; then
		ITYPE="aux"
	fi
	mysql_stop "$CONFIG" $ITYPE
}

function restore_aux_instance()
{
	DIR="${BASE_BACKUP_DIR}/${1}"
	create_aux_config $DIR || return 1
	rm -fr "$AUX_DATADIR/*" || return 1
	mkdir -p $AUX_DATADIR || return 1
	LIM_MEM_OPT=`mount_limit_memory_option`
	FULL_DIR="${BASE_BACKUP_DIR}/${DIR}"
	write_out "===== STARTING mysqlbackup ====="
	if [ $BG_MODE -eq 0 ]; then
		mysqlbackup --defaults-file=$AUX_CONFIG --read-threads=$READ_THREADS --write-threads=$WRITE_THREADS --backup-dir="$FULL_DIR" $LIM_MEM_OPT copy-back 2>&1 || return 1
	else
		mysqlbackup --defaults-file=$AUX_CONFIG --read-threads=$READ_THREADS --write-threads=$WRITE_THREADS --backup-dir="$FULL_DIR" $LIM_MEM_OPT copy-back >>"$LOG_FILE" 2>&1 || return 1
	fi
	write_out "===== FINISHED mysqlbackup ===== "
	chown -R mysql $AUX_DATADIR || return 1
}

function restore_target_instance()
{
	DIR="${1}"
	MYSQLD_USER="`crudini --get \"$MYSQL_CONF_FILE\" mysqld user`" 2>/dev/null
	#if server is running, abort
	if mysqladmin --defaults-file="$MYSQL_CONF_FILE" ping >/dev/null 2>&1; then
		write_out "MySQL is running - aborting"
		return 1
	fi
	mkdir -p "$DATADIR" || return 1
	if [ -n "$MYSQLD_USER" ]; then
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$DATADIR" || return 1
		fi
	fi

	if [ -n "$UNDODIR" ]; then
		if [ "${UNDODIR:0:1}" != "/" ]; then
			UNDODIR="$DATADIR/$UNDODIR"
		fi
		mkdir -p "$UNDODIR" || return 1
		rm -fr "$UNDODIR/"* || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$UNDODIR" || return 1
		fi
	fi

	#redo
	if [ -n "$REDODIR" ]; then
		if [ "${REDODIR:0:1}" != "/" ]; then
			REDODIR="$DATADIR/$REDODIR"
		fi
		mkdir -p "$REDODIR" || return 1
		if ls -d "$REDODIR"/* >/dev/null 2>&1; then
			write_out "Redo directory [$REDODIR] must be empty"
			return 1
		fi
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$REDODIR" || return 1
		fi
	fi
	if [ -n "$BINLOG_DIR" ]; then
		mkdir -p "$BINLOG_DIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$BINLOG_DIR" || return 1
		fi
	fi
	if [ -n "$SECURE_DIR" ]; then
		mkdir -p "$SECURE_DIR" || return 1
		if [ -n "$MYSQLD_USER" ]; then
			chown $MYSQLD_USER "$SECURE_DIR" || return 1
		fi
		chmod 700 "$SECURE_DIR" || return 1
	fi
	check_empty_target_database || return 1
	check_target_instance_config || return 1
	LIM_MEM_OPT=`mount_limit_memory_option`
	FULL_DIR="${BASE_BACKUP_DIR}/${DIR}"
	write_out "===== STARTING mysqlbackup ====="
	if [ $BG_MODE -eq 0 ]; then
		mysqlbackup --defaults-file=$MYSQL_CONF_FILE --read-threads=$READ_THREADS --write-threads=$WRITE_THREADS --backup-dir="$FULL_DIR" $LIM_MEM_OPT copy-back 2>&1 || return 1 
	else
		mysqlbackup --defaults-file=$MYSQL_CONF_FILE --read-threads=$READ_THREADS --write-threads=$WRITE_THREADS --backup-dir="$FULL_DIR" $LIM_MEM_OPT copy-back >>"$LOG_FILE" 2>&1 || return 1 
	fi
	write_out "===== FINISHED mysqlbackup ====="
	if [ -n "$MYSQLD_USER" ]; then
		write_out "Setting permissions"
		chown -R $MYSQLD_USER "$DATADIR" || return 1
		if [ -n "$REDODIR" ]; then
			chown -R $MYSQLD_USER "$REDODIR" || return 1
		fi
		if [ -n "$UNDODIR" ]; then
			chown -R $MYSQLD_USER "$UNDODIR" || return 1
		fi
		if [ -n "$BINLOG_INDEX" ]; then
			if [ -n "$MYSQLD_USER" ]; then
				chown $MYSQLD_USER "$BINLOG_INDEX" || return 1
			fi
		fi
		if [ -n "$BINLOG_DIR" ]; then
			if [ -n "$MYSQLD_USER" ]; then
				chown $MYSQLD_USER "$BINLOG_DIR" || return 1
				chown $MYSQLD_USER "$BINLOG_DIR"/* || return 1
			fi
		fi
	fi
}

function restore_validate_options()
{
	if [ -n "$RESTORE_DB_NEW_NAME" -a -z "$RESTORE_DB_OLD_NAME" ]; then
		echo "Option -x requires -d" >&2
		return 1
	fi
	if [ -n "$RESTORE_DB_OLD_NAME" -a -n "$RESTORE_TABLE_LIST" ]; then
		echo "Options -d and -t cannot be used together" >&2
		return 1
	fi
	if [ -n "$RESTORE_TABLE_LIST" ]; then
		restore_validate_tablenames || return 1
	fi
}

function restore_validate_tablenames()
{
	for QT in $RESTORE_TABLE_LIST; do
		if ! echo "$QT" | grep \\. >/dev/null; then
			echo "Invalid table name: '$QT' - table names must be qualified with schema" >&2
			return 1
		fi
		SCHEMA=`echo $QT | cut -d . -f 1`
		TABLE=`echo $QT | cut -d . -f 2`
		if [ -z "$SCHEMA" -o -z "$TABLE" ]; then
			echo "Invalid table name: '$QT' - table names must be qualified with schema" >&2
			return 1
		fi
	done
}

function show_binlog_position()
{
	BACKUP=$1
	NAME=`get_base_backup_binlog_name $BACKUP` || return 1
	POS=`get_base_backup_binlog_position $BACKUP` || return 1
	write_out "Backup binary log information:"
	write_out "   Name: $NAME"
	write_out "   Position: $POS"
}

function validate_config()
{
	#read-only
	if [ "$READ_ONLY" != "0" -a "$READ_ONLY" != "1" ]; then
		write_out "Invalid value for READ_ONLY configuration"
		return 1
	fi
	check_log_config || return 1
}

function backup()
{
	if [ $READ_ONLY -eq 1 ]; then
		write_out "Read-only mode is enabled in configuration"
		return 1
	fi

	CRED_OPT=`mount_target_credentials_opt`
	if [ $BG_MODE -eq 1 ]; then
		if ! mysqladmin --defaults-file="$MYSQL_CONF_FILE" $CRED_OPT ping >/dev/null 2>&1; then
			write_out "No MySQL server running - ignoring backup"
			return
		fi
	fi
	if ! which mysqlbackup >/dev/null 2>&1; then
		write_out "Cannot find 'mysqlbackup' in PATH"
		return 1
	fi
	CMD=`echo $1 | awk '{print tolower($0)}'`
	shift
	BINLOG_MASK="`crudini --get \"$MYSQL_CONF_FILE\" mysqld log_bin`" 2>/dev/null
	if [ -z "$BINLOG_MASK" ]; then
		BINLOG_MASK="`crudini --get \"$MYSQL_CONF_FILE\" mysqld log-bin`" 2>/dev/null
	fi
	if [ -z "$BINLOG_MASK" ]; then
		write_out "Cannot find binary logs directory in MySQL configuration file. Check if '$MYSQL_CONF_FILE' has variable [mysqld]:log_bin."
		return 1
	fi
	BINLOG_DIR="`dirname \"$BINLOG_MASK\"`" || return 1
	DATADIR="`crudini --get \"$MYSQL_CONF_FILE\" mysqld datadir`" || return 1
	case $CMD in
		full)
			backup_full $* || return 1
			;;
		binlog)
			backup_binlog $* || return 1
			;;
		*)
			usage
			return 1
			;;
	esac
}

function backup_binlog()
{
	local OPTIND l_opt
	while getopts "" opt; do
		case $opt in
			\?)
				echo "Invalid option: -$OPTARG" >&2
				usage
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if  [ $# -ne 0 ]; then
		usage
		return 1
	fi
	cd "$BACKUP_DIR" || return 1
	if ! exist_base_backup; then
		echo "No full backup was previously done" >&2
		return 1
	fi
	CRED_OPT=`mount_target_credentials_opt`

	#flush logs
	mysqladmin --defaults-file="$MYSQL_CONF_FILE" $CRED_OPT flush-logs || return 1

	#list binlogs, just ignoring the last one
	LIST_FILE=`mktemp /tmp/mytjrsrman.XXXXXX` || return 1
	mysql --defaults-file="$MYSQL_CONF_FILE" $CRED_OPT -e "show binary logs\G" | grep -wi log_name | cut -d \  -f 3 >$LIST_FILE || return 1
	TOTAL=`cat $LIST_FILE | wc -l` || return 1
	COUNT=$((TOTAL - 1))
	LIST=`head -n $COUNT $LIST_FILE`
	LAST_BINLOG=`tail -n 1 $LIST_FILE`
	rm $LIST_FILE
	for BINLOG in $LIST; do
		if ! [ -f "$BINLOG_BACKUP_DIR/${BINLOG}.gz" ]; then
			LONG_LOGSEQ=`echo $BINLOG | cut -d . -f 2`
			LOGSEQ=`expr $LONG_LOGSEQ + 0`
			write_out "Saving binary log sequence $LOGSEQ"
			gzip -c9 "$BINLOG_DIR/$BINLOG" >"$BINLOG_BACKUP_DIR/${BINLOG}.gz" || return 1
		fi
		if [ $PURGE_BINLOGS -eq 1 ]; then
			purge_binlogs $BINLOG || return 1
		fi
	done
	if [ $PURGE_BINLOGS -eq 1 ]; then
		purge_binlogs $LAST_BINLOG || return 1
	fi
}

function backup_full()
{
	local OPTIND l_opt
	while getopts "" opt; do
		case $opt in
			\?)
				echo "Invalid option: -$OPTARG" >&2
				usage
				return 1
				;;
		esac
	done
	shift $((OPTIND-1))
	if  [ $# -ne 0 ]; then
		usage
		return 1
	fi
	CRED_OPT=`mount_credentials_opt` || return 1
	cd "$BACKUP_DIR" || return 1
	mkdir -p "$BASE_BACKUP_DIR" || return 1
	DATE_VAL=`date +%Y-%m-%d`
	TIME_VAL=`date +%H-%M-%S`
	TIMESTAMP=${DATE_VAL}_${TIME_VAL}
	DIRECTORY="${BASE_BACKUP_DIR}/${TIMESTAMP}"
	mkdir -p "$DIRECTORY" || return 1
	IMAGE_FILE="${BASE_BACKUP_DIR}/${TIMESTAMP}.dat"
	LIM_MEM_OPT=`mount_limit_memory_option`
	write_out "===== STARTING mysqlbackup ====="
	if [ $BG_MODE -eq 0 ]; then
		mysqlbackup --defaults-file="$MYSQL_CONF_FILE" $CRED_OPT --read-threads=$READ_THREADS --write-threads=$WRITE_THREADS --backup-dir="${DIRECTORY}" $LIM_MEM_OPT backup-and-apply-log 2>&1
	else
		mysqlbackup --defaults-file="$MYSQL_CONF_FILE" $CRED_OPT --read-threads=$READ_THREADS --write-threads=$WRITE_THREADS --backup-dir="${DIRECTORY}" $LIM_MEM_OPT backup-and-apply-log >>"$LOG_FILE" 2>&1
	fi
	RETCODE=$?
	write_out "===== FINISHED mysqlbackup ====="
	#check_backup_consistency
	if [ $RETCODE -ne 0 ]; then
		rm -fr "${DIRECTORY}"
		return 1
	fi
	cd "$BASE_BACKUP_DIR" || return 1
	LAST_BACKUP=`ls | tail -n 1` || return 1
	write_out "Saving MySQL config file"
	cp "$MYSQL_CONF_FILE" "$DIRECTORY/my.cnf" || return 1
	write_out "Saving mytjrsrman config file"
	cp "$CONFIG_FILE" "$DIRECTORY/mytjrsrman.conf" || return 1
	fix_backup_timestamp $LAST_BACKUP || return 1
	backup_binlog || return 1
	remove_old_backups || return 1
}

function run()
{
	validate_config || return 1
	CMD=`echo $1 | awk '{print tolower($0)}'`
	shift
	USE_AUX_INSTANCE=0
	case $CMD in
		query)
			query $* || return 1
			;;
		backup)
			header
			check_lock_file || return 1
			if ! backup $*; then
				remove_lock_file
				return 1
			fi
			remove_lock_file
			;;
		init)
			init || return 1
			;;
		list)
			if ! list $*; then
				return 1
			fi
			;;
		restore)
			check_lock_file || return 1
			if ! restore $*; then
				remove_lock_file
				return 1
			fi
			remove_lock_file
			;;
		*)
			usage
			if [ -n "$CMD" ]; then
				echo "Invalid command: $CMD" >&2
			fi
			return 1
			;;
	esac

	#if bg mode
	if [ $BG_MODE -eq 1 ]; then
		#remove old logs
		find "$LOG_DIR" -mtime +30 -delete
		write_out "Finished"
	fi
}

function stop_aux_instance()
{
	STOP_TIMEOUT=30
	TS=`date +"%H:%M:%S"`
	if [ $BG_MODE -eq 0 ]; then
		echo "[$TS] Stopping aux instance"
	else
		echo "[$TS] Stopping aux instance" >>"$LOG_FILE"
	fi
	kill `cat $AUX_PID_FILE` || return 1
	sleep 3
	COUNT=3
	while [ $COUNT -lt $STOP_TIMEOUT ]; do
		sleep 1
		COUNT=`expr $COUNT + 1`
		if ! [ -f $AUX_PID_FILE ]; then
			rm "$AUX_CONFIG"
			rm -fr "$AUX_BASEDIR"
			return $RESULT
		fi
	done
	echo "Timeout reached waiting for aux instance to stop. Check log file at $AUX_LOG_ERROR." >&2
	return 1
}

function uncompress_backup()
{
	BKP="$1"
	TAR_FILE="${BASE_BACKUP_DIR}/${BKP}.tgz"
	tar -C "${BASE_BACKUP_DIR}" -x -z -f "${TAR_FILE}" || return 1
}

function usage()
{
	echo "Usage:"
	echo "mytjrsrman [-b] [ -c <config file> ] init"
	echo "mytjrsrman [-b] [ -c <config file> ] backup full|binlog"
	echo "mytjrsrman [-b] [ -c <config file> ] restore [ <restore options> ]"
	echo "mytjrsrman [-b] [ -c <config file> ] list [-h <hostname> [-P <port>]] full|binlog"
}

function wait_server_start()
{
	TIMEOUT=20
	CONF_FILE="$1"
	LOG_ERROR="`crudini --get \"$CONF_FILE\" mysqld log_error 2>/dev/null`"
	PID_FILE="`crudini --get \"$CONF_FILE\" mysqld pid_file 2>/dev/null`"
	sleep 2
	COUNT=0
	while [ $COUNT -lt $TIMEOUT ]; do
		if tail -n 20 "$LOG_ERROR" | grep -iw "ready for connections" >/dev/null; then
			return 0
		fi
		if ! [ -f "$PID_FILE" ]; then
			return 1
		fi
		sleep 2
		COUNT=$((COUNT + 2))
	done
}

function write_out()
{
	MSG="$1"
	TS=`date +"%H:%M:%S"`
	if [ $BG_MODE -eq 0 ]; then
		echo "[$$ $TS] $MSG"
	else
		echo "[$$ $TS] $MSG" >>"$LOG_FILE"
	fi
}

if [ "$DEBUG" == "1" ]; then
	set -x
fi
MYSQL_CONF_FILE=/etc/my.cnf
NOW_EPOCH=`date +%s`
DATE_VAL=`date +%Y-%m-%d`
TIME_VAL=`date +%H:%M:%S`
if [ $# -lt 1 ]; then
	usage
	exit
fi
MAX_READ_THREADS=20
MAX_WRITE_THREADS=20
BG_MODE=0
READ_THREADS=1
WRITE_THREADS=1
CONFIG_FILE=/etc/mytjrsrman.conf
READ_ONLY=0
PURGE_BINLOGS=1
while getopts "bc:" opt; do
	case $opt in
		b)
			BG_MODE=1
			;;
		c)
			CONFIG_FILE="$OPTARG"
			;;
		\?)
			echo "Invalid option: -$OPTARG" >&2
			;;
	esac
done
shift $((OPTIND-1))
source "$CONFIG_FILE" || exit -1
check_depends || exit -1
#check mysql conf file
if ! [ -f "$MYSQL_CONF_FILE" ]; then
	echo "MySQL config '$MYSQL_CONF_FILE' does not exist or is not a file." >&2
	exit -1
fi
MYHOST=`hostname`
BASE_BACKUP_DIR="$BACKUP_DIR/base"
BINLOG_BACKUP_DIR="$BACKUP_DIR/binlog"
RESTORE_BACKUP_DIR="$BACKUP_DIR/restore"
if [ $BG_MODE -eq 1 ]; then
	TIMESTAMP=`date +%Y-%m-%d`
	LOG_FILE="`mktemp \"${LOG_DIR}/${MYHOST}.${TIMESTAMP}.XXXXXX.log\"`" || exit 1
fi
run $*
RETCODE=$?
exit $RETCODE
